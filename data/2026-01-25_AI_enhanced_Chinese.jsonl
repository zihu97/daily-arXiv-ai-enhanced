{"id": "2601.16032", "categories": ["cs.PF", "cs.AI", "cs.LG", "cs.OS"], "pdf": "https://arxiv.org/pdf/2601.16032", "abs": "https://arxiv.org/abs/2601.16032", "authors": ["Yifan Zhu", "Yekai Pan", "Chen Ding"], "title": "Sawtooth Wavefront Reordering: Enhanced CuTile FlashAttention on NVIDIA GB10", "comment": null, "summary": "High-performance attention kernels are essential for Large Language Models. This paper presents analysis of CuTile-based Flash Attention memory behavior and a technique to improve its cache performance. In particular, our analysis on the NVIDIA GB10 (Grace Blackwell) identifies the main cause of L2 cache miss. Leveraging this insight, we introduce a new programming technique called Sawtooth Wavefront Reordering that reduces L2 misses. We validate it in both CUDA and CuTile, observing 50\\% or greater reduction in L2 misses and up to 60\\% increase in throughput on GB10.", "AI": {"tldr": "\u672c\u6587\u5206\u6790\u57fa\u4e8eCuTile\u7684Flash Attention\u5728NVIDIA GB10\u4e0a\u7684\u7f13\u5b58\u95ee\u9898\uff0c\u63d0\u51fa\u952f\u9f7f\u6ce2\u524d\u91cd\u6392\u5e8f\u6280\u672f\u4ee5\u51cf\u5c11L2\u7f13\u5b58\u7f3a\u5931\u5e76\u63d0\u5347\u541e\u5410\u91cf\u3002", "motivation": "\u9ad8\u6027\u80fd\u6ce8\u610f\u529b\u6838\u5bf9\u5927\u8bed\u8a00\u6a21\u578b\u81f3\u5173\u91cd\u8981\uff0c\u9700\u4f18\u5316\u7f13\u5b58\u6027\u80fd\u4ee5\u63d0\u9ad8\u6548\u7387\u3002", "method": "\u5206\u6790GB10\u663e\u5361L2\u7f13\u5b58\u7f3a\u5931\u4e3b\u8981\u539f\u56e0\uff0c\u8bbe\u8ba1\u952f\u9f7f\u6ce2\u524d\u91cd\u6392\u5e8f\u6280\u672f\u4ee5\u6539\u5584\u7f13\u5b58\u8868\u73b0\u3002", "result": "\u5b9e\u65bd\u540eL2\u7f13\u5b58\u7f3a\u5931\u7387\u964d\u4f4e\u8d8550%\uff0c\u541e\u5410\u91cf\u63d0\u5347\u8fbe60%\uff0c\u9002\u7528\u4e8eCUDA\u548cCuTile\u73af\u5883\u3002", "conclusion": "\u8be5\u6280\u672f\u9a8c\u8bc1\u6709\u6548\uff0c\u663e\u8457\u52a0\u901f\u4e86\u5927\u8bed\u8a00\u6a21\u578b\u7684\u6ce8\u610f\u529b\u6838\u6027\u80fd\u3002"}}
{"id": "2601.15710", "categories": ["cs.AR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.15710", "abs": "https://arxiv.org/abs/2601.15710", "authors": ["Jiahao Zhang", "Zifan He", "Nicholas Fraser", "Michaela Blott", "Yizhou Sun", "Jason Cong"], "title": "FlexLLM: Composable HLS Library for Flexible Hybrid LLM Accelerator Design", "comment": null, "summary": "We present FlexLLM, a composable High-Level Synthesis (HLS) library for rapid development of domain-specific LLM accelerators. FlexLLM exposes key architectural degrees of freedom for stage-customized inference, enabling hybrid designs that tailor temporal reuse and spatial dataflow differently for prefill and decode, and provides a comprehensive quantization suite to support accurate low-bit deployment. Using FlexLLM, we build a complete inference system for the Llama-3.2 1B model in under two months with only 1K lines of code. The system includes: (1) a stage-customized accelerator with hardware-efficient quantization (12.68 WikiText-2 PPL) surpassing SpinQuant baseline, and (2) a Hierarchical Memory Transformer (HMT) plug-in for efficient long-context processing. On the AMD U280 FPGA at 16nm, the accelerator achieves 1.29$\\times$ end-to-end speedup, 1.64$\\times$ higher decode throughput, and 3.14$\\times$ better energy efficiency than an NVIDIA A100 GPU (7nm) running BF16 inference; projected results on the V80 FPGA at 7nm reach 4.71$\\times$, 6.55$\\times$, and 4.13$\\times$, respectively. In long-context scenarios, integrating the HMT plug-in reduces prefill latency by 23.23$\\times$ and extends the context window by 64$\\times$, delivering 1.10$\\times$/4.86$\\times$ lower end-to-end latency and 5.21$\\times$/6.27$\\times$ higher energy efficiency on the U280/V80 compared to the A100 baseline. FlexLLM thus bridges algorithmic innovation in LLM inference and high-performance accelerators with minimal manual effort.", "AI": {"tldr": "FlexLLM\u662f\u4e00\u79cd\u53ef\u7ec4\u5408\u7684\u9ad8\u7ea7\u7efc\u5408\u5e93\uff0c\u7528\u4e8e\u5feb\u901f\u5f00\u53d1\u9886\u57df\u4e13\u7528\u5927\u8bed\u8a00\u6a21\u578b\u52a0\u901f\u5668\uff0c\u652f\u6301\u9636\u6bb5\u5b9a\u5236\u63a8\u7406\u548c\u9ad8\u6548\u91cf\u5316\u90e8\u7f72\u3002", "motivation": "\u89e3\u51b3\u73b0\u6709\u786c\u4ef6\u96be\u4ee5\u9ad8\u6548\u9002\u914d\u5927\u8bed\u8a00\u6a21\u578b\u63a8\u7406\u4e2d\u9884\u586b\u5145\u4e0e\u89e3\u7801\u9636\u6bb5\u7684\u5dee\u5f02\u5316\u9700\u6c42\uff0c\u4ee5\u53ca\u957f\u4e0a\u4e0b\u6587\u5904\u7406\u74f6\u9888\u95ee\u9898\u3002", "method": "\u63d0\u4f9b\u67b6\u6784\u8bbe\u8ba1\u81ea\u7531\u5ea6\u5b9e\u73b0\u9636\u6bb5\u5b9a\u5236\u6df7\u5408\u8bbe\u8ba1\uff0c\u96c6\u6210\u91cf\u5316\u5957\u4ef6\uff0c\u5e76\u5f00\u53d1Hierarchical Memory Transformer\u63d2\u4ef6\u4f18\u5316\u957f\u4e0a\u4e0b\u6587\u5904\u7406\u3002", "result": "\u5728AMD U280 FPGA\u4e0a\u76f8\u8f83NVIDIA A100 GPU\uff1a\u7aef\u5230\u7aef\u52a0\u901f1.29\u500d\uff0c\u89e3\u7801\u541e\u5410\u91cf\u63d0\u53471.64\u500d\u80fd\u6548\u63d0\u9ad83.14\u500d\uff1b\u4f7f\u7528HMT\u63d2\u4ef6\u540e\u9884\u586b\u5145\u5ef6\u8fdf\u964d\u4f4e23.23\u500d\uff0c\u4e0a\u4e0b\u6587\u7a97\u53e3\u6269\u592764\u500d\u3002", "conclusion": "\u8be5\u6846\u67b6\u4ee5\u6700\u5c11\u4eba\u5de5\u5b9e\u73b0LLM\u7b97\u6cd5\u521b\u65b0\u4e0e\u9ad8\u6027\u80fd\u786c\u4ef6\u52a0\u901f\u7684\u7ed3\u5408\uff0c\u663e\u8457\u63d0\u5347FPGA\u5e73\u53f0\u4e0a\u7684\u63a8\u7406\u6548\u7387\u548c\u80fd\u6548\u3002"}}
{"id": "2601.16091", "categories": ["cs.MA", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.16091", "abs": "https://arxiv.org/abs/2601.16091", "authors": ["Saar Cohen"], "title": "Delayed Assignments in Online Non-Centroid Clustering with Stochastic Arrivals", "comment": "To Appear in the 25th International Conference on Autonomous Agents and Multiagent Systems (AAMAS), 2026", "summary": "Clustering is a fundamental problem, aiming to partition a set of elements, like agents or data points, into clusters such that elements in the same cluster are closer to each other than to those in other clusters. In this paper, we present a new framework for studying online non-centroid clustering with delays, where elements, that arrive one at a time as points in a finite metric space, should be assigned to clusters, but assignments need not be immediate. Specifically, upon arrival, each point's location is revealed, and an online algorithm has to irrevocably assign it to an existing cluster or create a new one containing, at this moment, only this point. However, we allow decisions to be postponed at a delay cost, instead of following the more common assumption of immediate decisions upon arrival. This poses a critical challenge: the goal is to minimize both the total distance costs between points in each cluster and the overall delay costs incurred by postponing assignments. In the classic worst-case arrival model, where points arrive in an arbitrary order, no algorithm has a competitive ratio better than sublogarithmic in the number of points. To overcome this strong impossibility, we focus on a stochastic arrival model, where points' locations are drawn independently across time from an unknown and fixed probability distribution over the finite metric space. We offer hope for beyond worst-case adversaries: we devise an algorithm that is constant competitive in the sense that, as the number of points grows, the ratio between the expected overall costs of the output clustering and an optimal offline clustering is bounded by a constant.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e00\u79cd\u5728\u7ebf\u975e\u4e2d\u5fc3\u805a\u7c7b\u6846\u67b6\uff0c\u652f\u6301\u5ef6\u8fdf\u51b3\u7b56\uff0c\u5728\u968f\u673a\u5230\u8fbe\u6a21\u578b\u4e0b\u5b9e\u73b0\u5e38\u6570\u7ade\u4e89\u6bd4\u3002", "motivation": "\u89e3\u51b3\u6700\u574f\u60c5\u51b5\u5230\u8fbe\u6a21\u578b\u4e0b\u6027\u80fd\u5dee\u7684\u95ee\u9898\uff0c\u5141\u8bb8\u5ef6\u8fdf\u5206\u914d\u4ee5\u8054\u5408\u4f18\u5316\u805a\u7c7b\u8ddd\u79bb\u6210\u672c\u548c\u5ef6\u8fdf\u6210\u672c\u3002", "method": "\u5047\u8bbe\u70b9\u4f4d\u7f6e\u4ece\u672a\u77e5\u5206\u5e03\u72ec\u7acb\u62bd\u6837\uff0c\u8bbe\u8ba1\u5728\u7ebf\u7b97\u6cd5\u5ef6\u8fdf\u5206\u914d\u51b3\u7b56\uff1b\u70b9\u5230\u8fbe\u65f6\u53ef\u76f4\u63a5\u805a\u7c7b\u6216\u5ef6\u540e\u51b3\u7b56\u4ea7\u751f\u6210\u672c\u3002", "result": "\u7b97\u6cd5\u5728\u70b9\u6570\u589e\u591a\u65f6\uff0c\u9884\u671f\u603b\u6210\u672c\u4e0e\u6700\u4f18\u79bb\u7ebf\u805a\u7c7b\u7684\u6bd4\u7387\u6709\u5e38\u6570\u4e0a\u754c\uff0c\u7ade\u4e89\u6027\u80fd\u8d85\u8d8a\u6700\u574f\u60c5\u5f62\u3002", "conclusion": "\u5728\u968f\u673a\u73af\u5883\u4e2d\u6709\u6548\u514b\u670d\u4e0d\u53ef\u80fd\u6027\uff0c\u8bc1\u660e\u5728\u7ebf\u805a\u7c7b\u53ef\u83b7\u6052\u5b9a\u7ade\u4e89\u6bd4\uff0c\u63d0\u5347\u5b9e\u7528\u6027\u4e0e\u6269\u5c55\u6027\u3002"}}
{"id": "2601.15335", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2601.15335", "abs": "https://arxiv.org/abs/2601.15335", "authors": ["Yi Zhai", "Dian Shen", "Junzhou Luo", "Bin Yang"], "title": "ToolCaching: Towards Efficient Caching for LLM Tool-calling", "comment": null, "summary": "Recent advances in Large Language Models (LLMs) have revolutionized web applications, enabling intelligent search, recommendation, and assistant services with natural language interfaces. Tool-calling extends LLMs with the ability to interact with external APIs, greatly enhancing their practical utility. While prior research has improved tool-calling performance by adopting traditional computer systems techniques, such as parallel and asynchronous execution, the challenge of redundant or repeated tool-calling requests remains largely unaddressed. Caching is a classic solution to this problem, but applying it to LLM tool-calling introduces new difficulties due to heterogeneous request semantics, dynamic workloads, and varying freshness requirements, which render conventional cache policies ineffective. To address these issues, we propose ToolCaching, an efficient feature-driven and adaptive caching framework for LLM tool-calling systems. ToolCaching systematically integrates semantic and system-level features to evaluate request cacheability and estimate caching value. At its core, the VAAC algorithm integrates bandit-based admission with value-driven, multi-factor eviction, jointly accounting for request frequency, recency, and caching value. Extensive experiments on synthetic and public tool-calling workloads demonstrate that ToolCaching with VAAC achieves up to 11% higher cache hit ratios and 34% lower latency compared to standard policies, effectively accelerating LLM tool-calling in practical applications.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.15578", "categories": ["cs.NI", "cs.AI", "cs.LG", "cs.RO"], "pdf": "https://arxiv.org/pdf/2601.15578", "abs": "https://arxiv.org/abs/2601.15578", "authors": ["Cyril Shih-Huan Hsu", "Xi Li", "Lanfranco Zanzi", "Zhiheng Yang", "Chrysa Papagianni", "Xavier Costa P\u00e9rez"], "title": "MapViT: A Two-Stage ViT-Based Framework for Real-Time Radio Quality Map Prediction in Dynamic Environments", "comment": "This paper has been accepted for publication at IEEE International Conference on Communications (ICC) 2026", "summary": "Recent advancements in mobile and wireless networks are unlocking the full potential of robotic autonomy, enabling robots to take advantage of ultra-low latency, high data throughput, and ubiquitous connectivity. However, for robots to navigate and operate seamlessly, efficiently and reliably, they must have an accurate understanding of both their surrounding environment and the quality of radio signals. Achieving this in highly dynamic and ever-changing environments remains a challenging and largely unsolved problem. In this paper, we introduce MapViT, a two-stage Vision Transformer (ViT)-based framework inspired by the success of pre-train and fine-tune paradigm for Large Language Models (LLMs). MapViT is designed to predict both environmental changes and expected radio signal quality. We evaluate the framework using a set of representative Machine Learning (ML) models, analyzing their respective strengths and limitations across different scenarios. Experimental results demonstrate that the proposed two-stage pipeline enables real-time prediction, with the ViT-based implementation achieving a strong balance between accuracy and computational efficiency. This makes MapViT a promising solution for energy- and resource-constrained platforms such as mobile robots. Moreover, the geometry foundation model derived from the self-supervised pre-training stage improves data efficiency and transferability, enabling effective downstream predictions even with limited labeled data. Overall, this work lays the foundation for next-generation digital twin ecosystems, and it paves the way for a new class of ML foundation models driving multi-modal intelligence in future 6G-enabled systems.", "AI": {"tldr": "\u7814\u7a76\u8005\u63d0\u51faMapViT\u6846\u67b6\uff0c\u57fa\u4e8e\u89c6\u89c9Transformer\u9884\u6d4b\u73af\u5883\u53d8\u5316\u548c\u65e0\u7ebf\u7535\u4fe1\u53f7\u8d28\u91cf\uff0c\u4ee5\u5b9e\u73b0\u79fb\u52a8\u673a\u5668\u4eba\u7684\u53ef\u9760\u5bfc\u822a\u4e0e\u9ad8\u6548\u8fd0\u884c\u3002", "motivation": "\u89e3\u51b3\u52a8\u6001\u73af\u5883\u4e2d\u673a\u5668\u4eba\u5bf9\u5468\u56f4\u73af\u5883\u548c\u65e0\u7ebf\u7535\u4fe1\u53f7\u7406\u89e3\u4e0d\u8db3\u7684\u95ee\u9898\uff0c\u8fd9\u662f\u81ea\u52a8\u9a7e\u9a76\u9886\u57df\u7684\u6838\u5fc3\u6311\u6218\u3002", "method": "\u91c7\u7528\u4e24\u9636\u6bb5Vision Transformer\u67b6\u6784\uff0c\u501f\u9274\u5927\u578b\u8bed\u8a00\u6a21\u578b\u7684\u9884\u8bad\u7ec3\u7cbe\u8c03\u8303\u5f0fhungarian notation\u9884\u6d4b\u73af\u5883\u53d8\u5316\u4e0e\u4fe1\u53f7\u8d28\u91cf\uff0c\u4f7f\u7528ML\u6a21\u578b\u8bc4\u4f30\u6846\u67b6\u6027\u80fd\u3002", "result": "\u5b9e\u9a8c\u8bc1\u660e\u8be5\u6846\u67b6\u5b9e\u73b0\u5b9e\u65f6\u9884\u6d4b\uff0cViT\u5728\u7cbe\u5ea6\u548c\u8ba1\u7b97\u6548\u7387\u95f4\u4fdd\u6301\u5e73\u8861\uff0c\u63d0\u5347\u6570\u636e\u6548\u7387\u548c\u8fc1\u79fb\u80fd\u529b\uff0c\u9002\u5408\u8d44\u6e90\u53d7\u9650\u5e73\u53f0\u3002", "conclusion": "\u6b64\u5de5\u4f5c\u4e3a\u4e0b\u4e00\u4ee3\u6570\u5b57\u5b6a\u751f\u751f\u6001\u7cfb\u7edf\u5960\u5b9a\u57fa\u7840\uff0c\u5f15\u5bfc\u9762\u54116G\u7cfb\u7edf\u7684\u591a\u6a21\u6001\u667a\u80fdML\u57fa\u7840\u6a21\u578b\u53d1\u5c55\u3002"}}
{"id": "2601.15339", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.15339", "abs": "https://arxiv.org/abs/2601.15339", "authors": ["Jayant Havare", "Ashish Mittal", "Srikanth Tamilselvam", "Ganesh Ramakrishnan"], "title": "Lost in Transcription: How Speech-to-Text Errors Derail Code Understanding", "comment": null, "summary": "Code understanding is a foundational capability in software engineering tools and developer workflows. However, most existing systems are designed for English-speaking users interacting via keyboards, which limits accessibility in multilingual and voice-first settings, particularly in regions like India. Voice-based interfaces offer a more inclusive modality, but spoken queries involving code present unique challenges due to the presence of non-standard English usage, domain-specific vocabulary, and custom identifiers such as variable and function names, often combined with code-mixed expressions. In this work, we develop a multilingual speech-driven framework for code understanding that accepts spoken queries in a user native language, transcribes them using Automatic Speech Recognition (ASR), applies code-aware ASR output refinement using Large Language Models (LLMs), and interfaces with code models to perform tasks such as code question answering and code retrieval through benchmarks such as CodeSearchNet, CoRNStack, and CodeQA. Focusing on four widely spoken Indic languages and English, we systematically characterize how transcription errors impact downstream task performance. We also identified key failure modes in ASR for code and demonstrated that LLM-guided refinement significantly improves performance across both transcription and code understanding stages. Our findings underscore the need for code-sensitive adaptations in speech interfaces and offer a practical solution for building robust, multilingual voice-driven programming tools.", "AI": {"tldr": "\u672c\u7814\u7a76\u5f00\u53d1\u4e86\u4e00\u4e2a\u591a\u8bed\u8a00\u8bed\u97f3\u9a71\u52a8\u6846\u67b6\uff0c\u652f\u6301\u7528\u6237\u7528\u6bcd\u8bed\u53e3\u5934\u67e5\u8be2\u4ee3\u7801\uff0c\u901a\u8fc7ASroma\u548cLLM\u4f18\u5316\u8f6c\u5f55\u540e\u6267\u884c\u4ee3\u7801\u95ee\u7b54\u548c\u68c0\u7d22\u4efb\u52a1\uff0c\u89e3\u51b3\u4e86\u975e\u82f1\u8bed\u573a\u666f\u4e0b\u7684\u7f16\u7a0b\u8bed\u97f3\u4ea4\u4e92\u95ee\u9898\u3002", "motivation": "\u73b0\u6709\u7f16\u7a0b\u5de5\u5177\u4e3b\u8981\u670d\u52a1\u4e8e\u82f1\u6587\u952e\u76d8\u7528\u6237\uff0c\u9650\u5236\u4e86\u591a\u8bed\u8a00\u548c\u8bed\u97f3\u4f18\u5148\u573a\u666f\uff08\u5982\u5370\u5ea6\uff09\u7684\u53ef\u8bbf\u95ee\u6027\u3002\u8bed\u97f3\u67e5\u8be2\u4ee3\u7801\u5b58\u5728\u65b9\u8a00\u3001\u672f\u8bed\u548c\u6df7\u5408\u8868\u8fbe\u7b49\u6311\u6218\uff0c\u4e9f\u9700\u5305\u5bb9\u6027\u89e3\u51b3\u65b9\u6848\u3002", "method": "\u6784\u5efa\u6846\u67b6\u5305\u542b\uff1a1) \u652f\u6301\u6bcd\u8bed\u8bed\u97f3\u8f93\u5165\uff1b2) \u7528ASR\u8f6c\u5f55\u8bed\u97f3\uff1b3) \u57fa\u4e8eLLM\u8fdb\u884c\u4ee3\u7801\u611f\u77e5\u7684\u8f6c\u5f55\u4fee\u6b63\uff1b4) \u8fde\u63a5\u4ee3\u7801\u6a21\u578b\u5904\u7406CodeSearchNet\u7b49\u57fa\u51c6\u4efb\u52a1\uff0c\u91cd\u70b9\u6d4b\u8bd5\u56db\u79cd\u5370\u5ea6\u8bed\u8a00\u548c\u82f1\u8bed\u3002", "result": "\u7cfb\u7edf\u5316\u5206\u6790\u8f6c\u5f55\u9519\u8bef\u5bf9\u4efb\u52a1\u7684\u5f71\u54cd\uff0c\u8bc6\u522bASR\u5173\u952e\u5931\u8d25\u6a21\u5f0f\uff1b\u5b9e\u9a8c\u8bc1\u660eLLM\u5f15\u5bfc\u7684\u4f18\u5316\u663e\u8457\u63d0\u5347\u8f6c\u5f55\u51c6\u786e\u7387\u548c\u4ee3\u7801\u7406\u89e3\u6027\u80fd\uff0c\u5177\u4f53\u6539\u8fdb\u4f53\u73b0\u5728\u591a\u9879\u4e0b\u6e38\u4efb\u52a1\u4e2d\u3002", "conclusion": "\u6210\u679c\u5f3a\u8c03\u8bed\u97f3\u754c\u9762\u9700\u9002\u914d\u4ee3\u7801\u7279\u6027\uff0c\u4e3a\u6784\u5efa\u9c81\u68d2\u7684\u591a\u8bed\u8a00\u8bed\u97f3\u7f16\u7a0b\u5de5\u5177\u63d0\u4f9b\u5b9e\u7528\u65b9\u6848\uff0c\u63a8\u52a8\u7f16\u7a0b\u5de5\u5177\u5305\u5bb9\u6027\u53d1\u5c55\u3002"}}
{"id": "2601.15633", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2601.15633", "abs": "https://arxiv.org/abs/2601.15633", "authors": ["Enzo Meneses", "Hugo Bec", "Crist\u00f3bal A. Navarroa", "Beno\u00eet Crespin", "Felipe A. Quezada", "Nancy Hitschfeld", "Heinich Porro", "Maxime Maria"], "title": "Advancing RT Core-Accelerated Fixed-Radius Nearest Neighbor Search", "comment": "Journal submission", "summary": "In this work we introduce three ideas that can further improve particle FRNN physics simulations running on RT Cores; i) a real-time update/rebuild ratio optimizer for the bounding volume hierarchy (BVH) structure, ii) a new RT core use, with two variants, that eliminates the need of a neighbor list and iii) a technique that enables RT cores for FRNN with periodic boundary conditions (BC). Experimental evaluation using the Lennard-Jones FRNN interaction model as a case study shows that the proposed update/rebuild ratio optimizer is capable of adapting to the different dynamics that emerge during a simulation, leading to a RT core pipeline up to $\\sim 3.4\\times$ faster than with other known approaches to manage the BVH. In terms of simulation step performance, the proposed variants can significantly improve the speedup and EE of the base RT core idea; from $\\sim1.3\\times$ at small radius to $\\sim2.0\\times$ for log normal radius distributions. Furthermore, the proposed variants manage to simulate cases that would otherwise not fit in memory because of the use of neighbor lists, such as clusters of particles with log normal radius distribution. The proposed RT Core technique to support periodic BC is indeed effective as it does not introduce any significant penalty in performance. In terms of scaling, the proposed methods scale both their performance and EE across GPU generations. Throughout the experimental evaluation, we also identify the simulation cases were regular GPU computation should still be preferred, contributing to the understanding of the strengths and limitations of RT cores.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.15352", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.15352", "abs": "https://arxiv.org/abs/2601.15352", "authors": ["Adeyemi Adeseye", "Aisvarya Adeseye"], "title": "A Prompt-Based Framework for Loop Vulnerability Detection Using Local LLMs", "comment": "Accepted and Waiting to be published ICAI'25: 27th International Conference on Artificial Intelligence https://american-cse.org/csce2025/conferences-ICAI", "summary": "Loop vulnerabilities are one major risky construct in software development. They can easily lead to infinite loops or executions, exhaust resources, or introduce logical errors that degrade performance and compromise security. The problem are often undetected by traditional static analyzers because such tools rely on syntactic patterns, which makes them struggle to detect semantic flaws. Consequently, Large Language Models (LLMs) offer new potential for vulnerability detection because of their ability to understand code contextually. Moreover, local LLMs unlike commercial ones like ChatGPT or Gemini addresses issues such as privacy, latency, and dependency concerns by facilitating efficient offline analysis. Consequently, this study proposes a prompt-based framework that utilize local LLMs for the detection of loop vulnerabilities within Python 3.7+ code. The framework targets three categories of loop-related issues, such as control and logic errors, security risks inside loops, and resource management inefficiencies. A generalized and structured prompt-based framework was designed and tested with two locally deployed LLMs (LLaMA 3.2; 3B and Phi 3.5; 4B) by guiding their behavior via iterative prompting. The designed prompt-based framework included key safeguarding features such as language-specific awareness, code-aware grounding, version sensitivity, and hallucination prevention. The LLM results were validated against a manually established baseline truth, and the results indicate that Phi outperforms LLaMA in precision, recall, and F1-score. The findings emphasize the importance of designing effective prompts for local LLMs to perform secure and accurate code vulnerability analysis.", "AI": {"tldr": "\u672c\u7814\u7a76\u63d0\u51fa\u4e86\u57fa\u4e8e\u672c\u5730LLMs\u7684\u63d0\u793a\u6846\u67b6\uff0c\u7528\u4e8e\u68c0\u6d4bPython 3.7+\u4ee3\u7801\u4e2d\u7684\u5faa\u73af\u6f0f\u6d1e\uff0c\u5e76\u901a\u8fc7\u5b9e\u9a8c\u9a8c\u8bc1\u4e86\u6846\u67b6\u6548\u679c\u3002", "motivation": "\u4f20\u7edf\u9759\u6001\u5206\u6790\u5668\u96be\u4ee5\u68c0\u6d4britical\u8bed\u4e49\u7ea7\u5faa\u73af\u6f0f\u6d1e\uff0c\u800c\u672c\u5730LLMs\u80fd\u517c\u987e\u4ee3\u7801\u4e0a\u4e0b\u6587\u7406\u89e3\u4e14\u89e3\u51b3\u9690\u79c1\u3001\u5ef6\u8fdf\u7b49\u4e91\u670d\u52a1\u9650\u5236\u3002", "method": "\u8bbe\u8ba1\u7ed3\u6784\u5316\u63d0\u793a\u6846\u67b6\uff08\u542b\u8bed\u8a00\u8ba4\u77e5\u3001\u7248\u672c\u654f\u611f\u7b49\u9632\u62a4\u7279\u6027\uff09\uff0c\u6307\u5bfc\u672c\u5730\u90e8\u7f72\u7684LLaMA 3B\u548cPhi-4B\u6a21\u578b\u901a\u8fc7\u8fed\u4ee3\u63d0\u793a\u68c0\u6d4b\u4e09\u7c7b\u5faa\u73af\u6f0f\u6d1e\u3002", "result": "\u57fa\u4e8e\u4eba\u5de5\u57fa\u51c6\u9a8c\u8bc1\u663e\u793a\uff0cPhi\u6a21\u578b\u5728\u7cbe\u786e\u7387\u3001\u53ec\u56de\u7387\u548cF1\u5206\u6570\u4e0a\u5168\u9762\u4f18\u4e8eLLaMA\u6a21\u578b\u3002", "conclusion": "\u6709\u6548\u7684\u63d0\u793a\u5de5\u7a0b\u662f\u672c\u5730LLMs\u5b9e\u73b0\u7cbe\u51c6\u4ee3\u7801\u6f0f\u6d1e\u5206\u6790\u7684\u5173\u952e\uff0c\u8be5\u65b9\u6cd5\u4e3a\u5b89\u5168\u9ad8\u6548\u7684\u79bb\u7ebf\u68c0\u6d4b\u63d0\u4f9b\u4e86\u65b0\u601d\u8def\u3002"}}
{"id": "2601.15687", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.15687", "abs": "https://arxiv.org/abs/2601.15687", "authors": ["Khusrav Badalov", "Young Yoon"], "title": "FARM: Field-Aware Resolution Model for Intelligent Trigger-Action Automation", "comment": null, "summary": "Trigger-Action Programming (TAP) platforms such as IFTTT and Zapier enable Web of Things (WoT) automation by composing event-driven rules across heterogeneous services. A TAP applet links a trigger to an action and must bind trigger outputs (ingredients) to action inputs (fields) to be executable. Prior work largely treats TAP as service-level prediction from natural language, which often yields non-executable applets that still require manual configuration. We study the function-level configuration problem: generating complete applets with correct ingredient-to-field bindings. We propose FARM (Field-Aware Resolution Model), a two-stage architecture for automated applet generation with full configuration. Stage 1 trains contrastive dual encoders with selective layer freezing over schema-enriched representations, retrieving candidates from 1,724 trigger functions and 1,287 action functions (2.2M possible trigger-action pairs). Stage 2 performs selection and configuration using an LLM-based multi-agent pipeline. It includes intent analysis, trigger selection, action selection via cross-schema scoring, and configuration verification. Agents coordinate through shared state and agreement-based selection. FARM achieves 81% joint accuracy on Gold (62% Noisy, 70% One-shot) at the function level, where both trigger and action functions must match the ground truth. For comparison with service-level baselines, we map functions to their parent services and evaluate at the service level. FARM reaches 81% joint accuracy and improves over TARGE by 23 percentage points. FARM also generates ingredient-to-field bindings, producing executable automation configurations.", "AI": {"tldr": "\u672c\u6587\u63d0\u51faFARM\u6846\u67b6\u89e3\u51b3TAP\u5c0f\u7a0b\u5e8f\u529f\u80fd\u7ea7\u914d\u7f6e\u95ee\u9898\uff0c\u901a\u8fc7\u53cc\u9636\u6bb5\u6a21\u578b\u5b9e\u73b0\u9ad8\u7cbe\u5ea6\u81ea\u52a8\u5316\u5c0f\u7a0b\u5e8f\u751f\u6210\u4e0e\u7ed1\u5b9a\u5339\u914d\u3002", "motivation": "\u73b0\u6709TAP\u5e73\u53f0\u591a\u4fa7\u91cd\u4e8e\u670d\u52a1\u7ea7\u81ea\u7136\u8bed\u8a00\u9884\u6d4b\uff0c\u5e38\u751f\u6210\u9700\u624b\u52a8\u914d\u7f6e\u7684\u975e\u53ef\u6267\u884c\u5c0f\u7a0b\u5e8f\u3002\u9700\u89e3\u51b3\u529f\u80fd\u7ea7\u914d\u7f6e\u95ee\u9898\uff08\u5305\u62ec\u89e6\u53d1\u5668-\u52a8\u4f5c\u7ed1\u5b9a\uff09\uff0c\u5b9e\u73b0\u5b8c\u6574\u53ef\u6267\u884c\u81ea\u52a8\u5316\u3002", "method": "FARM\u91c7\u7528\u53cc\u9636\u6bb5\u67b6\u6784\uff1a1) \u4f7f\u7528\u6a21\u5f0f\u589e\u5f3a\u8868\u793a\u8bad\u7ec3\u5bf9\u6bd4\u53cc\u7f16\u7801\u5668\uff0c\u4ece220\u4e07\u79cd\u89e6\u53d1-\u52a8\u4f5c\u5bf9\u4e2d\u5019\u9009\u68c0\u7d22\uff1b2) \u57fa\u4e8eLLM\u7684\u591a\u667a\u80fd\u4f53\u6d41\u6c34\u7ebf\u6267\u884c\u610f\u56fe\u5206\u6790\u3001\u8de8\u6a21\u5f0f\u8bc4\u5206\u7684\u9009\u62e9\u673a\u5236\u53ca\u914d\u7f6e\u9a8c\u8bc1\u3002", "result": "\u529f\u80fd\u7ea7\u8054\u5408\u51c6\u786e\u7387\u8fbe81%\uff08\u566a\u58f0\u6570\u636e\u4e0b62%\uff0c\u5355\u6837\u672c\u4e0b70%\uff09\uff0c\u670d\u52a1\u7ea7\u51c6\u786e\u738781%\uff0c\u8f83TARGE\u63d0\u534723\u4e2a\u767e\u5206\u70b9\uff1b\u6210\u529f\u751f\u6210\u53ef\u6267\u884c\u7684\u6210\u5206-\u5b57\u6bb5\u7ed1\u5b9a\u914d\u7f6e\u3002", "conclusion": "FARM\u9996\u6b21\u5b9e\u73b0\u81ea\u52a8\u5316\u751f\u6210\u5b8c\u6574\u53ef\u6267\u884c\u7684TAP\u5c0f\u7a0b\u5e8f\uff0c\u663e\u8457\u964d\u4f4e\u4e86\u624b\u52a8\u914d\u7f6e\u9700\u6c42\uff0c\u4e3a\u7269\u8054\u7f51\u81ea\u52a8\u5316\u63d0\u4f9b\u4e86\u53ef\u9760\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2601.15879", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.15879", "abs": "https://arxiv.org/abs/2601.15879", "authors": ["Jiajun Zhang", "Zeyu Cui", "Lei Zhang", "Jian Yang", "Jiaxi Yang", "Qiang Liu", "Zilei Wang", "Binyuan Hui", "Liang Wang", "Junyang Lin"], "title": "Evaluating and Achieving Controllable Code Completion in Code LLM", "comment": null, "summary": "Code completion has become a central task, gaining significant attention with the rise of large language model (LLM)-based tools in software engineering. Although recent advances have greatly improved LLMs' code completion abilities, evaluation methods have not advanced equally. Most current benchmarks focus solely on functional correctness of code completions based on given context, overlooking models' ability to follow user instructions during completion-a common scenario in LLM-assisted programming. To address this limitation, we present the first instruction-guided code completion benchmark, Controllable Code Completion Benchmark (C3-Bench), comprising 2,195 carefully designed completion tasks. Through comprehensive evaluation of over 40 mainstream LLMs across C3-Bench and conventional benchmarks, we reveal substantial gaps in instruction-following capabilities between open-source and advanced proprietary models during code completion tasks. Moreover, we develop a straightforward data synthesis pipeline that leverages Qwen2.5-Coder to generate high-quality instruction-completion pairs for supervised fine-tuning (SFT). The resulting model, Qwen2.5-Coder-C3, achieves state-of-the-art performance on C3-Bench. Our findings provide valuable insights for enhancing LLMs' code completion and instruction-following capabilities, establishing new directions for future research in code LLMs. To facilitate reproducibility and foster further research in code LLMs, we open-source all code, datasets, and models.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.16009", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.16009", "abs": "https://arxiv.org/abs/2601.16009", "authors": ["Giovanna Broccia", "Sira Vegas", "Alessio Ferrari"], "title": "The Role of Cognitive Abilities in Requirements Inspection: Comparing UML and Textual Representations", "comment": null, "summary": "The representation of requirements plays a critical role in the accuracy of requirements inspection. While visual representations, such as UML diagrams, are widely used alongside text-based requirements, their effectiveness in supporting inspection is still debated. Cognitive abilities, such as working memory and mental rotation skills, may also influence inspection accuracy. This study aims to evaluate whether the use of UML sequence diagrams alongside text-based requirements improves the accuracy of requirements inspection compared to text-based requirements alone and to explore whether cognitive abilities are associated with differences in performance across the two treatments (text vs text with UML support). We conducted a crossover experiment with 38 participants to assess the accuracy of requirements inspection under the two treatments in terms of issues found and justifications provided. Linear mixed-effects and generalized linear models were used to analyse the effects of treatment, period, sequence, and cognitive abilities. The results indicate a significant three-way interaction between representation type, working memory capacity, and mental rotation ability. This finding suggests that the effectiveness of UML support is not uniform across individuals: participants with high scores in both cognitive abilities experienced reduced performance when using UML for violation detection. Conversely, the same cognitive profile was associated with improved justification accuracy under UML-aided inspection, indicating that higher cognitive abilities may support deeper reasoning processes when dealing with multi-modal information, i.e., diagrams and text.", "AI": {"tldr": "\u7814\u7a76\u8bc4\u4f30UML\u5e8f\u5217\u56fe\u5982\u4f55\u63d0\u5347\u9700\u6c42\u68c0\u67e5\u51c6\u786e\u6027\u53ca\u8ba4\u77e5\u80fd\u529b\u7684\u5f71\u54cd\uff0c\u53d1\u73b0UML\u652f\u6301\u6548\u679c\u56e0\u4eba\u800c\u5f02\u3002", "motivation": "\u63a2\u8ba8UML\u56fe\u662f\u5426\u6bd4\u7eaf\u6587\u672c\u66f4\u80fd\u63d0\u9ad8\u9700\u6c42\u68c0\u67e5\u51c6\u786e\u6027\uff0c\u5e76\u5206\u6790\u8ba4\u77e5\u80fd\u529b\uff08\u5de5\u4f5c\u8bb0\u5fc6\u548c\u5fc3\u7406\u65cb\u8f6c\uff09\u662f\u5426\u5728\u6587\u672c\u4e0eUML\u5904\u7406\u95f4\u9020\u6210\u7ee9\u6548\u5dee\u5f02\u3002", "method": "\u91c7\u7528\u4ea4\u53c9\u5b9e\u9a8c\u8bbe\u8ba1\uff0c\u62db\u52df38\u540d\u53c2\u4e0e\u8005\u6bd4\u8f83\u7eaf\u6587\u672c\u4e0e\u6587\u672c\u52a0UML\u7684\u68c0\u67e5\u6548\u679c\uff0c\u4f7f\u7528\u7ebf\u6027\u6df7\u5408\u6548\u5e94\u6a21\u578b\u5206\u6790\u5904\u7406\u65b9\u6cd5\u3001\u5468\u671f\u3001\u5e8f\u5217\u53ca\u8ba4\u77e5\u80fd\u529b\u3002", "result": "UML\u652f\u6301\u6548\u679c\u53d6\u51b3\u4e8e\u8ba4\u77e5\u80fd\u529b\u7ec4\u5408\uff1a\u9ad8\u5de5\u4f5c\u8bb0\u5fc6\u548c\u5fc3\u7406\u65cb\u8f6c\u80fd\u529b\u8005\u4f7f\u7528UML\u65f6\u8fdd\u89c4\u68c0\u6d4b\u51c6\u786e\u7387\u4e0b\u964d\uff0c\u4f46\u8bba\u8bc1\u51c6\u786e\u7387\u63d0\u9ad8\uff0c\u8868\u660e\u9ad8\u8ba4\u77e5\u80fd\u529b\u5728\u591a\u6a21\u6001\u4fe1\u606f\uff08\u56fe\u6587\u7ed3\u5408\uff09\u4e0b\u652f\u6301\u6df1\u5ea6\u63a8\u7406\u3002", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.16080", "categories": ["cs.SE", "cs.CY"], "pdf": "https://arxiv.org/pdf/2601.16080", "abs": "https://arxiv.org/abs/2601.16080", "authors": ["Oleksandr Kosenkov", "Ehsan Zabardast", "Jannik Fischbach", "Tony Gorschek", "Daniel Mendez"], "title": "Towards a Goal-Centric Assessment of Requirements Engineering Methods for Privacy by Design", "comment": "The paper has been accepted for the 32nd International Working Conference on Requirements Engineering: Foundation for Software Quality (REFSQ 2026)", "summary": "Implementing privacy by design (PbD) according to the General Data Protection Regulation (GDPR) is met with a growing number of requirements engineering (RE) approaches. However, the question of which RE method for PbD fits best the goals of organisations remains a challenge. We report our endeavor to close this gap by synthesizing a goal-centric approach for PbD methods assessment. We used literature review, interviews, and validation with practitioners to achieve the goal of our study. As practitioners do not approach PbD systematically, we suggest that RE methods for PbD should be assessed against organisational goals, rather than process characteristics only. We hope that, when further developed, the goal-centric approach could support the development, selection, and tailoring of RE practices for PbD.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
