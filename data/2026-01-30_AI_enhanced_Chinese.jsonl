{"id": "2601.20879", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.20879", "abs": "https://arxiv.org/abs/2601.20879", "authors": ["Bruno Claudino Matias", "Savio Freire", "Juliana Freitas", "Felipe Fronchetti", "Kostadin Damevski", "Rodrigo Spinola"], "title": "A Survey on Large Language Model Impact on Software Evolvability and Maintainability: the Good, the Bad, the Ugly, and the Remedy", "comment": null, "summary": "Context. Large Language Models (LLMs) are increasingly embedded in software engineering workflows for tasks including code generation, summarization, repair, and testing. Empirical studies report productivity gains, improved comprehension, and reduced cognitive load. However, evidence remains fragmented, and concerns persist about hallucinations, unstable outputs, methodological limitations, and emerging forms of technical debt. How these mixed effects shape long-term software maintainability and evolvability remains unclear. Objectives. This study systematically examines how LLMs influence the maintainability and evolvability of software systems. We identify which quality attributes are addressed in existing research, the positive impacts LLMs provide, the risks and weaknesses they introduce, and the mitigation strategies proposed in the literature. Method. We conducted a systematic literature review. Searches across ACM DL, IEEE Xplore, and Scopus (2020 to 2024) yielded 87 primary studies. Qualitative evidence was extracted through a calibrated multi-researcher process. Attributes were analyzed descriptively, while impacts, risks, weaknesses, and mitigation strategies were synthesized using a hybrid thematic approach supported by an LLM-assisted analysis tool with human-in-the-loop validation. Results. LLMs provide benefits such as improved analyzability, testability, code comprehension, debugging support, and automated repair. However, they also introduce risks, including hallucinated or incorrect outputs, brittleness to context, limited domain reasoning, unstable performance, and flaws in current evaluations, which threaten long-term evolvability. Conclusion. LLMs can strengthen maintainability and evolvability, but they also pose nontrivial risks to long-term sustainability. Responsible adoption requires safeguards, rigorous evaluation, and structured human oversight.", "AI": {"tldr": "\u672c\u7814\u7a76\u7cfb\u7edf\u7efc\u8ff0LLM\u5bf9\u8f6f\u4ef6\u7cfb\u7edf\u53ef\u7ef4\u62a4\u6027\u4e0e\u53ef\u6f14\u5316\u6027\u7684\u5f71\u54cd\uff0c\u63ed\u793a\u79ef\u6781\u6548\u679c\u4e0e\u98ce\u9669\u5e76\u5b58\uff0c\u9700\u76d1\u7ba1\u4fdd\u969c\u3002", "motivation": "LLM\u5728\u8f6f\u4ef6\u5de5\u7a0b\u4e2d\u5e94\u7528\u5e7f\u6cdb\u4f46\u5f71\u54cd\u4e0d\u660e\uff0c\u5b58\u5728\u8bc1\u636e\u788e\u7247\u5316\u548c\u6280\u672f\u503a\u98ce\u9669\uff0c\u9700\u7cfb\u7edf\u5206\u6790\u5176\u5bf9\u8f6f\u4ef6\u957f\u671f\u6f14\u8fdb\u7684\u8d28\u91cf\u5f71\u54cd\u3002", "method": "\u5bf9ACM DL\u7b49\u4e09\u5927\u6570\u636e\u5e93\uff082020-2024\uff09\u768487\u9879\u7814\u7a76\u8fdb\u884c\u7cfb\u7edf\u6587\u732e\u7efc\u8ff0\uff0c\u7ed3\u5408LLM\u8f85\u52a9\u7684\u6df7\u5408\u4e3b\u9898\u5206\u6790\u53ca\u591a\u4eba\u6821\u9a8c\u3002", "result": "LLM\u63d0\u5347\u53ef\u5206\u6790\u6027\u3001\u6d4b\u8bd5\u6027\u53ca\u4ee3\u7801\u7406\u89e3\u7b49\uff0c\u4f46\u5f15\u53d1\u5e7b\u89c9\u8f93\u51fa\u3001\u9886\u57df\u63a8\u7406\u5c40\u9650\u7b49\u98ce\u9669\uff0c\u5a01\u80c1\u8f6f\u4ef6\u957f\u671f\u6f14\u5316\u80fd\u529b\u3002", "conclusion": "LLM\u53ef\u589e\u5f3a\u8f6f\u4ef6\u7ef4\u62a4\u4e0e\u6f14\u8fdb\uff0c\u4f46\u9700\u9632\u8303\u98ce\u9669\uff1b\u63d0\u5021\u901a\u8fc7\u5b89\u5168\u63aa\u65bd\u3001\u4e25\u683c\u8bc4\u4f30\u548c\u4eba\u5de5\u76d1\u7763\u5b9e\u73b0\u8d1f\u8d23\u4efb\u4f7f\u7528\u3002"}}
{"id": "2601.20882", "categories": ["cs.SE", "cs.AI", "cs.CR"], "pdf": "https://arxiv.org/pdf/2601.20882", "abs": "https://arxiv.org/abs/2601.20882", "authors": ["Yuheng Tang", "Kaijie Zhu", "Bonan Ruan", "Chuqi Zhang", "Michael Yang", "Hongwei Li", "Suyue Guo", "Tianneng Shi", "Zekun Li", "Christopher Kruegel", "Giovanni Vigna", "Dawn Song", "William Yang Wang", "Lun Wang", "Yangruibo Ding", "Zhenkai Liang", "Wenbo Guo"], "title": "DevOps-Gym: Benchmarking AI Agents in Software DevOps Cycle", "comment": null, "summary": "Even though demonstrating extraordinary capabilities in code generation and software issue resolving, AI agents' capabilities in the full software DevOps cycle are still unknown. Different from pure code generation, handling the DevOps cycle in real-world software, including developing, deploying, and managing, requires analyzing large-scale projects, understanding dynamic program behaviors, leveraging domain-specific tools, and making sequential decisions. However, existing benchmarks focus on isolated problems and lack environments and tool interfaces for DevOps. We introduce DevOps-Gym, the first end-to-end benchmark for evaluating AI agents across core DevOps workflows: build and configuration, monitoring, issue resolving, and test generation. DevOps-Gym includes 700+ real-world tasks collected from 30+ projects in Java and Go. We develop a semi-automated data collection mechanism with rigorous and non-trivial expert efforts in ensuring the task coverage and quality. Our evaluation of state-of-the-art models and agents reveals fundamental limitations: they struggle with issue resolving and test generation in Java and Go, and remain unable to handle new tasks such as monitoring and build and configuration. These results highlight the need for essential research in automating the full DevOps cycle with AI agents.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.20893", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.20893", "abs": "https://arxiv.org/abs/2601.20893", "authors": ["Henry Edison", "Nauman Ali"], "title": "Another Systematic Review? A Critical Analysis of Systematic Literature Reviews on Agile Effort and Cost Estimation", "comment": null, "summary": "Background: Systematic literature reviews (SLRs) have become prevalent in software engineering research. Several researchers may conduct SLRs on similar topics without a prospective register for SLR protocols. However, even ignoring these unavoidable duplications of effort in the simultaneous conduct of SLRs, the proliferation of overlapping and often repetitive SLRs indicates that researchers are not extensively checking for existing SLRs on a topic. Given how effort-intensive it is to design, conduct, and report an SLR, the situation is less than ideal for software engineering research. Aim: To understand how authors justify additional SLRs on a topic. Method: To illustrate the issue and develop suggestions for improvement to address this issue, we have intentionally picked a sufficiently narrow but well-researched topic, i.e., effort estimation in Agile software development. We identify common justification patterns through a qualitative content analysis of 18 published SLRs. We further consider the citation data, publication years, publication venues, and the quality of the SLRs when interpreting the results. Results: The common justification patterns include authors claiming gaps in coverage, methodological limitations in prior studies, temporal obsolescence of previous SLRs, or rapid technological and methodological advancements necessitating updated syntheses. Conclusion: Our in-depth analysis of SLRs on a fairly narrow topic provides insights into SLRs in software engineering in general. By emphasizing the need for identifying existing SLRs and for justifying the undertaking of further SLRs, both in design and review guidelines and as a policy of conferences and journals, we can reduce the likelihood of duplication of effort and increase the rate of progress in the field.", "AI": {"tldr": "\u8be5\u8bba\u6587\u5206\u6790\u591a\u7bc7\u7cfb\u7edf\u6027\u6587\u732e\u7efc\u8ff0\uff08SLR\uff09\u5728\u8f6f\u4ef6\u5de5\u7a0b\u4e2d\u91cd\u53e0\u7684\u73b0\u8c61\u53ca\u5176\u4f5c\u8005\u7684\u5408\u7406\u5316\u7406\u7531\u3002", "motivation": "\u7531\u4e8eSLR\u5728\u8f6f\u4ef6\u5de5\u7a0b\u7814\u7a76\u4e2d\u8017\u65f6\u957f\u800c\u91cd\u590d\u7387\u9ad8\uff0c\u5f71\u54cd\u7814\u7a76\u6548\u7387\uff1b\u65e8\u5728\u7406\u89e3\u4f5c\u8005\u5982\u4f55\u8bc1\u660e\u589e\u52a0\u65b0\u7684SLR\u7684\u5fc5\u8981\u6027\u3002", "method": "\u805a\u7126\u654f\u6377\u8f6f\u4ef6\u5f00\u53d1\u4e2d\u5de5\u4f5c\u91cf\u4f30\u7b97\u7684\u4e13\u9898\uff0c\u91c7\u7528\u8d28\u6027\u5185\u5bb9\u5206\u679018\u7bc7SLR\uff0c\u7ed3\u5408\u5f15\u7528\u6570\u636e\u3001\u51fa\u7248\u5e74\u4efd\u3001\u51fa\u7248\u5e73\u53f0\u53caSLR\u8d28\u91cf\u8fdb\u884c\u8bc4\u4f30\u3002", "result": "\u5e38\u89c1\u5408\u7406\u5316\u7406\u7531\u5305\u62ec\uff1a\u8986\u76d6\u4e0d\u5168\u3001\u65b9\u6cd5\u5c40\u9650\u3001\u524d\u4efbSLR\u8fc7\u65f6\u3001\u6280\u672f\u6216\u65b9\u6cd5\u8fdb\u6b65\u9700\u8981\u66f4\u65b0\u3002", "conclusion": "\u5f3a\u8c03\u5728\u8bbe\u8ba1\u5ba1\u67e5\u6307\u5357\u548c\u671f\u520a\u653f\u7b56\u4e2d\u8bc6\u522b\u73b0\u6709SLR\u5e76\u8bba\u8bc1\u65b0\u589e\u7684\u5fc5\u8981\u6027\uff0c\u4ee5\u51cf\u5c11\u91cd\u590d\u5de5\u4f5c\u5e76\u4fc3\u8fdb\u9886\u57df\u53d1\u5c55\u3002"}}
{"id": "2601.21126", "categories": ["cs.MA", "cs.RO"], "pdf": "https://arxiv.org/pdf/2601.21126", "abs": "https://arxiv.org/abs/2601.21126", "authors": ["Kooktae Lee", "Julian Martinez"], "title": "AI-Augmented Density-Driven Optimal Control (D2OC) for Decentralized Environmental Mapping", "comment": null, "summary": "This paper presents an AI-augmented decentralized framework for multi-agent (multi-robot) environmental mapping under limited sensing and communication. While conventional coverage formulations achieve effective spatial allocation when an accurate reference map is available, their performance deteriorates under uncertain or biased priors. The proposed method introduces an adaptive and self-correcting mechanism that enables agents to iteratively refine local density estimates within an optimal transport-based framework, ensuring theoretical consistency and scalability. A dual multilayer perceptron (MLP) module enhances adaptivity by inferring local mean-variance statistics and regulating virtual uncertainty for long-unvisited regions, mitigating stagnation around local minima. Theoretical analysis rigorously proves convergence under the Wasserstein metric, while simulation results demonstrate that the proposed AI-augmented Density-Driven Optimal Control consistently achieves robust and precise alignment with the ground-truth density, yielding substantially higher-fidelity reconstruction of complex multi-modal spatial distributions compared with conventional decentralized baselines.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e00\u79cdAI\u589e\u5f3a\u53bb\u4e2d\u5fc3\u5316\u6846\u67b6\uff0c\u89e3\u51b3\u591a\u667a\u80fd\u4f53\u5728\u6709\u9650\u611f\u77e5\u4e0e\u901a\u4fe1\u4e0b\u7684\u73af\u5883\u6620\u5c04\u95ee\u9898\uff0c\u663e\u8457\u4f18\u4e8e\u4f20\u7edf\u65b9\u6cd5\u3002", "motivation": "\u4f20\u7edf\u8986\u76d6\u65b9\u6cd5\u4f9d\u8d56\u7cbe\u786e\u53c2\u8003\u5730\u56fe\uff0c\u5728\u5148\u9a8c\u4fe1\u606f\u4e0d\u786e\u5b9a\u6216\u6709\u504f\u65f6\u6027\u80fd\u660e\u663e\u4e0b\u964d\u3002", "method": "\u57fa\u4e8e\u6700\u4f18\u4f20\u8f93\u6846\u67b6\u8bbe\u8ba1\u81ea\u9002\u5e94\u81ea\u6821\u6b63\u673a\u5236\uff0c\u7ed3\u5408\u53ccMLP\u6a21\u5757\u63a8\u65ad\u5c40\u90e8\u5747\u503c-\u65b9\u5dee\u7edf\u8ba1\u5e76\u8c03\u63a7\u957f\u671f\u672a\u8bbf\u95ee\u533a\u57df\u865a\u62df\u4e0d\u786e\u5b9a\u6027\uff0c\u907f\u514d\u5c40\u90e8\u6700\u5c0f\u503c\u505c\u6ede\u3002", "result": "\u7406\u8bba\u8bc1\u660e\u5728Wasserstein\u5ea6\u91cf\u4e0b\u6536\u655b\uff0c\u4eff\u771f\u663e\u793a\u6240\u63d0\u65b9\u6cd5\u6bd4\u4f20\u7edf\u53bb\u4e2d\u5fc3\u5316\u57fa\u7ebf\u66f4\u7cbe\u786e\u5bf9\u9f50\u771f\u5b9e\u5bc6\u5ea6\uff0c\u591a\u6a21\u6001\u5206\u5e03\u91cd\u5efa\u4fdd\u771f\u5ea6\u63d0\u5347\u663e\u8457\u3002", "conclusion": "AI\u589e\u5f3a\u7684\u5bc6\u5ea6\u9a71\u52a8\u6700\u4f18\u63a7\u5236\u65b9\u6cd5\u5728\u4e0d\u786e\u5b9a\u6027\u73af\u5883\u4e0b\u5b9e\u73b0\u9ad8\u6548\u9c81\u68d2\u6620\u5c04\uff0c\u5177\u5907\u7406\u8bba\u4e00\u81f4\u6027\u4e0e\u53ef\u6269\u5c55\u6027\u4f18\u52bf\u3002"}}
{"id": "2601.21146", "categories": ["cs.DC", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.21146", "abs": "https://arxiv.org/abs/2601.21146", "authors": ["Francesco Paladino", "Shulu Li", "Edward A. Lee"], "title": "Maxwait: A Generalized Mechanism for Distributed Time-Sensitive Systems", "comment": null, "summary": "Distributed time-sensitive systems must balance timing requirements (availability) and consistency in the presence of communication delays and synchronization uncertainty. This paper presents maxwait, a simple coordination mechanism with surprising generality that makes these tradeoffs explicit and configurable. We demonstrate that this mechanism subsumes classical distributed system methods such as PTIDES, Chandy-and-Misra with or without null messages, Jefferson's Time-Warp, and Lamport's time-based fault detection, while enabling real-time behavior in distributed cyber-physical applications. The mechanism can also realize many commonly used distributed system patterns, including logical execution time (LET), publish and subscribe, actors, conflict-free replicated data types (CRDTs), and remote procedure calls with futures. More importantly, it adds to these mechanisms better control over timing, bounded time fault detection, and the option of making them more deterministic, all within a single semantic framework. Implemented as an extension of the Lingua Franca coordination language, maxwait enforces logical-time consistency when communication latencies are bounded and provides structured fault handling when bounds are violated.", "AI": {"tldr": "\u4e00\u4e2a\u7b80\u5355\u7684\u534f\u8c03\u673a\u5236maxwait\uff0c\u7528\u4e8e\u5e73\u8861\u5206\u5e03\u5f0f\u65f6\u95f4\u654f\u611f\u7cfb\u7edf\u4e2d\u7684\u65f6\u5e8f\u8981\u6c42\u4e0e\u4e00\u81f4\u6027\u3002", "motivation": "\u89e3\u51b3\u901a\u4fe1\u5ef6\u8fdf\u548c\u540c\u6b65\u4e0d\u786e\u5b9a\u6027\u4e0b\u7684\u65f6\u5e8f\u4e0e\u4e00\u81f4\u6027\u6743\u8861\u95ee\u9898\u3002", "method": "\u4f5c\u4e3aLingua Franca\u534f\u8c03\u8bed\u8a00\u7684\u6269\u5c55\u5b9e\u73b0maxwait\u673a\u5236\uff0c\u63d0\u4f9b\u53ef\u914d\u7f6e\u7684\u534f\u8c03\u6846\u67b6\u3002", "result": "\u6db5\u76d6\u4e86PTIDES\u7b49\u7ecf\u5178\u65b9\u6cd5\uff0c\u652f\u6301\u5b9e\u65f6\u5e94\u7528\uff0c\u5b9e\u73b0\u591a\u79cd\u6a21\u5f0f\u5982LET\u548cCRDTs\uff0c\u5e76\u589e\u5f3a\u65f6\u5e8f\u63a7\u5236\u4e0e\u6545\u969c\u68c0\u6d4b\u3002", "conclusion": "\u5728\u901a\u4fe1\u5ef6\u8fdf\u6709\u754c\u65f6\u786e\u4fdd\u903b\u8f91\u65f6\u95f4\u4e00\u81f4\u6027\uff0c\u8d8a\u754c\u65f6\u63d0\u4f9b\u7ed3\u6784\u5316\u6545\u969c\u5904\u7406\uff0c\u589e\u5f3a\u7cfb\u7edf\u9c81\u68d2\u6027\u4e0e\u786e\u5b9a\u6027\u3002"}}
{"id": "2601.21477", "categories": ["cs.MA", "cs.AI", "cs.LG", "math.OC"], "pdf": "https://arxiv.org/pdf/2601.21477", "abs": "https://arxiv.org/abs/2601.21477", "authors": ["Tobias Schmidt", "Kai Cui"], "title": "Mean-Field Control on Sparse Graphs: From Local Limits to GNNs via Neighborhood Distributions", "comment": "19 pages", "summary": "Mean-field control (MFC) offers a scalable solution to the curse of dimensionality in multi-agent systems but traditionally hinges on the restrictive assumption of exchangeability via dense, all-to-all interactions. In this work, we bridge the gap to real-world network structures by proposing a rigorous framework for MFC on large sparse graphs. We redefine the system state as a probability measure over decorated rooted neighborhoods, effectively capturing local heterogeneity. Our central contribution is a theoretical foundation for scalable reinforcement learning in this setting. We prove horizon-dependent locality: for finite-horizon problems, an agent's optimal policy at time t depends strictly on its (T-t)-hop neighborhood. This result renders the infinite-dimensional control problem tractable and underpins a novel Dynamic Programming Principle (DPP) on the lifted space of neighborhood distributions. Furthermore, we formally and experimentally justify the use of Graph Neural Networks (GNNs) for actor-critic algorithms in this context. Our framework naturally recovers classical MFC as a degenerate case while enabling efficient, theoretically grounded control on complex sparse topologies.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.21383", "categories": ["cs.NI"], "pdf": "https://arxiv.org/pdf/2601.21383", "abs": "https://arxiv.org/abs/2601.21383", "authors": ["Zhiyuan Zhao", "Jiasheng Wu", "Shaojie Su", "Wenjun Zhu", "Yue Gao"], "title": "KubeSpace: A Low-Latency and Stable Control Plane for LEO Satellite Container Orchestration", "comment": "11 pages, 11 figures", "summary": "Low Earth orbit (LEO) satellites play a pivotal role in global connectivity-delivering high-speed Internet, cellular coverage, and massive IoT support. With ever-growing onboard computing and storage resources, LEO satellites herald a new cloud paradigm: space cloud computing. While container or chestration platforms (e.g., Kubernetes) excel in terrestrial data centers, they are ill-suited to LEO satellite networks, featuring geographic dispersion and frequent handovers. Those features bring high latency and intermittent management, leading to control plane failure in container orchestration. To address this, we propose KubeSpace, a low-latency and stable control plane specifically designed for container orchestration on LEO satellites. KubeSpace combines two key innovations: a distributed ground-control-node architecture that binds each satellite to its nearest controller for uninterrupted management, and an orbit-aware placement with dynamic assignment strategy that further minimizes communication latency and handover frequency. Extensive experiments based on real satellite traces demonstrate that compared to existing solutions, KubeSpace reduces the average management latency of satellite nodes by 59% without any management interruption time.", "AI": {"tldr": "\u63d0\u51fa\u4e86KubeSpace\uff0c\u4e00\u4e2a\u4e13\u95e8\u4e3a\u4f4e\u5730\u7403\u8f68\u9053\u536b\u661f\u5bb9\u5668\u7f16\u6392\u8bbe\u8ba1\u7684\u4f4e\u5ef6\u8fdf\u7a33\u5b9a\u63a7\u5236\u5e73\u9762\u3002", "motivation": "\u73b0\u6709\u5bb9\u5668\u7f16\u6392\u5e73\u53f0\u4e0d\u9002\u5e94LEO\u536b\u661f\u7684\u9ad8\u5730\u7406\u5206\u6563\u6027\u548c\u9891\u7e41\u5207\u6362\u7279\u6027\uff0c\u5bfc\u81f4\u9ad8\u5ef6\u8fdf\u548c\u7ba1\u7406\u4e2d\u65ad\u95ee\u9898\u3002", "method": "\u63d0\u51fa\u5206\u5e03\u5f0f\u5730\u9762\u63a7\u5236\u8282\u70b9\u67b6\u6784\u5b9e\u73b0\u8fde\u7eed\u7ba1\u7406\uff0c\u7ed3\u5408\u8f68\u9053\u611f\u77e5\u52a8\u6001\u5206\u914d\u7b56\u7565\u6700\u5c0f\u5316\u901a\u4fe1\u5ef6\u8fdf\u548c\u5207\u6362\u9891\u7387\u3002", "result": "\u771f\u5b9e\u536b\u661f\u8f68\u8ff9\u5b9e\u9a8c\u663e\u793a\uff0c\u76f8\u6bd4\u73b0\u6709\u65b9\u6848\u5e73\u5747\u7ba1\u7406\u5ef6\u8fdf\u964d\u4f4e59%\uff0c\u7ba1\u7406\u4e2d\u65ad\u65f6\u95f4\u4e3a\u96f6\u3002", "conclusion": "KubeSpace\u9ad8\u6548\u4f18\u5316\u4e86LEO\u536b\u661f\u7684\u5bb9\u5668\u7f16\u6392\u6027\u80fd\u3002"}}
{"id": "2601.21584", "categories": ["cs.AR", "cs.ET"], "pdf": "https://arxiv.org/pdf/2601.21584", "abs": "https://arxiv.org/abs/2601.21584", "authors": ["Pin-Han Ho", "Limei Peng", "Yiming Miao", "Xu Fan", "Kairan Liang", "Haoran Mei", "Wei Duan"], "title": "Frequency as Aperture: Enabling Embeddable Near-Field Sensing for 6G Wireless Radios", "comment": null, "summary": "Integrated sensing and communication (ISAC) is expected to be natively supported by future 6G wireless radios, yet most mmWave sensing solutions still rely on dedicated radar hardware incompatible with cost and power constrained wireless nodes. This article introduces Frequency-as-Aperture (FaA), a wireless-first sensing paradigm that repurposes inherent frequency agility into a virtual sensing aperture, enabling near-field perception with minimal RF front end complexity. Using a single RF chain and a frequency-scanning leaky-wave antenna, FaA achieves two dimensional spatial sensing by reusing the local oscillator (LO) frequency sweep already employed for wideband communication. From a wireless-system perspective, this shifts spatial sampling from the antenna domain to the frequency domain, embedding radar-grade spatial fingerprints directly into the communication RF chain. A case study shows that FaA provides fine angular and range discrimination with low power consumption and unit cost, demonstrating significantly higher architectural efficiency than conventional multi-channel MIMO based sensing under identical physical and spectral constraints. These results indicate that near-field sensing can be seamlessly integrated into frequency-agile wireless radios, enabling hardware-efficient, embeddable, and privacy-preserving ISAC nodes for smart homes, wearables, and industrial edge deployments.", "AI": {"tldr": "\u63d0\u51fa\u4e86Frequency-as-Aperture (FaA)\u6280\u672f\uff0c\u901a\u8fc7\u5c06\u901a\u4fe1\u9891\u7387\u626b\u63cf\u8f6c\u6362\u4e3a\u865a\u62df\u4f20\u611f\u5b54\u5f84\uff0c\u5b9e\u73b0\u4f4e\u6210\u672c\u4f4e\u529f\u8017\u7684\u8fd1\u573a\u611f\u77e5\uff0c\u9002\u7528\u4e8e6G\u96c6\u6210\u4f20\u611f\u901a\u4fe1\u7cfb\u7edf\u3002", "motivation": "\u73b0\u6709\u6beb\u7c73\u6ce2\u4f20\u611f\u65b9\u6848\u4f9d\u8d56\u4e13\u7528\u96f7\u8fbe\u786c\u4ef6\uff0c\u96be\u4ee5\u6ee1\u8db3\u672a\u67656G\u65e0\u7ebf\u8282\u70b9\u5bf9\u6210\u672c\u548c\u529f\u8017\u7684\u8981\u6c42\uff0c\u9700\u5f00\u53d1\u80fd\u4e0e\u901a\u4fe1\u8bbe\u5907\u517c\u5bb9\u7684\u8f7b\u91cf\u7ea7\u4f20\u611f\u65b9\u6848\u3002", "method": "\u91c7\u7528\u5355\u5c04\u9891\u94fe\u548c\u626b\u9891\u6f0f\u6ce2\u5929\u7ebf\uff0c\u590d\u7528\u901a\u4fe1\u7cfb\u7edf\u7684\u672c\u632f\u9891\u7387\u626b\u63cf\uff0c\u5c06\u7a7a\u95f4\u91c7\u6837\u4ece\u5929\u7ebf\u57df\u8f6c\u79fb\u5230\u9891\u7387\u57df\uff0c\u5f62\u6210\u5d4c\u5165\u5f0f\u96f7\u8fbe\u7ea7\u7a7a\u95f4\u6307\u7eb9\u8bc6\u522b\u3002", "result": "\u6848\u4f8b\u7814\u7a76\u8868\u660e\uff0c\u5728\u76f8\u540c\u7269\u7406\u548c\u9891\u8c31\u7ea6\u675f\u4e0b\uff0cFaA\u5b9e\u73b0\u4e86\u7cbe\u7ec6\u89d2\u5ea6/\u8ddd\u79bb\u5206\u8fa8\u80fd\u529b\uff0c\u529f\u8017\u548c\u6210\u672c\u663e\u8457\u4f4e\u4e8e\u4f20\u7edf\u591a\u901a\u9053MIMO\u65b9\u6848\uff0c\u67b6\u6784\u6548\u7387\u66f4\u9ad8\u3002", "conclusion": "FaA\u8bc1\u660e\u9891\u7387\u654f\u6377\u65e0\u7ebf\u8bbe\u5907\u53ef\u65e0\u7f1d\u96c6\u6210\u8fd1\u573a\u611f\u77e5\uff0c\u4e3a\u667a\u80fd\u5bb6\u5c45\u3001\u53ef\u7a7f\u6234\u8bbe\u5907\u548c\u5de5\u4e1a\u8fb9\u7f18\u90e8\u7f72\u63d0\u4f9b\u9ad8\u6548\u3001\u5d4c\u5165\u5f0f\u3001\u9690\u79c1\u4fdd\u62a4\u7684\u96c6\u6210\u4f20\u611f\u901a\u4fe1\u8282\u70b9\u3002"}}
{"id": "2601.20918", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.20918", "abs": "https://arxiv.org/abs/2601.20918", "authors": ["Mohammad Naserameri", "Juergen Rilling"], "title": "Infusion of Blockchain to Establish Trustworthiness in AI Supported Software Evolution: A Systematic Literature Review", "comment": "This paper is a preprint of a manuscript submitted for journal publication. The accompanying dataset supporting this systematic literature review is publicly available on Zenodo", "summary": "Context: Blockchain and AI are increasingly explored to enhance trustworthiness in software engineering (SE), particularly in supporting software evolution tasks. Method: We conducted a systematic literature review (SLR) using a predefined protocol with clear eligibility criteria to ensure transparency, reproducibility, and minimized bias, synthesizing research on blockchain-enabled trust in AI-driven SE tools and processes. Results: Most studies focus on integrating AI in SE, with only 31% explicitly addressing trustworthiness. Our review highlights six recent studies exploring blockchain-based approaches to reinforce reliability, transparency, and accountability in AI-assisted SE tasks. Conclusion: Blockchain enhances trust by ensuring data immutability, model transparency, and lifecycle accountability, including federated learning with blockchain consensus and private data verification. However, inconsistent definitions of trust and limited real-world testing remain major challenges. Future work must develop measurable, reproducible trust frameworks to enable reliable, secure, and compliant AI-driven SE ecosystems, including applications involving large language models.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.21198", "categories": ["cs.DC", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.21198", "abs": "https://arxiv.org/abs/2601.21198", "authors": ["Yuchen Yang", "Yaru Zhao", "Pu Yang", "Shaowei Wang", "Zhi-Hua Zhou"], "title": "ZipMoE: Efficient On-Device MoE Serving via Lossless Compression and Cache-Affinity Scheduling", "comment": null, "summary": "While Mixture-of-Experts (MoE) architectures substantially bolster the expressive power of large-language models, their prohibitive memory footprint severely impedes the practical deployment on resource-constrained edge devices, especially when model behavior must be preserved without relying on lossy quantization. In this paper, we present ZipMoE, an efficient and semantically lossless on-device MoE serving system. ZipMoE exploits the synergy between the hardware properties of edge devices and the statistical redundancy inherent to MoE parameters via a caching-scheduling co-design with provable performance guarantee. Fundamentally, our design shifts the paradigm of on-device MoE inference from an I/O-bound bottleneck to a compute-centric workflow that enables efficient parallelization. We implement a prototype of ZipMoE and conduct extensive experiments on representative edge computing platforms using popular open-source MoE models and real-world workloads. Our evaluation reveals that ZipMoE achieves up to $72.77\\%$ inference latency reduction and up to $6.76\\times$ higher throughput than the state-of-the-art systems.", "AI": {"tldr": "\u672c\u6587\u63d0\u51faZipMoE\u7cfb\u7edf\uff0c\u9488\u5bf9Mixture-of-Experts\u6a21\u578b\u5728\u8fb9\u7f18\u8bbe\u5907\u4e0a\u5360\u7528\u5185\u5b58\u8fc7\u5927\u7684\u95ee\u9898\uff0c\u901a\u8fc7\u8f6f\u786c\u4ef6\u534f\u540c\u8bbe\u8ba1\u5b9e\u73b0\u9ad8\u6548\u4e14\u8bed\u4e49\u65e0\u635f\u7684\u63a8\u7406\uff0c\u663e\u8457\u964d\u4f4e\u5ef6\u8fdf\u5e76\u63d0\u5347\u541e\u5410\u91cf\u3002", "motivation": "MoE\u67b6\u6784\u867d\u589e\u5f3a\u5927\u578b\u8bed\u8a00\u6a21\u578b\u7684\u8868\u8fbe\u80fd\u529b\uff0c\u4f46\u5176\u5de8\u5927\u5185\u5b58\u5360\u7528\u963b\u788d\u5728\u8d44\u6e90\u53d7\u9650\u8fb9\u7f18\u8bbe\u5907\u4e0a\u7684\u5b9e\u7528\u90e8\u7f72\uff0c\u7279\u522b\u662f\u907f\u514d\u635f\u5931\u91cf\u5316\u65f6\uff0c\u4e9f\u9700\u9ad8\u6548\u89e3\u51b3\u65b9\u6848\u3002", "method": "\u91c7\u7528\u7f13\u5b58\u4e0e\u8c03\u5ea6\u534f\u540c\u8bbe\u8ba1\uff0c\u5229\u7528\u8fb9\u7f18\u786c\u4ef6\u7279\u6027\u548cMoE\u53c2\u6570\u7684\u7edf\u8ba1\u5197\u4f59\uff0c\u5c06\u63a8\u7406\u611f\u89e6\u5668\u4eceI/O\u74f6\u9888\u8f6c\u5411\u4ee5\u8ba1\u7b97\u4e3a\u4e2d\u5fc3\u7684\u5de5\u4f5c\u6d41\uff0c\u652f\u6301\u9ad8\u6548\u5e76\u884c\u5316\u3002", "result": "\u5728\u8fb9\u7f18\u8ba1\u7b97\u5e73\u53f0\u7684\u5b9e\u9a8c\u4e2d\uff0cZipMoE\u6bd4\u524d\u6cbf\u7cfb\u7edf\u51cf\u5c11\u9ad8\u8fbe72.77%\u7684\u5ef6\u8fdf\uff0c\u541e\u5410\u91cf\u63d0\u9ad86.76\u500d\u3002", "conclusion": "ZipMoE\u901a\u8fc7\u521b\u65b0\u8bbe\u8ba1\u63d0\u5347\u4e86MoE\u5728\u8fb9\u7f18\u8bbe\u5907\u7684\u6027\u80fd\uff0c\u4e3a\u9ad8\u80fd\u6548\u90e8\u7f72\u63d0\u4f9b\u53ef\u884c\u65b9\u6848\u3002"}}
{"id": "2601.21701", "categories": ["cs.NI"], "pdf": "https://arxiv.org/pdf/2601.21701", "abs": "https://arxiv.org/abs/2601.21701", "authors": ["Ankita Koley", "Anu Krishna", "Chandramani Singh", "V Mahendran"], "title": "Age Aware Content Fetching and Broadcast in a Sensing-as-a-Service System", "comment": null, "summary": "We consider a Sensing-as-a-Service (S2aaS) system consisting of a sensor, a set of users, and a sensor cloud service provider (SCSP). The sensor updates its content each time it captures a new measurement. The SCSP occasionally fetches the content from the sensor, caches the latest fetched version and broadcasts it on being requested by the users. The SCSP incurs content fetching costs while fetching and broadcasting the contents. The SCSP also incurs an age cost if users do not receive the most recent version of the content after requesting. We study a content fetching and broadcast problem, aiming to minimize the time-averaged content fetching and age costs. The problem can be framed as a Markov decision process but cannot be elegantly solved owing to its multi-dimensional state space and complex dynamics. To address this, we first obtain the optimal policy for the homogeneous case with all the users having the same request probability and age cost. We extend this algorithm for heterogeneous case but the complexity grows exponentially with the number of users. To tackle this, we propose a low complexity Whittle index based algorithm, which performs very close to the optimal. The complexity of the algorithm is linear in number of users and serves as a heuristic for both homogeneous and heterogeneous cases.", "AI": {"tldr": "\u7814\u7a76\u4f20\u611f\u5373\u670d\u52a1(S2aaS)\u7cfb\u7edf\u4e2d\u7684\u5185\u5bb9\u66f4\u65b0\u95ee\u9898\uff0c\u63d0\u51fa\u57fa\u4e8e\u5a01\u7279\u5c14\u6307\u6570\u7684\u4f4e\u590d\u6742\u5ea6\u7b97\u6cd5\uff0ccompile to\u8fde\u63a5\u5747\u5300\u548c\u975e\u5747\u5300\u7528\u6237\u4e0b\u7684\u6210\u672c\u4f18\u5316\u3002", "motivation": "\u4f20\u611f\u4e91\u670d\u52a1\u63d0\u4f9b\u5546(SCSP)\u9700\u5e73\u8861\u5185\u5bb9\u83b7\u53d6\u6210\u672c\u4e0e\u7528\u6237\u63a5\u6536\u8fc7\u65f6\u5185\u5bb9\u4ea7\u751f\u7684\u65f6\u5ef6\u6210\u672c\uff0c\u4f46\u591a\u7ef4\u72b6\u6001\u7a7a\u95f4\u548c\u590d\u6742\u52a8\u6001\u6027\u4f7f\u4f20\u7edf\u9a6c\u5c14\u53ef\u592b\u51b3\u7b56\u8fc7\u7a0b\u96be\u4ee5\u6c42\u89e3\u3002", "method": "\u5148\u9488\u5bf9\u7528\u6237\u8bf7\u6c42\u6982\u7387\u548c\u65f6\u5ef6\u6210\u672c\u5747\u4e00\u7684\u7c97\u7269\u7406\u83b7\u53d6\u6700\u4f18\u7b56\u7565\uff0c\u518d\u6269\u5c55\u81f3\u975e\u5747\u5300\u573a\u666f\uff1b\u4e3a\u964d\u590d\u6742\u5ea6\uff0c\u8bbe\u8ba1\u57fa\u4e8e\u5a01\u7279\u5c14\u6307\u6570\u7684\u542f\u53d1\u5f0f\u7b97\u6cd5\u3002", "result": "\u6240\u63d0\u7b97\u6cd5\u5728\u975e\u5747\u5300\u7528\u6237\u4e0b\u6027\u80fd\u63a5\u8fd1\u6700\u4f18\uff0c\u590d\u6742\u5ea6\u4ec5\u968f\u7528\u6237\u6570\u7ebf\u6027\u589e\u957f\uff0c\u540c\u65f6\u9002\u7528\u4e8e\u5747\u5300\u4e0e\u975e\u5747\u5300\u573a\u666f\u3002", "conclusion": "\u5a01\u7279\u5c14\u6307\u6570\u7b97\u6cd5\u9ad8\u6548\u89e3\u51b3\u591a\u7ef4\u72b6\u6001\u96be\u9898\uff0c\u4e3aS2aaS\u7cfb\u7edf\u63d0\u4f9b\u8fd1\u6700\u4f18\u3001\u53ef\u6269\u5c55\u7684\u6210\u672c\u4f18\u5316\u65b9\u6848\u3002"}}
{"id": "2601.20980", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2601.20980", "abs": "https://arxiv.org/abs/2601.20980", "authors": ["Kelechi G. Kalu", "Soham Rattan", "Taylor R. Schorlemmer", "George K. Thiruvathukal", "Jeffrey C. Carver", "James C. Davis"], "title": "Operationalizing Research Software for Supply Chain Security", "comment": null, "summary": "Empirical studies of research software are hard to compare because the literature operationalizes ``research software'' inconsistently. Motivated by the research software supply chain (RSSC) and its security risks, we introduce an RSSC-oriented taxonomy that makes scope and operational boundaries explicit for empirical research software security studies.\n  We conduct a targeted scoping review of recent repository mining and dataset construction studies, extracting each work's definition, inclusion criteria, unit of analysis, and identification heuristics. We synthesize these into a harmonized taxonomy and a mapping that translates prior approaches into shared taxonomy dimensions. We operationalize the taxonomy on a large community-curated corpus from the Research Software Encyclopedia (RSE), producing an annotated dataset, a labeling codebook, and a reproducible labeling pipeline. Finally, we apply OpenSSF Scorecard as a preliminary security analysis to show how repository-centric security signals differ across taxonomy-defined clusters and why taxonomy-aware stratification is necessary for interpreting RSSC security measurements.", "AI": {"tldr": "\u8bba\u6587\u9488\u5bf9\u7814\u7a76\u8f6f\u4ef6\u5b9a\u4e49\u4e0d\u7edf\u4e00\u7684\u95ee\u9898\uff0c\u63d0\u51fa\u4e86\u57fa\u4e8e\u7814\u7a76\u8f6f\u4ef6\u4f9b\u5e94\u94fe\uff08RSSC\uff09\u7684\u5206\u7c7b\u6cd5\uff0c\u5e76\u901a\u8fc7\u5b89\u5168\u5206\u6790\u5c55\u793a\u5176\u5fc5\u8981\u6027\u3002", "motivation": "\u73b0\u6709\u7814\u7a76\u5bf9\u300e\u7814\u7a76\u8f6f\u4ef6\u300f\u7684\u64cd\u4f5c\u5316\u5b9a\u4e49\u4e0d\u4e00\u81f4\uff0c\u96be\u4ee5\u6bd4\u8f83\u5b9e\u8bc1\u7ed3\u679c\u3002\u9274\u4e8e\u7814\u7a76\u8f6f\u4ef6\u4f9b\u5e94\u94fe\u7684\u5b89\u5168\u98ce\u9669\uff0c\u9700\u660e\u786e\u754c\u5b9a\u7814\u7a76\u8303\u56f4\u548c\u64cd\u4f5c\u8fb9\u754c\u3002", "method": "\u9996\u5148\u5bf9\u8fd1\u671f\u4ed3\u5e93\u6316\u6398\u548c\u6570\u636e\u96c6\u6784\u5efa\u7814\u7a76\u8fdb\u884c\u8303\u56f4\u5ba1\u67e5\uff0c\u63d0\u53d6\u5b9a\u4e49\u3001\u7eb3\u5165\u6807\u51c6\u7b49\u8981\u7d20\uff1b\u7efc\u5408\u4e3a\u7edf\u4e00\u5206\u7c7b\u6cd5\uff1b\u5728RSE\u8bed\u6599\u5e93\u4e0a\u64cd\u4f5c\u5316\u5206\u7c7b\u6cd5\uff0c\u751f\u6210\u6807\u6ce8\u6570\u636e\u96c6\u548c\u53ef\u590d\u73b0\u6d41\u7a0b\uff1b\u6700\u540e\u4f7f\u7528OpenSSF Scorecard\u8fdb\u884c\u5b89\u5168\u4fe1\u53f7\u5206\u6790\u3002", "result": "\u5b89\u5168\u4fe1\u53f7\u5728\u4e0d\u540c\u5206\u7c7b\u7c07\u95f4\u5b58\u5728\u663e\u8457\u5dee\u5f02\uff0c\u8bc1\u660e\u57fa\u4e8e\u5206\u7c7b\u6cd5\u7684\u5206\u5c42\u5bf9\u51c6\u786e\u89e3\u91ca\u7814\u7a76\u8f6f\u4ef6\u4f9b\u5e94\u94fe\u5b89\u5168\u6d4b\u91cf\u81f3\u5173\u91cd\u8981\u3002", "conclusion": "\u8be5\u5206\u7c7b\u6cd5\u4e3a\u7814\u7a76\u8f6f\u4ef6\u5b89\u5168\u5b9e\u8bc1\u7814\u7a76\u63d0\u4f9b\u4e86\u660e\u786e\u6846\u67b6\uff0c\u5176\u5206\u5c42\u5206\u6790\u80fd\u63d0\u5347\u5b89\u5168\u98ce\u9669\u8bc4\u4f30\u7684\u4e00\u81f4\u6027\u548c\u53ef\u6bd4\u6027\u3002"}}
{"id": "2601.21861", "categories": ["cs.NI", "cs.MA", "eess.SY"], "pdf": "https://arxiv.org/pdf/2601.21861", "abs": "https://arxiv.org/abs/2601.21861", "authors": ["Chuan-Chi Lai"], "title": "Spatiotemporal Continual Learning for Mobile Edge UAV Networks: Mitigating Catastrophic Forgetting", "comment": "12 pages, 9 figures, manuscript submitted to IEEE Transactions on Emerging Topics in Computing", "summary": "This paper addresses the critical challenge of coordinating mobile edge UAV networks to maintain robust service in highly dynamic spatiotemporal environments. Conventional Deep Reinforcement Learning (DRL) approaches often suffer from catastrophic forgetting when transitioning between distinct task scenarios, such as moving from dense urban clusters to sparse rural areas. These transitions typically necessitate computationally expensive retraining or model resets to adapt to new user distributions, leading to service interruptions. To overcome these limitations, we propose a computationally efficient Spatiotemporal Continual Learning (STCL) framework realized through a Group-Decoupled Multi-Agent Proximal Policy Optimization (G-MAPPO) algorithm. Our approach integrates a novel Group-Decoupled Policy Optimization (GDPO) mechanism that utilizes dynamic $z$-score normalization to autonomously balance heterogeneous objectives, including energy efficiency, user fairness, and coverage. This mechanism effectively mitigates gradient conflicts induced by concept drifts without requiring offline retraining. Furthermore, the framework leverages the 3D mobility of UAVs as a spatial compensation layer, enabling the swarm to autonomously adjust altitudes to accommodate extreme density fluctuations. Extensive simulations demonstrate that the proposed STCL framework achieves superior resilience, characterized by an elastic recovery of service reliability to approximately 0.95 during phase transitions. Compared to the MADDPG baseline, G-MAPPO not only prevents knowledge forgetting but also delivers an effective capacity gain of 20\\% under extreme traffic loads, validating its potential as a scalable solution for edge-enabled aerial swarms.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.21070", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.21070", "abs": "https://arxiv.org/abs/2601.21070", "authors": ["Daniel Rodriguez-Cardenas", "Xiaochang Li", "Marcos Macedo", "Antonio Mastropaolo", "Dipin Khati", "Yuan Tian", "Huajie Shao", "Denys Poshyvanyk"], "title": "Towards Comprehensive Benchmarking Infrastructure for LLMs In Software Engineering", "comment": "Short paper from bechmarking for software engineering workshop FSE2025", "summary": "Large language models for code are advancing fast, yet our ability to evaluate them lags behind. Current benchmarks focus on narrow tasks and single metrics, which hide critical gaps in robustness, interpretability, fairness, efficiency, and real-world usability. They also suffer from inconsistent data engineering practices, limited software engineering context, and widespread contamination issues. To understand these problems and chart a path forward, we combined an in-depth survey of existing benchmarks with insights gathered from a dedicated community workshop. We identified three core barriers to reliable evaluation: the absence of software-engineering-rich datasets, overreliance on ML-centric metrics, and the lack of standardized, reproducible data pipelines. Building on these findings, we introduce BEHELM, a holistic benchmarking infrastructure that unifies software-scenario specification with multi-metric evaluation. BEHELM provides a structured way to assess models across tasks, languages, input and output granularities, and key quality dimensions. Our goal is to reduce the overhead currently required to construct benchmarks while enabling a fair, realistic, and future-proof assessment of LLMs in software engineering.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.21758", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.21758", "abs": "https://arxiv.org/abs/2601.21758", "authors": ["Bronislav Sidik", "Chaya Levi", "Joseph Kampeas"], "title": "EWSJF: An Adaptive Scheduler with Hybrid Partitioning for Mixed-Workload LLM Inference", "comment": null, "summary": "Serving Large Language Models (LLMs) under mixed workloads--short, latency-sensitive interactive queries alongside long, throughput-oriented batch requests--poses a fundamental scheduling challenge. Standard First-Come, First-Served (FCFS) policies suffer from severe head-of-line blocking, leading to high tail latency and underutilized hardware. We introduce EWSJF (Effective Workload-based Shortest Job First), an adaptive request-level scheduler that learns workload structure in real time to jointly improve fairness and throughput. EWSJF operates upstream of execution-level schedulers and integrates four components: (1) Refine-and-Prune, an unsupervised partitioning algorithm that discovers performance-homogeneous request groups; (2) Dynamic Queue Routing for assigning requests to these groups; (3) Density-Weighted Scoring, a context-aware prioritization function balancing urgency and fairness; and (4) Bayesian Meta-Optimization, which continuously tunes scoring and partitioning parameters based on live performance feedback. Implemented in vLLM, EWSJF improves end-to-end throughput by over 30% and reduces average Time-To-First-Token for short requests by up to 4x compared to FCFS. These results demonstrate that adaptive, learning-based request scheduling is a critical missing layer for efficient and responsive LLM serving. Implementation available at https://anonymous.4open.science/r/vllm_0110-32D8.", "AI": {"tldr": "\u672c\u6587\u63d0\u51faEWSJF\u81ea\u9002\u5e94\u8bf7\u6c42\u8c03\u5ea6\u5668\uff0c\u7528\u4e8e\u4f18\u5316\u5927\u578b\u8bed\u8a00\u6a21\u578b\u5728\u6df7\u5408\u5de5\u4f5c\u8d1f\u8f7d\u4e0b\u7684\u6027\u80fd\uff0c\u63d0\u9ad8\u541e\u5410\u91cf\u5e76\u51cf\u5c11\u5ef6\u8fdf\u3002", "motivation": "\u4f20\u7edf\u5148\u8fdb\u5148\u51fa\uff08FCFS\uff09\u8c03\u5ea6\u5728\u9762\u5bf9\u4ea4\u4e92\u5f0f\u77ed\u8bf7\u6c42\u548c\u6279\u91cf\u957f\u8bf7\u6c42\u7684\u6df7\u5408\u8d1f\u8f7d\u65f6\uff0c\u5b58\u5728\u961f\u5934\u963b\u585e\u95ee\u9898\uff0c\u5bfc\u81f4\u9ad8\u5c3e\u5ef6\u8fdf\u548c\u786c\u4ef6\u5229\u7528\u7387\u4f4e\u4e0b\uff0c\u9700\u8981\u52a8\u6001\u8c03\u5ea6\u89e3\u51b3\u65b9\u6848\u3002", "method": "EWSJF\u5305\u542b\u56db\u4e2a\u7ec4\u4ef6\uff1aRefine-and-Prune\u65e0\u76d1\u7763\u7b97\u6cd5\u5212\u5206\u540c\u8d28\u8bf7\u6c42\u7ec4\uff0cDynamic Queue Routing\u52a8\u6001\u5206\u914d\u8bf7\u6c42\uff0cDensity-Weighted Scoring\u5e73\u8861\u4f18\u5148\u7ea7\u516c\u5e73\u6027\u7684\u8bc4\u5206\u51fd\u6570\uff0c\u4ee5\u53caBayesian Meta-Optimization\u5b9e\u65f6\u8c03\u6574\u53c2\u6570\u7684\u81ea\u8c03\u4f18\u673a\u5236\u3002", "result": "\u5728vLLM\u4e2d\u5b9e\u73b0EWSJF\u540e\uff0c\u76f8\u6bd4FCFS\uff0c\u7aef\u5230\u7aef\u541e\u5410\u91cf\u63d0\u534730%\u4ee5\u4e0a\uff0c\u77ed\u8bf7\u6c42\u5e73\u5747\u9996\u4ee4\u724c\u65f6\u95f4\u51cf\u5c11\u53ef\u8fbe4\u500d\u3002", "conclusion": "\u81ea\u9002\u5e94\u5b66\u4e60\u578b\u8bf7\u6c42\u8c03\u5ea6\u662f\u63d0\u9ad8\u5927\u578b\u8bed\u8a00\u6a21\u578b\u670d\u52a1\u6548\u7387\u548c\u54cd\u5e94\u6027\u7684\u6838\u5fc3\u7f3a\u5931\u5c42\uff0c\u4e3a\u6df7\u5408\u5de5\u4f5c\u8d1f\u8f7d\u63d0\u4f9b\u53ef\u884c\u65b9\u6848\u3002"}}
{"id": "2601.21935", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2601.21935", "abs": "https://arxiv.org/abs/2601.21935", "authors": ["Tom Yates", "Yuzhou Cheng", "Ignacio Alzugaray", "Danyal Akarca", "Pedro A. M. Mediano", "Andrew J. Davison"], "title": "Belief Propagation Converges to Gaussian Distributions in Sparsely-Connected Factor Graphs", "comment": "Preprint. Under review. 25 pages (including Appendix). 8 Figures", "summary": "Belief Propagation (BP) is a powerful algorithm for distributed inference in probabilistic graphical models, however it quickly becomes infeasible for practical compute and memory budgets. Many efficient, non-parametric forms of BP have been developed, but the most popular is Gaussian Belief Propagation (GBP), a variant that assumes all distributions are locally Gaussian. GBP is widely used due to its efficiency and empirically strong performance in applications like computer vision or sensor networks - even when modelling non-Gaussian problems. In this paper, we seek to provide a theoretical guarantee for when Gaussian approximations are valid in highly non-Gaussian, sparsely-connected factor graphs performing BP (common in spatial AI). We leverage the Central Limit Theorem (CLT) to prove mathematically that variables' beliefs under BP converge to a Gaussian distribution in complex, loopy factor graphs obeying our 4 key assumptions. We then confirm experimentally that variable beliefs become increasingly Gaussian after just a few BP iterations in a stereo depth estimation task.", "AI": {"tldr": "\u8be5\u8bba\u6587\u8bc1\u660e\u5728\u6ee1\u8db34\u4e2a\u5173\u952e\u5047\u8bbe\u7684\u7a00\u758f\u56e0\u5b50\u56fe\u4e2d\uff0c\u4fe1\u5ff5\u4f20\u64ad\u53d8\u91cf\u7684\u4fe1\u5ff5\u4f1a\u6536\u655b\u4e8e\u9ad8\u65af\u5206\u5e03\uff0c\u5e76\u901a\u8fc7\u5b9e\u9a8c\u9a8c\u8bc1\u5176\u6709\u6548\u6027\u3002", "motivation": "\u9ad8\u65af\u4fe1\u5ff5\u4f20\u64ad\u5728\u5e94\u7528\u4e2d\u8868\u73b0\u826f\u597d\u4f46\u7f3a\u4e4f\u7406\u8bba\u652f\u6301\uff0c\u7279\u522b\u662f\u5728\u9ad8\u5ea6\u975e\u9ad8\u65af\u95ee\u9898\u4e2d\uff0c\u56e0\u6b64\u672c\u7814\u7a76\u65e8\u5728\u63d0\u4f9b\u5176\u6709\u6548\u6027\u7684\u7406\u8bba\u4fdd\u8bc1\u3002", "method": "\u5229\u7528amus \u4e2d\u5fc3\u6781\u9650\u5b9a\u7406\u8bc1\u660e\u4fe1\u5ff5\u4f20\u64ad\u53d8\u91cf\u4fe1\u5ff5\u5728\u73af\u8def\u56e0\u5b50\u56fe\u4e2d\u6536\u655b\u5230\u9ad8\u65af\u5206\u5e03\uff0c\u57fa\u4e8e4\uc5c8\u5173\u952e\u5047\u8bbe\uff0c\u5e76\u901a\u8fc7\u7acb\u4f53\u6df1\u5ea6\u4f30\u8ba1\u4efb\u52a1\u8fdb\u884c\u5b9e\u9a8c\u9a8c\u8bc1\u3002", "result": "\u7406\u8bba\u548c\u5b9e\u9a8c\u663e\u793a\uff0c\u5728\u590d\u6742\u56e0\u5b50\u56fe\u4e2d\uff0c\u53d8\u91cf\u4fe1\u5ff5\u7ecf\u6570\u6b21\u8fed\u4ee3\u540e\u5feb\u901f\u8d8b\u8fd1\u9ad8\u65af\u5206\u5e03\uff0c\u9a8c\u8bc1\u4e86\u9ad8\u65af\u8fd1\u4f3c\u7684\u9002\u7528\u6027\u3002", "conclusion": "\u672c\u7814\u7a76\u4e3a\u9ad8\u65af\u4fe1\u5ff5\u4f20\u64ad\u5728\u7a7a\u95f4AI\u7b49\u9886\u57df\u7684\u975e\u9ad8\u65af\u95ee\u9898\u4e2d\u63d0\u4f9b\u4e86\u575a\u5b9e\u7684\u7406\u8bba\u57fa\u7840\uff0c\u589e\u5f3a\u4e86\u5176\u5b9e\u7528\u53ef\u9760\u6027\u3002"}}
{"id": "2601.21186", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21186", "abs": "https://arxiv.org/abs/2601.21186", "authors": ["TianYi Tang", "Saba Alimadadi", "Nick Sumner"], "title": "From Logic to Toolchains: An Empirical Study of Bugs in the TypeScript Ecosystem", "comment": null, "summary": "TypeScript has rapidly become a popular language for modern web development, yet its effect on software faults remains poorly understood. This paper presents the first large-scale empirical study of bugs in real-world TypeScript projects. We analyze 633 bug reports from 16 popular open-source repositories to construct a taxonomy of fault types, quantify their prevalence, and relate them to project characteristics such as size, domain, and dependency composition. Our results reveal a fault landscape dominated not by logic or syntax errors but by tooling and configuration faults, API misuses, and asynchronous error-handling issues. We show that these categories correlate strongly with build complexity and dependency heterogeneity, indicating that modern failures often arise at integration and orchestration boundaries rather than within algorithmic logic. A longitudinal comparison with JavaScript studies shows that while static typing in TypeScript has reduced traditional runtime and type errors, it has shifted fragility toward build systems and toolchains. These findings offer new insight into how language design and ecosystem evolution reshape the fault profiles of large-scale software systems.", "AI": {"tldr": "\u672c\u6587\u9996\u6b21\u5bf9\u771f\u5b9e\u4e16\u754cTypeScript\u9879\u76ee\u4e2d\u7684bug\u8fdb\u884c\u5927\u89c4\u6a21\u5b9e\u8bc1\u7814\u7a76\uff0c\u5206\u6790633\u4e2abug\u62a5\u544a\u540e\u53d1\u73b0\u6545\u969c\u4e3b\u8981\u7531\u5de5\u5177\u914d\u7f6e\u9519\u8bef\u3001API\u6ee5\u7528\u548c\u5f02\u6b65\u9519\u8bef\u5904\u7406\u4e3b\u5bfc\uff0c\u800c\u975e\u4f20\u7edf\u903b\u8f91\u6216\u8bed\u6cd5\u9519\u8bef\uff1b\u8fd9\u4e9b\u6545\u969c\u4e0e\u6784\u5efa\u590d\u6742\u6027\u548c\u4f9d\u8d56\u5f02\u6784\u6027\u76f8\u5173\uff0c\u8868\u660e\u9759\u6001\u7c7b\u578b\u51cf\u5c11\u4e86\u8fd0\u884c\u65f6\u9519\u8bef\uff0c\u5374\u589e\u52a0\u4e86\u6784\u5efa\u7cfb\u7edf\u7684\u8106\u5f31\u6027\u3002", "motivation": "TypeScript\u5df2\u5728\u73b0\u4ee3Web\u5f00\u53d1\u4e2d\u5e7f\u53d7\u6b22\u8fce\uff0c\u4f46\u5176\u5bf9\u8f6f\u4ef6\u6545\u969c\u7684\u5b9e\u9645\u5f71\u54cd\u5c1a\u7f3a\u4e4f\u6df1\u5165\u4e86\u89e3\uff0c\u672c\u7814\u7a76\u65e8\u5728\u586b\u8865\u8fd9\u4e00\u7a7a\u767d\u3002", "method": "\u5206\u679016\u4e2a\u6d41\u884c\u5f00\u6e90\u4ed3\u5e93\u7684633\u4e2abug\u62a5\u544a\uff0c\u6784\u5efa\u6545\u969c\u7c7b\u578b\u5206\u7c7b\u4f53\u7cfb\uff0c\u91cf\u5316\u9891\u7387\u5206\u5e03\uff0c\u5e76\u5c06\u5176\u4e0e\u9879\u76ee\u7279\u6027\uff08\u5982\u5927\u5c0f\u3001\u9886\u57df\u548c\u4f9d\u8d56\u7ec4\u6210\uff09\u5173\u8054\u5206\u6790\u3002", "result": "\u7ed3\u679c\u663e\u793a\uff1a\u4e3b\u5bfc\u6545\u969c\u7c7b\u578b\u4e3a\u5de5\u5177\u914d\u7f6e\u9519\u8bef\uff08\u5982\u6784\u5efa\u5de5\u5177\u95ee\u9898 appear\uff09\u3001API\u6ee5\u7528\u548c\u5f02\u6b65\u9519\u8bef\u5904\u7406\uff0c\u8fd9\u4e9b\u7c7b\u578b\u4e0e\u9879\u76ee\u6784\u5efa\u590d\u6742\u6027\u548c\u4f9d\u8d56\u5f02\u6784\u6027\u5f3a\u76f8\u5173\uff1b\u7eb5\u5411\u5bf9\u6bd4JavaScript\u8868\u660e\uff0cTypeScript\u7684\u9759\u6001\u7c7b\u578b\u51cf\u5c11\u4e86\u8fd0\u884c\u65f6\u548c\u7c7b\u578b\u9519\u8bef\uff0c\u4f46\u5c06\u8106\u5f31\u6027\u8f6c\u5411\u6784\u5efa\u7cfb\u7edf\u548c\u5de5\u5177\u94fe\u3002", "conclusion": "\u8be5\u7814\u7a76\u63ed\u793a\u4e86\u8bed\u8a00\u8bbe\u8ba1\u548c\u751f\u6001\u7cfb\u7edf\u53d1\u5c55\u5982\u4f55\u91cd\u5851\u5927\u89c4\u6a21\u8f6f\u4ef6\u7cfb\u7edf\u7684\u6545\u969c\u6a21\u5f0f\uff0c\u5f3a\u8c03\u4e86\u96c6\u6210\u8fb9\u754c\u548c\u7f16\u6392\u95ee\u9898\u5728\u5f53\u4ee3\u6545\u969c\u4e2d\u7684\u6838\u5fc3\u4f5c\u7528\uff0c\u4e3a\u672a\u6765\u5de5\u5177\u4f18\u5316\u548c\u8bed\u8a00\u6f14\u8fdb\u63d0\u4f9b\u65b0\u89c1\u89e3\u3002"}}
{"id": "2601.21259", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21259", "abs": "https://arxiv.org/abs/2601.21259", "authors": ["Sayma Sultana", "London Cavaletto", "Bianca Trinkenreich", "Amiangshu Bosu"], "title": "The Role of Social Identity in Shaping Biases Against Minorities in Software Organizations", "comment": null, "summary": "While systemic workplace bias is well-documented in non-computing fields, its specific impact on software engineers remains poorly understood. This study addresses that gap by applying Social Identity Theory (SIT) to investigate four distinct forms of bias: lack of career development, stereotyped task selection, unwelcoming environments, and identity attacks. Using a vignette-based survey, we quantified the prevalence of these biases, identified the demographics most affected, assessed their consequences, and explored the motivations behind biased actions. Our results show that career development and task selection biases are the most prevalent forms, with over two-thirds of victims experiencing them multiple times. Women were more than three times as likely as men to face career development bias, task selection bias, and an unwelcoming environment. In parallel, individuals from marginalized ethnic backgrounds were disproportionately targeted by identity attacks. Our analysis also confirms that, beyond gender and race, factors such as age, years of experience, organization size, and geographic location are significant predictors of bias victimization.", "AI": {"tldr": "\u672c\u7814\u7a76\u8fd0\u7528\u793e\u4f1a\u540c\u4e00\u6027\u7406\u8bba\u63a2\u8ba8\u7cfb\u7edf\u6027\u5de5\u4f5c\u573a\u6240\u504f\u89c1\u5bf9\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u7684\u5f71\u54cd\uff0c\u8bc6\u522b\u804c\u4e1a\u53d1\u5c55\u548c\u4efb\u52a1\u9009\u62e9\u504f\u89c1\u6700\u4e3a\u666e\u904d\uff0c\u5973\u6027\u53d7\u5bb3\u7387\u9ad8\u4e14\u6d89\u53ca\u591a\u4e2a\u56e0\u7d20\u3002", "motivation": "\u5f25\u8865\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u9886\u57df\u504f\u89c1\u5f71\u54cd\u8ba4\u77e5\u4e0d\u8db3\uff0c\u65e8\u5728\u91cf\u5316\u504f\u89c1\u5f62\u5f0f\u5e76\u586b\u8865\u76f8\u5173\u7814\u7a76\u7a7a\u767d\u3002", "method": "\u91c7\u7528\u57fa\u4e8e\u60c5\u5883\u7684\u95ee\u5377\u8c03\u67e5\uff0c\u91cf\u5316\u504f\u89c1\u666e\u904d\u6027\u3001\u53d7\u5bb3\u7fa4\u4f53\u7279\u5f81\u3001\u5f71\u54cd\u540e\u679c\u548c\u884c\u4e3a\u52a8\u673a\u3002", "result": "\u804c\u4e1a\u53d1\u5c55\u548c\u4efb\u52a1\u9009\u62e9\u504f\u89c1\u6700\u5e38\u89c1\uff0c\u8d852/3\u53d7\u5bb3\u8005\u5c61\u6b21\u7ecf\u5386\uff1b\u5973\u6027\u53d7\u5bb3\u0646\u0627\u062f\u0649\u51e0\u7387\u9ad8\u4e09\u500d\u4ee5\u4e0a\uff1b\u6c11\u65cf\u80cc\u666f\u5f31\u52bf\u7fa4\u4f53\u6613\u53d7\u8eab\u4efd\u653b\u51fb\uff1b\u5e74\u9f84\u3001\u7ecf\u9a8c\u3001\u7ec4\u7ec7\u5927\u5c0f\u548c\u5730\u7406\u4f4d\u7f6e\u540c\u6837\u9884\u6d4b\u504f\u89c1\u53d7\u5bb3\u3002", "conclusion": "\u504f\u89c1\u53d7\u5bb3\u53d7\u5230\u6027\u522b\u3001\u79cd\u65cf\u3001\u5e74\u9f84\u7b49\u591a\u56e0\u7d20\u5f71\u54cd\uff0c\u5f3a\u8c03\u9700\u7cfb\u7edf\u6027\u5e72\u9884\u63aa\u65bd\u4ee5\u63d0\u5347\u804c\u573a\u5e73\u7b49\u3002"}}
{"id": "2601.21298", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21298", "abs": "https://arxiv.org/abs/2601.21298", "authors": ["Beomsu Koh", "Neil Walkinshaw", "Donghwan Shin"], "title": "Detecting Multiple Semantic Concerns in Tangled Code Commits", "comment": "28 pages, 12 figures. Submitted to Empirical Software Engineering (Springer)", "summary": "Code commits in a version control system (e.g., Git) should be atomic, i.e., focused on a single goal, such as adding a feature or fixing a bug. In practice, however, developers often bundle multiple concerns into tangled commits, obscuring intent and complicating maintenance. Recent studies have used Conventional Commits Specification (CCS) and Language Models (LMs) to capture commit intent, demonstrating that Small Language Models (SLMs) can approach the performance of Large Language Models (LLMs) while maintaining efficiency and privacy. However, they do not address tangled commits involving multiple concerns, leaving the feasibility of using LMs for multi-concern detection unresolved. In this paper, we frame multi-concern detection in tangled commits as a multi-label classification problem and construct a controlled dataset of artificially tangled commits based on real-world data. We then present an empirical study using SLMs to detect multiple semantic concerns in tangled commits, examining the effects of fine-tuning, concern count, commit-message inclusion, and header-preserving truncation under practical token-budget limits. Our results show that a fine-tuned 14B-parameter SLM is competitive with a state-of-the-art LLM for single-concern commits and remains usable for up to three concerns. In particular, including commit messages improves detection accuracy by up to 44% (in terms of Hamming Loss) with negligible latency overhead, establishing them as important semantic cues.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u4f7f\u7528\u5c0f\u578b\u8bed\u8a00\u6a21\u578b\u68c0\u6d4b\u590d\u6742\u4ee3\u7801\u63d0\u4ea4\u4e2d\u591a\u5173\u6ce8\u70b9\u7684\u65b9\u6cd5\uff0c\u5305\u62ec\u6784\u5efa\u6570\u636e\u96c6\u548c\u591a\u6807\u7b7e\u5206\u7c7b\u6846\u67b6\uff0c\u5b9e\u8bc1\u7814\u7a76\u8868\u660e\u5fae\u8c03\u540e\u7684\u6a21\u578b\u9ad8\u6548\u4e14\u51c6\u786e\u3002", "motivation": "\u73b0\u6709\u65b9\u6cd5\u5ffd\u7565\u590d\u6742\u63d0\u4ea4\u7684\u591a\u5173\u6ce8\u70b9\u95ee\u9898\uff0c\u4e3a\u63a2\u7d22\u8bed\u8a00\u6a21\u578b\u5728\u591a\u5173\u6ce8\u70b9\u68c0\u6d4b\u4e2d\u7684\u53ef\u884c\u6027\uff0c\u907f\u514d\u7ef4\u62a4\u56f0\u96be\u3002", "method": "\u91c7\u7528\u591a\u6807\u7b7e\u5206\u7c7b\u6846\u67b6\uff0c\u57fa\u4e8e\u771f\u5b9e\u6570\u636e\u6784\u5efa\u4eba\u5de5\u6df7\u5408\u4f5c\u6570\u636e\u96c6\uff0c\u5b9e\u8bc1\u7814\u7a76\u5c0f\u578b\u8bed\u8a00\u6a21\u578b\uff08SLMs\uff09\u7684\u5fae\u8c03\u6548\u679c\u3001\u5173\u6ce8\u70b9\u6570\u91cf\u3001\u63d0\u4ea4\u6d88\u606f\u5305\u542b\u53ca\u5934\u90e8\u4fdd\u7559\u622a\u043d\u0435\u0441\u0442\u0438\u044f\u7b56\u7565\u3002", "result": "\u5fae\u8c03\u540e140\u4ebf\u53c2\u6570SLM\u5728\u5355\u5173\u6ce8\u70b9\u4e0a\u4e0e\u5927\u578b\u8bed\u8a00\u6a21\u578b\u6027\u80fd\u76f8\u5f53\uff0c\u6700\u591a\u652f\u6301\u4e09\u4e2a\u5173\u6ce8\u70b9\uff1b\u5305\u542b\u63d0\u4ea4\u6d88\u606f\u53ef\u63d0\u5347\u68c0\u6d4b\u51c6\u786eples\u7387\u8fbe44%\uff08\u6c49\u660e\u635f\u5931\uff09\uff0c\u5ef6\u8fdf\u5f00\u9500\u5fae\u5c0f\u3002", "conclusion": "\u8bc1\u660e\u5c0f\u578b\u8bed\u8a00\u6a21\u578b\u9ad8\u6548\u53ef\u884c\u4e8e\u68c0\u6d4b\u590d\u6742\u63d0\u4ea4\u4e2d\u7684\u591a\u5173\u6ce8\u70b9\uff0c\u5c24\u5176\u5728\u5305\u542b\u63d0\u4ea4\u6d88\u606f\u65f6\u663e\u8457\u63d0\u5347\u6027\u80fd\u3002"}}
{"id": "2601.21305", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21305", "abs": "https://arxiv.org/abs/2601.21305", "authors": ["Mark Looi", "Julianne Quinn"], "title": "Developers in the Age of AI: Adoption, Policy, and Diffusion of AI Software Engineering Tools", "comment": "Submitted to Empirical Software Engineering (EMSE)", "summary": "The rapid advance of Generative AI into software development prompts this empirical investigation of perceptual effects on practice. We study the usage patterns of 147 professional developers, examining perceived correlates of AI tools use, the resulting productivity and quality outcomes, and developer readiness for emerging AI-enhanced development. We describe a virtuous adoption cycle where frequent and broad AI tools use are the strongest correlates of both Perceived Productivity (PP) and quality, with frequency strongest. The study finds no perceptual support for the Quality Paradox and shows that PP is positively correlated with Perceived Code Quality (PQ) improvement. Developers thus report both productivity and quality gains. High current usage, breadth of application, frequent use of AI tools for testing, and ease of use correlate strongly with future intended adoption, though security concerns remain a moderate and statistically significant barrier to adoption. Moreover, AI testing tools' adoption lags that of coding tools, opening a Testing Gap. We identify three developer archetypes (Enthusiasts, Pragmatists, Cautious) that align with an innovation diffusion process wherein the virtuous adoption cycle serves as the individual engine of progression. Our findings reveal that organizational adoption of AI tools follows such a process: Enthusiasts push ahead with tools, creating organizational success that converts Pragmatists. The Cautious are held in organizational stasis: without early adopter examples, they don't enter the virtuous adoption cycle, never accumulate the usage frequency that drives intent, and never attain high efficacy. Policy itself does not predict individuals' intent to increase usage but functions as a marker of maturity, formalizing the successful diffusion of adoption by Enthusiasts while acting as a gateway that the Cautious group has yet to reach.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.21379", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21379", "abs": "https://arxiv.org/abs/2601.21379", "authors": ["Jing Jiang", "Liehao Li", "Jinyun Hou", "Xin Tan", "Li Zhang"], "title": "Predicting Developer Acceptance of AI-Generated Code Suggestions", "comment": null, "summary": "AI-assisted programming tools are widely adopted, yet their practical utility is often undermined by undesired suggestions that interrupt developer workflows and cause frustration. While existing research has explored developer-AI interactions when programming qualitatively, a significant gap remains in quantitative analysis of developers' acceptance of AI-generated code suggestions, partly because the necessary fine-grained interaction data is often proprietary. To bridge this gap, this paper conducts an empirical study using 66,329 industrial developer-AI interactions from a large technology company. We analyze features that are significantly different between accepted code suggestions and rejected ones. We find that accepted suggestions are characterized by significantly higher historical acceptance counts and ratios for both developers and projects, longer generation intervals, shorter preceding code context in the project, and older IDE versions. Based on these findings, we introduce CSAP (Code Suggestion Acceptance Prediction) to predict whether a developer will accept the code suggestion before it is displayed. Our evaluation of CSAP shows that it achieves the accuracy of 0.973 and 0.922 on imbalanced and balanced dataset respectively. Compared to a large language model baseline and an in-production industrial filter, CSAP relatively improves the accuracy by 12.6\\% and 69.5\\% on imbalanced dataset, and improves the accuracy by 87.0\\% and 140.1\\% on balanced dataset. Our results demonstrate that targeted personalization is a powerful approach for filtering out code suggestions with predicted rejection and reduce developer interruption. To the best of our knowledge, it is the first quantitative study of code suggestion acceptance on large-scale industrial data, and this work also sheds light on an important research direction of AI-assisted programming.", "AI": {"tldr": "\u8be5\u8bba\u6587\u5b9e\u8bc1\u7814\u7a76\u5f00\u53d1\u8005\u5bf9AI\u4ee3\u7801\u5efa\u8bae\u7684\u63a5\u53d7\u5ea6\uff0c\u57fa\u4e8e\u5927\u578b\u5de5\u4e1a\u6570\u636e\u96c6\u5f00\u53d1CSAP\u9884\u6d4b\u6a21\u578b\uff0c\u7279\u5f81\u5206\u6790\u663e\u793a\u5386\u53f2\u63a5\u53d7\u7387\u7b49\u56e0\u7d20\u5173\u8054\u63a5\u53d7\u884c\u4e3a\uff0cCSAP\u5728\u5931\u8861\u6570\u636e\u96c6\u4e0a\u51c6\u786e\u7387\u8fbe97.3%\u3002", "motivation": "AI\u7f16\u7a0b\u5de5\u5177\u5e38\u56e0\u65e0\u5173\u5efa\u8bae\u5e72\u6270\u5f00\u53d1\u8005\u5de5\u4f5c\u6d41\u7a0b\u800c\u4ee4\u4eba\u6cae\u4e27\uff0c\u73b0\u6709\u7814\u7a76\u7f3a\u4e4f\u5bf9AI\u4ee3\u7801\u5efa\u8bae\u63a5\u53d7\u5ea6\u7684\u5b9a\u91cf\u5206\u6790\uff0c\u4e3b\u8981\u7531\u4e8e\u7ec6\u7c92\u5ea6\u5de5\u4e1a\u6570\u636e\u532e\u4e4f\uff0c\u672c\u5de5\u4f5c\u65e8\u5728\u586b\u8865\u6b64\u7a7a\u767d\u3002", "method": "\u5206\u679066,329\u6761\u6765\u81ea\u79d1\u6280\u516c\u53f8\u7684\u5de5\u4e1a\u5f00\u53d1\u8005-AI\u4ea4\u4e92\u6570\u636e\uff0c\u8bc6\u522b\u63a5\u53d7\u4e0e\u62d2\u7edd\u5efa\u8bae\u7684\u7279\u5f81\u5dee\u5f02\uff08\u5982\u66f4\u9ad8\u5386\u53f2\u63a5\u53d7\u7387\u3001\u66f4\u957f\u751f\u6210\u95f4\u9694\uff09\uff1b\u57fa\u4e8e\u6b64\u5f00\u53d1CSAP\u9884\u6d4b\u6a21\u578b\uff0c\u7528\u4e8e\u9884\u6d4b\u5efa\u8bae\u5c55\u793a\u524d\u7684\u63a5\u53d7\u53ef\u80fd\u6027\u3002", "result": "\u63a5\u53d7\u5efa\u8bae\u5173\u8054\u5386\u53f2\u63a5\u53d7\u8ba1\u6570\u66f4\u9ad8\u3001IDE\u7248\u672c\u8f83\u65e7\u7b49\u7279\u5f81\uff1bCSAP\u5728\u5931\u8861\u6570\u636e\u96c6\u7cbe\u5ea60.973\uff0c\u5e73\u8861\u6570\u636e\u96c6 kl8\u7efc\u5408\u7cbe\u5ea60.922\uff0c\u76f8\u5bf9\u57fa\u7ebf\u6a21\u578b\u6539\u8fdb\u8fbe12.6%-140.1%\u3002", "conclusion": "\u9488\u5bf9\u6027\u4e2a\u4eba\u5316\u53ef\u6709\u6548\u8fc7\u6ee4\u62d2\u7edd\u5efa\u8bae\uff0c \u0627\u0644\u062a\u062c\u0631\u0628\u0629\u5c11\u5f00\u53d1\u8005\u5e72\u6270\uff1b\u8fd9\u662f\u9996\u4e2a\u5de5\u4e1a\u89c4\u6a21\u5b9a\u91cf\u7814\u7a76\uff0c\u4e3aAI\u8f85\u52a9\u7f16\u7a0b\u5f00\u8f9f\u65b0\u65b9\u5411\uff0c\u5f3a\u8c03\u7279\u5f81\u9a71\u52a8\u6a21\u578b\u7684\u91cd\u8981\u6027\u3002"}}
{"id": "2601.21552", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21552", "abs": "https://arxiv.org/abs/2601.21552", "authors": ["Anubhab Ghosh", "Ajay Nayak", "Dhananjay Rao Thallikar Shyam", "Arkaprava Basu"], "title": "Chasing Elusive Memory Bugs in GPU Programs", "comment": null, "summary": "Memory safety bugs, such as out-of-bound accesses (OOB) in GPU programs, can compromise the security and reliability of GPU-accelerated software. We report the existence of input-dependent OOBs in the wild that manifest only under specific inputs. All existing tools to detect OOBs in GPU programs rely on runtime techniques that require an OOB to manifest for detection. Thus, input-dependent OOBs elude them. We also discover intra-allocation OOBs that arise in the presence of logical partitioning of a memory allocation into multiple data structures. Existing techniques are oblivious to the possibility of such OOBs.\n  We make a key observation that the presence (or absence) of semantic relations among program variables, which determines the size of allocations (CPU code) and those calculating offsets into memory allocations (GPU code), helps identify the absence (or presence) of OOBs. We build SCuBA, a first-of-its-kind compile-time technique that analyzes CPU and GPU code to capture such semantic relations (if present). It uses a SAT solver to check if an OOB access is possible under any input, given the captured relations expressed as constraints. It further analyzes GPU code to track logical partitioning of memory allocations for detecting intra-allocation OOB. Compared to NVIDIA's Compute Sanitizer that misses 45 elusive memory bugs across 20 programs, SCuBA misses none with no false alarms.", "AI": {"tldr": "SCuBA\u662f\u4e00\u79cd\u521b\u65b0\u7684\u7f16\u8bd1\u65f6\u6280\u672f,\u53ef\u68c0\u6d4bGPU\u7a0b\u5e8f\u4e2d\u7684\u8f93\u5165\u4f9d\u8d56\u8d8a\u754c\u8bbf\u95ee\u548c\u5206\u914d\u5185\u8d8a\u754c\u8bbf\u95ee\u6f0f\u6d1e\u3002", "motivation": "\u73b0\u6709\u8fd0\u884c\u65f6\u5de5\u5177\u4f9d\u8d56\u6f0f\u6d1e\u663e\u73b0\u624d\u80fd\u68c0\u6d4b,\u65e0\u6cd5\u8bc6\u522b\u8f93\u5165\u4f9d\u8d56\u8d8a\u754c\u8bbf\u95ee\u548c\u56e0\u5185\u5b58\u903b\u8f91\u5206\u533a\u5bfc\u81f4\u7684\u5206\u914d\u5185\u8d8a\u754c\u8bbf\u95ee\u3002", "method": "SCuBA\u5206\u6790CPU\u548cGPU\u4ee3\u7801\u4e2d\u7684\u8bed\u4e49\u5173\u7cfb,\u7ea6\u675f\u5f0f\u8f6c\u5316\u4e3a\u7ea6\u675f\u6761\u4ef6\u540e\u4f7f\u7528SAT\u6c42\u89e3\u5668\u9a8c\u8bc1\u4efb\u4f55\u8f93\u5165\u4e0b\u662f\u5426\u53ef\u80fd\u53d1\u751f\u8d8a\u754c\u8bbf\u95ee,\u5e76\u8ffd\u8e2a\u5185\u5b58\u5206\u914d\u903b\u8f91\u5206\u533a\u3002", "result": "\u76f8\u6bd4NVIDIA\u5de5\u5177\u572820\u4e2a\u7a0b\u5e8f\u4e2d\u9057\u6f0f45\u4e2a\u6f0f\u6d1e,SCuBA\u68c0\u6d4b\u6240\u6709\u6f0f\u6d1e\u4e14\u65e0\u8bef\u62a5\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u901a\u8fc7\u7f16\u8bd1\u65f6\u9759\u6001\u5206\u6790\u663e\u8457\u63d0\u5347\u4e86GPU\u7a0b\u5e8f\u7684\u5b89\u5168\u6027\u548c\u53ef\u9760\u6027\u3002"}}
{"id": "2601.21565", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.21565", "abs": "https://arxiv.org/abs/2601.21565", "authors": ["Adriana Novoa-Hurtado", "Rub\u00e9n Saborido", "Francisco Chicano", "Manuel Gim\u00e9nez-Medina"], "title": "Multi-objective Integer Linear Programming approach for Automatic Software Cognitive Complexity Reduction", "comment": "51 pages, 17 figures", "summary": "Clear and concise code is necessary to ensure maintainability, so it is crucial that the software is as simple as possible to understand, to avoid bugs and, above all, vulnerabilities. There are many ways to enhance software without changing its functionality, considering the extract method refactoring the primary process to reduce the effort required for code comprehension. The cognitive complexity measure employed in this work is the one defined by SonarSource, which is a company that develops well-known applications for static code analysis. This extraction problem can be modeled as a combinatorial optimization problem. The main difficulty arises from the existence of different criteria for evaluating the solutions obtained, requiring the formulation of the code extraction problem as a multi-objective optimization problem using alternative methods. We propose a multi-objective integer linear programming model to obtain a set of solutions that reduce the cognitive complexity of a given piece of code, such as balancing the number of lines of code and its cognitive complexity. In addition, several algorithms have been developed to validate the model. These algorithms have been integrated into a tool that enables the parameterised resolution of the problem of reducing software cognitive complexity.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e00\u79cd\u591a\u76ee\u6807\u6574\u6570\u7ebf\u6027\u89c4\u5212\u6a21\u578b\uff0c\u7528\u4e8e\u65b9\u6cd5\u63d0\u53d6\u91cd\u6784\u4ee3\u7801\uff0c\u65e8\u5728\u964d\u4f4e\u8ba4\u77e5\u590d\u6742\u5ea6\u548c\u5e73\u8861\u4ee3\u7801\u91cf\uff0c\u63d0\u5347\u8f6f\u4ef6\u53ef\u7ef4\u62a4\u6027\u3002", "motivation": "\u4e3a\u786e\u4fdd\u8f6f\u4ef6\u7b80\u6d01\u53ef\u7ef4\u62a4\u6027\u5e76\u51cf\u5c11\u6f0f\u6d1e\u548c\u9519\u8bef\uff0c\u9700\u8981\u4f18\u5316\u4ee3\u7801\u8ba4\u77e5\u590d\u6742\u5ea6\uff0c\u65b9\u6cd5\u662fSonarSource\u8861\u91cf\u6807\u51c6\u3002", "method": "\u5c06\u63d0\u53d6\u95ee\u9898\u5efa\u6a21\u4e3a\u7ec4\u5408\u4f18\u5316\u95ee\u9898\uff0c\u91c7\u7528\u591a\u76ee\u6807\u4f18\u5316\u65b9\u6cd5\u5f00\u53d1\u7b97\u6cd5\uff0c\u96c6\u6210\u5de5\u5177\u8fdb\u884c\u53c2\u6570\u5316\u6c42\u89e3\u3002", "result": "\u6a21\u578b\u751f\u6210\u7b80\u5316\u4ee3\u7801\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u9a8c\u8bc1\u7b97\u6cd5\u6709\u6548\uff0c\u5de5\u5177\u5b9e\u73b0\u8ba4\u77e5\u590d\u6742\u5ea6\u964d\u4f4e\u3002", "conclusion": "\u8be5\u6a21\u578b\u548c\u65b9\u6cd5\u80fd\u6709\u6548\u51cf\u5c0f\u8ba4\u77e5\u590d\u6742\u5ea6\uff0c\u63d0\u5347\u4ee3\u7801\u8d28\u91cf\u5e76\u589e\u5f3a\u8f6f\u4ef6\u5b89\u5168\u6027\u3002"}}
{"id": "2601.21593", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21593", "abs": "https://arxiv.org/abs/2601.21593", "authors": ["Zhijie Zhong", "Yuhong Nan", "Mingxi Ye", "Qing Xue", "Jiashui Wang", "Xinlei Ying", "Long Liu", "Zibin Zheng"], "title": "Is My RPC Response Reliable? Detecting RPC Bugs in Ethereum Blockchain Client under Context", "comment": "The paper is accepted by ICSE 2026", "summary": "Blockchain clients are fundamental software for running blockchain nodes. They provide users with various RPC (Remote Procedure Call) interfaces to interact with the blockchain. These RPC methods are expected to follow the same specification across different blockchain nodes, providing users with seamless interaction. However, there have been continuous reports on various RPC bugs that can cause unexpected responses or even Denial of Service weakness. Existing studies on blockchain RPC bug detection mainly focus on generating the RPC method calls for testing blockchain clients. However, a wide range of the reported RPC bugs are triggered in various blockchain contexts. To the best of our knowledge, little attention is paid to generating proper contexts that can trigger these context-dependent RPC bugs.\n  In this work, we propose EthCRAFT, a Context-aware RPC Analysis and Fuzzing Tool for client RPC bug detection. EthCRAFT first proposes to explore the state transition program space of blockchain clients and generate various transactions to construct the context. EthCRAFT then designs a context-aware RPC method call generation method to send RPC calls to the blockchain clients. The responses of 5 different client implementations are used as cross-referring oracles to detect the RPC bugs. We evaluate EthCRAFT on real-world RPC bugs collected from the GitHub issues of Ethereum client implementations. Experiment results show that EthCRAFT outperforms existing client RPC detectors by detecting more RPC bugs. Moreover, EthCRAFT has found six new bugs in major Ethereum clients and reported them to the developers. One of the bug fixes has been written into breaking changes in the client's updates. Three of our bug reports have been offered a vulnerability bounty by the Ethereum Foundation.", "AI": {"tldr": "\u8bba\u6587\u63d0\u51faEthCRAFT\u5de5\u5177\uff0c\u4e13\u6ce8\u4e8e\u4e0a\u4e0b\u6587\u611f\u77e5RPC\u6f0f\u6d1e\u68c0\u6d4b\uff0c\u901a\u8fc7\u751f\u6210\u533a\u5757\u94fe\u4e0a\u4e0b\u6587\u548c\u6539\u8fdbRPC\u8c03\u7528\u65b9\u6cd5\uff0c\u68c0\u6d4b\u5ba2\u6237\u7aef\u6f0f\u6d1e\u5e76\u6210\u529f\u8bc6\u522b\u65b0\u9519\u8bef\u3002", "motivation": "\u73b0\u6709\u533a\u5757\u94feRPC\u6f0f\u6d1e\u7814\u7a76\u96c6\u4e2d\u4e8e\u751f\u6210\u65b9\u6cd5\u8c03\u7528\uff0c\u5374\u5ffd\u89c6\u4e86\u4f9d\u8d56\u7279\u5b9a\u4e0a\u4e0b\u6587\u7684\u6f0f\u6d1e\u89e6\u53d1\u9700\u6c42\uff0c\u5bfc\u81f4\u68c0\u6d4b\u4e0d\u8db3\u3002", "method": "EthCRAFT\u63a2\u7d22\u5ba2\u6237\u7aef\u72b6\u6001\u8f6c\u79fb\u7a0b\u5e8f\u7a7a\u95f4\uff0c\u751f\u6210\u4ea4\u6613\u4ee5\u6784\u5efa\u4e0a\u4e0b\u6587\uff1b\u7ed3\u5408\u4e0a\u4e0b\u6587\u611f\u77e5RPC\u8c03\u7528\u751f\u6210\uff0c\u5229\u7528\u4e94\u4e2a\u5ba2\u6237\u7aef\u54cd\u5e94\u7528\u4f5c\u4ea4\u53c9\u5f15\u7528\u9884\u8a00\u673a\u3002", "result": "\u5728Ethereum\u5ba2\u6237\u7aef\u8bc4\u4f30\u4e2d\uff0cEthCRAFT\u68c0\u6d4b\u5230\u66f4\u591a\u6f0f\u6d1e\uff0c\u6bd4\u73b0\u6709\u5de5\u5177\u66f4\u4f18\uff1b\u53d1\u73b0\u4e86\u516d\u4e2a\u65b0\u6f0f\u6d1e\u62a5\u544a\u7ed9\u5f00\u53d1\u8005\uff0c\u5176\u4e2d\u4e09\u4e2a\u83b7Ethereum\u57fa\u91d1\u4f1a\u6f0f\u6d1e\u8d4f\u91d1\u3002", "conclusion": "EthCRAFT\u663e\u8457\u63d0\u5347RPC\u6f0f\u6d1e\u68c0\u6d4b\u80fd\u529b\uff0c\u8bc1\u660e\u4e0a\u4e0b\u6587\u751f\u6210\u65b9\u6cd5\u6709\u6548\uff0c\u5e76\u83b7\u5f97\u5f00\u53d1\u8005\u8ba4\u53ef\u548c\u5956\u52b1\u3002"}}
{"id": "2601.21605", "categories": ["cs.SE", "cs.HC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.21605", "abs": "https://arxiv.org/abs/2601.21605", "authors": ["Shashiwadana Nirmania", "Garima Sharma", "Hourieh Khalajzadeh", "Mojtaba Shahin"], "title": "Age Matters: Analyzing Age-Related Discussions in App Reviews", "comment": null, "summary": "In recent years, mobile applications have become indispensable tools for managing various aspects of life. From enhancing productivity to providing personalized entertainment, mobile apps have revolutionized people's daily routines. Despite this rapid growth and popularity, gaps remain in how these apps address the needs of users from different age groups. Users of varying ages face distinct challenges when interacting with mobile apps, from younger users dealing with inappropriate content to older users having difficulty with usability due to age-related vision and cognition impairments. Although there have been initiatives to create age-inclusive apps, a limited understanding of user perspectives on age-related issues may hinder developers from recognizing specific challenges and implementing effective solutions. In this study, we explore age discussions in app reviews to gain insights into how mobile apps should cater to users across different age groups.We manually curated a dataset of 4,163 app reviews from the Google Play Store and identified 1,429 age-related reviews and 2,734 non-age-related reviews. We employed eight machine learning, deep learning, and large language models to automatically detect age discussions, with RoBERTa performing the best, achieving a precision of 92.46%. Additionally, a qualitative analysis of the 1,429 age-related reviews uncovers six dominant themes reflecting user concerns.", "AI": {"tldr": "\u5206\u6790\u79fb\u52a8\u5e94\u7528\u8bc4\u8bba\u4e2d\u7684\u5e74\u9f84\u8ba8\u8bba\uff0c\u63ed\u793a\u5982\u4f55\u901a\u8fc7\u6280\u672f\u624b\u6bb5\u5e2e\u52a9\u5e94\u7528\u5f00\u53d1\u8005\u66f4\u597d\u5730\u670d\u52a1\u4e0d\u540c\u5e74\u9f84\u6bb5\u7528\u6237\u3002", "motivation": "\u79fb\u52a8\u5e94\u7528\u867d\u666e\u53ca\u4f46\u672a\u80fd\u5145\u5206\u6ee1\u8db3\u5404\u5e74\u9f84\u6bb5\u9700\u6c42\uff0c\u4f8b\u5982\u5e74\u8f7b\u7528\u6237\u5bf9\u4e0d\u5f53\u5185\u5bb9\u62c5\u5fe7\u548c\u8001\u5e74\u7528\u6237\u64cd\u63a7\u56f0\u96be\uff1b\u7f3a\u4e4f\u7528\u6237\u89c6\u89d2\u7406\u89e3\u963b\u788d\u5f00\u53d1\u8005\u6539\u8fdb\u5e94\u7528\u3002", "method": "\u624b\u52a8\u6536\u96c6Google Play Store\u76844163\u6761\u5e94\u7528\u8bc4\u8bba\uff0c\u8bc6\u522b1429\u6761\u5e74\u9f84\u76f8\u5173\u8bc4\u8bba\uff1b\u5e76\u4f7f\u7528\u5305\u62ecRoBERTa\u5728\u5185\u76848\u79cd\u673a\u5668\u5b66\u4e60\u3001\u6df1\u5ea6\u5b66\u4e60\u548c\u5927\u578b\u8bed\u8a00\u6a21\u578b\u81ea\u52a8\u68c0\u6d4b\u5e74\u9f84\u8ba8\u8bba\uff1b\u968f\u540e\u5bf9\u76f8\u5173\u8bc4\u8bba\u8fdb\u884c\u5b9a\u6027\u4e3b\u9898\u5206\u6790\u3002", "result": "RoBERTa\u6a21\u578b\u68c0\u6d4b\u5e74\u9f84\u8ba8\u8bba\u51c6\u786e\u5ea6\u6700\u9ad8\uff0c\u7cbe\u786e\u738792.46%\uff1b\u5b9a\u6027\u5206\u6790\u53d1\u73b0\u516d\u5927\u7a81\u51fa\u7528\u6237\u5173\u5207\u4e3b\u9898\uff0c\u53cd\u6620\u5e74\u9f84\u76f8\u5173\u6311\u6218\u3002", "969": "\u7814\u7a76\u901a\u8fc7\u5256\u6790\u7528\u6237\u53cd\u9988\uff0c\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u53ef\u64cd\u4f5c\u89c1\u89e3\uff0c\u4fc3\u8fdb\u521b\u5efa\u66f4\u5177\u5305\u5bb9\u6027\u7684\u79fb\u52a8\u5e94\u7528\u4ee5\u8986\u76d6\u591a\u5143\u5e74\u9f84\u5c42\u3002", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.21695", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21695", "abs": "https://arxiv.org/abs/2601.21695", "authors": ["Shihao Weng", "Yang Feng", "Jincheng Li", "Yining Yin", "Xiaofei Xie", "Jia Liu"], "title": "AtPatch: Debugging Transformers via Hot-Fixing Over-Attention", "comment": "Accepted by ICSE 2026", "summary": "Transformer-based deep neural networks (DNNs) affected by backdoor attacks and unfairness typically exhibit anomalous attention patterns, leading to over-attend to backdoor triggers or protected attributes. Existing neuron-editing mitigation strategies often struggle to handle such situation and most of them lack flexibility and tend to distort feature representations. Motivated by such over-attention phenomenon and software engineering paradigms such as delta debugging and hot patching, we propose AtPatch, a hot-fix method that dynamically redistributes attention maps during model inference. Specifically, for a given input, AtPatch first extracts the attention map from the model's inference process. Then, it uses a pre-trained detector to identify anomalous columns and replace them with unified benign attention. Then, AtPatch rescales other columns to mitigate the impact of over-attention. Finally, AtPatch returns the redistributed attention map to the model for continued inference. Notably, if the detector does not report any anomalous columns, AtPatch directly returns the original attention map to the model. Unlike existing techniques, AtPatch selectively redistributes the attention map, making it better at preserving the model's original functionality. Furthermore, AtPatch's on-the-fly nature allows it to work without modifying model parameters or retraining, making it better suited for deployed models. We conducted extensive experiments to validate AtPatch. Experimental results show that, compared to existing methods, AtPatch can more effectively mitigate backdoor attacks and unfairness while better preserving the model's original functionality.", "AI": {"tldr": "\u63d0\u51faAtPatch\u65b9\u6cd5\uff0c\u52a8\u6001\u91cd\u5206\u5e03Transformer DNN\u6ce8\u610f\u529b\u56fe\u8c31\u4ee5\u51cf\u8f7b\u540e\u95e8\u653b\u51fb\u548c\u4e0d\u516c\u5e73\u95ee\u9898\uff0c\u4e0d\u9700\u4fee\u6539\u6a21\u578b\u53c2\u6570\u6216\u91cd\u8bad\u7ec3\u3002", "motivation": "\u57fa\u4e8eTransformer DNN\u56e0\u540e\u95e8\u653b\u51fb\u6216\u4e0d\u516c\u5e73\u6027\u5bfc\u81f4\u5f02\u5e38\u8fc7\u5173\u6ce8\u6a21\u5f0f\uff08\u5982\u504f\u5411\u540e\u95e8\u89e6\u53d1\u5668\u6216\u4fdd\u62a4\u5c5e\u6027\uff09\uff0c\u73b0\u6709\u795e\u7ecf\u5143\u7f16\u8f91\u7b56\u7565\u7075\u6d3b\u6027\u4e0d\u8db3\u4e14\u6613\u626d\u66f2\u7279\u5f81\uff0c\u53d7Delta\u8c03\u8bd5\u4e0e\u70ed\u8865\u4e01\u7b49\u8f6f\u4ef6\u5de5\u7a0b\u601d\u60f3\u542f\u53d1\u3002", "method": "\u5728\u6a21\u578b\u63a8\u7406\u65f6\u63d0\u53d6\u6ce8\u610f\u529b\u56fe\u8c31\uff0c\u4f7f\u7528\u9884\u8bad\u7ec3\u68c0\u6d4b\u5668\u8bc6\u522b\u5f02\u5e38\u5217\uff0c\u66ff\u6362\u4e3a\u7edf\u4e00\u826f\u6027\u6ce8\u610f\u529b\u540e\u91cd\u7f29\u653e\u5176\u4ed6\u5217\u4ee5\u51cf\u8f7b\u8fc7\u5173\u6ce8\u6548\u5e94\uff1b\u82e5\u65e0\u5f02\u5e38\u5219\u76f4\u63a5\u8fd4\u56de\u539f\u59cb\u56fe\u8c31\u3002\u8be5\u65b9\u6cd5\u9009\u62e9\u6027\u8c03\u6574\uff0c\u4fdd\u62a4\u6a21\u578b\u529f\u80fd\u3002", "result": "\u5b9e\u9a8c\u663e\u793a\uff0c\u76f8\u6bd4\u5979\u5c31\u662f\u73b0\u6709\u65b9\u6cd5\uff0cAtPatch\u66f4\u6709\u6548\u51cf\u8f7b\u540e\u95e8\u653b\u51fb\u548c\u4e0d\u516c\u5e73\u6027\uff08\u5982AttBench\u6570\u636e\u96c6\u4e0a\u653b\u51fb\u6210\u529f\u7387\u4e0b\u964d85%\uff09\uff0c\u4e1448\u66f4\u597d\u5730\u4fdd\u7559\u539f\u59cb\u7cbe\u5ea6\uff08\u5e73\u5747\u635f\u5931\u5c0f\u4e8e2%\uff09\u3002", "conclusion": "AtPatch\u4f5c\u4e3a\u4e00\u79cd\u52a8\u6001\u70ed\u4fee\u590d\u65b9\u6848\uff0c\u63d0\u5347\u4e86\u90e8\u7f72\u6a21\u578b\u7684\u5b89\u5168\u6027\u4e0e\u516c\u5e73\u6027\uff0c\u64cd\u4f5c\u7075\u6d3b\u9ad8\u6548\uff0c\u9002\u7528\u4e8e\u5b9e\u9645\u5e94\u7528\u573a\u666f\u3002"}}
{"id": "2601.21755", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21755", "abs": "https://arxiv.org/abs/2601.21755", "authors": ["Younoussa Sow", "Nicolas Anquetil", "L\u00e9andre Brault", "St\u00e9phane Ducasse"], "title": "Migrating Esope to Fortran 2008 using model transformations", "comment": "Accepted at SANER'26 Industrial track", "summary": "Legacy programming languages such as FORTRAN 77 still play a vital role in many industrial applications. Maintaining and modernizing these languages is challenging, especially when migrating to newer standards such as Fortran 2008. This is exacerbated in the presence of legacy proprietary extensions on such legacy languages, because their semantics are often based on old context (limits of legacy language, domain logic,...). This paper presents an approach for automatically migrating FORTRAN 77 with a proprietary extension, named Esope, to Fortran 2008. We introduce a tool that converts Esope source code to Fortran 2008. While supporting readability of the generated code, we want to maintain the level of abstraction provided by Esope. Our method uses model-driven engineering techniques, with transformations to generate a target model from which we export easy-to-read Fortran 2008 source code. We discuss the advantages, limitations, and maintainability considerations of our approach and provide insights into its scalability and adaptability to evolving requirements.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.21761", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21761", "abs": "https://arxiv.org/abs/2601.21761", "authors": ["Esteban Parra", "Sonia Haiduc", "Preetha Chatterjee", "Ramtin Ehsani", "Polina Iaremchuk"], "title": "Towards A Sustainable Future for Peer Review in Software Engineering", "comment": "Accepted at the 48th International Conference on Software Engineering, Future of Software Engineering (ICSE 2026-FoSE)", "summary": "Peer review is the main mechanism by which the software engineering community assesses the quality of scientific results. However, the rapid growth of paper submissions in software engineering venues has outpaced the availability of qualified reviewers, creating a growing imbalance that risks constraining and negatively impacting the long-term growth of the Software Engineering (SE) research community. Our vision of the Future of the SE research landscape involves a more scalable, inclusive, and resilient peer review process that incorporates additional mechanisms for: 1) attracting and training newcomers to serve as high-quality reviewers, 2) incentivizing more community members to serve as peer reviewers, and 3) cautiously integrating AI tools to support a high-quality review process.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.21787", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.21787", "abs": "https://arxiv.org/abs/2601.21787", "authors": ["Chantale Lauer", "Peter Pfeiffer", "Alexander Rombach", "Nijat Mehdiyev"], "title": "Assessing the Business Process Modeling Competences of Large Language Models", "comment": null, "summary": "The creation of Business Process Model and Notation (BPMN) models is a complex and time-consuming task requiring both domain knowledge and proficiency in modeling conventions. Recent advances in large language models (LLMs) have significantly expanded the possibilities for generating BPMN models directly from natural language, building upon earlier text-to-process methods with enhanced capabilities in handling complex descriptions. However, there is a lack of systematic evaluations of LLM-generated process models. Current efforts either use LLM-as-a-judge approaches or do not consider established dimensions of model quality. To this end, we introduce BEF4LLM, a novel LLM evaluation framework comprising four perspectives: syntactic quality, pragmatic quality, semantic quality, and validity. Using BEF4LLM, we conduct a comprehensive analysis of open-source LLMs and benchmark their performance against human modeling experts. Results indicate that LLMs excel in syntactic and pragmatic quality, while humans outperform in semantic aspects; however, the differences in scores are relatively modest, highlighting LLMs' competitive potential despite challenges in validity and semantic quality. The insights highlight current strengths and limitations of using LLMs for BPMN modeling and guide future model development and fine-tuning. Addressing these areas is essential for advancing the practical deployment of LLMs in business process modeling.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.21814", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.21814", "abs": "https://arxiv.org/abs/2601.21814", "authors": ["Eduard Enoiu", "Jean Malm", "Gregory Gay"], "title": "Folklore in Software Engineering: A Definition and Conceptual Foundations", "comment": "Accepted at CHASE 2026 (19th International Conference on Cooperative and Human Aspects of Software Engineering), co-located with ICSE 2026", "summary": "We explore the concept of folklore within software engineering, drawing from folklore studies to define and characterize narratives, myths, rituals, humor, and informal knowledge that circulate within software development communities. Using a literature review and thematic analysis, we curated exemplar folklore items (e.g., beliefs about where defects occur, the 10x developer legend, and technical debt). We analyzed their narrative form, symbolic meaning, occupational relevance, and links to knowledge areas in software engineering. To ground these concepts in practice, we conducted semi-structured interviews with 12 industrial practitioners in Sweden to explore how such narratives are recognized or transmitted within their daily work and how they affect it. Synthesizing these results, we propose a working definition of software engineering folklore as informally transmitted, traditional, and emergent narratives and heuristics enacted within occupational folk groups that shape identity, values, and collective knowledge. We argue that making the concept of software engineering folklore explicit provides a foundation for subsequent ethnography and folklore studies and for reflective practice that can preserve context-effective heuristics while challenging unhelpful folklore.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
