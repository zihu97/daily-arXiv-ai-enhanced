<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 8]
- [cs.DC](#cs.DC) [Total: 4]
- [cs.NI](#cs.NI) [Total: 4]
- [cs.MA](#cs.MA) [Total: 1]
- [cs.AR](#cs.AR) [Total: 4]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Modeling Developer Burnout with GenAI Adoption](https://arxiv.org/abs/2510.07435)
*Zixuan Feng,Sadia Afroz,Anita Sarma*

Main category: cs.SE

TL;DR: 本文研究生成式人工智能（GenAI）对开发者职业倦怠的影响，发现GenAI的采用通过增加工作需求加剧倦怠，但工作资源和对GenAI的积极认知可缓解该影响。


<details>
  <summary>Details</summary>
Motivation: 尽管GenAI在提升开发效率方面具有潜力，但其引入也可能带来新的工作压力，进而影响开发者福祉。因此，有必要探究GenAI采用与开发者职业倦怠之间的关系。

Method: 基于工作需求—资源（JD–R）模型，采用嵌入式混合方法设计：对442名开发者进行问卷调查，使用偏最小二乘结构方程模型（PLS-SEM）和回归分析量化工作需求、资源与倦怠的关系，并结合开放式回答的定性分析以丰富解释。

Result: GenAI的采用通过提升工作需求而加剧职业倦怠；然而，充足的工作资源和对GenAI的积极看法能显著缓解这一负面影响。

Conclusion: GenAI的引入是一把双刃剑：虽可能增加压力导致倦怠，但若辅以适当资源支持和正向认知，可转化为积极的发展机遇。

Abstract: Generative AI (GenAI) is rapidly reshaping software development workflows.
While prior studies emphasize productivity gains, the adoption of GenAI also
introduces new pressures that may harm developers' well-being. In this paper,
we investigate the relationship between the adoption of GenAI and developers'
burnout. We utilized the Job Demands--Resources (JD--R) model as the analytic
lens in our empirical study. We employed a concurrent embedded mixed-methods
research design, integrating quantitative and qualitative evidence. We first
surveyed 442 developers across diverse organizations, roles, and levels of
experience. We then employed Partial Least Squares--Structural Equation
Modeling (PLS-SEM) and regression to model the relationships among job demands,
job resources, and burnout, complemented by a qualitative analysis of
open-ended responses to contextualize the quantitative findings. Our results
show that GenAI adoption heightens burnout by increasing job demands, while job
resources and positive perceptions of GenAI mitigate these effects, reframing
adoption as an opportunity.

</details>


### [2] [HotBugs.jar: A Benchmark of Hot Fixes for Time-Critical Bugs](https://arxiv.org/abs/2510.07529)
*Carol Hanna,Federica Sarro,Mark Harman,Justyna Petke*

Main category: cs.SE

TL;DR: 本文提出了 HotBugs$.$jar，这是首个专注于真实世界热修复（hot fixes）的数据集，包含679个经人工验证的热修复案例，其中110个可通过测试套件复现，旨在支持快速调试、自动修复和生产系统韧性等研究。


<details>
  <summary>Details</summary>
Motivation: 现有评估基准缺乏专门针对热修复的研究数据集，而热修复在应对生产系统中的紧急问题方面至关重要，因此亟需一个专门的基准来推动相关研究。

Method: 作者从10个活跃的Apache项目中挖掘了超过19万次提交和15万份问题报告，筛选出746个符合热修复标准的补丁，经人工评估后确认679个为真实热修复，并基于Bugs$.$jar框架整合其中110个可复现案例，提供包含错误/修复版本、测试套件和元数据的标准化数据集。

Result: 构建了HotBugs$.$jar数据集，包含679个经验证的热修复案例，其中110个可复现；该数据集已被SBSE会议挑战赛采纳为官方数据集，展现出实际影响力。

Conclusion: HotBugs$.$jar填补了热修复研究领域缺乏专用基准的空白，为自动化修复、快速调试和软件系统韧性等方向提供了重要支撑，有望推动该领域的进一步发展。

Abstract: Hot fixes are urgent, unplanned changes deployed to production systems to
address time-critical issues. Despite their importance, no existing evaluation
benchmark focuses specifically on hot fixes. We present HotBugs$.$jar, the
first dataset dedicated to real-world hot fixes. From an initial mining of 10
active Apache projects totaling over 190K commits and 150K issue reports, we
identified 746 software patches that met our hot-fix criteria. After manual
evaluation, 679 were confirmed as genuine hot fixes, of which 110 are
reproducible using a test suite. Building upon the Bugs$.$jar framework,
HotBugs$.$jar integrates these 110 reproducible cases and makes available all
679 manually validated hot fixes, each enriched with comprehensive metadata to
support future research. Each hot fix was systematically identified using Jira
issue data, validated by independent reviewers, and packaged in a reproducible
format with buggy and fixed versions, test suites, and metadata. HotBugs$.$jar
has already been adopted as the official challenge dataset for the Search-Based
Software Engineering (SBSE) Conference Challenge Track, demonstrating its
immediate impact. This benchmark enables the study and evaluation of tools for
rapid debugging, automated repair, and production-grade resilience in modern
software systems to drive research in this essential area forward.

</details>


### [3] [RustAssure: Differential Symbolic Testing for LLM-Transpiled C-to-Rust Code](https://arxiv.org/abs/2510.07604)
*Yubo Bai,Tapti Palit*

Main category: cs.SE

TL;DR: RustAssure 利用大语言模型（LLMs）将 C 代码自动转译为内存安全的 Rust 代码，并结合提示工程与差分符号测试，确保生成代码的正确性与语义一致性。


<details>
  <summary>Details</summary>
Motivation: 为使现有用不安全语言（如 C）编写的代码库能够利用 Rust 的内存安全保障，需将其自动转译为 Rust；但 LLM 生成的代码可能存在难以通过传统测试发现的细微错误。

Method: RustAssure 使用大语言模型进行 C 到 Rust 的自动转译，通过提示工程提升生成代码的地道性和安全性，并采用差分符号测试验证 C 与 Rust 代码的语义等价性。

Result: 在五个真实世界应用和库上的评估表明，RustAssure 能为 89.8% 的 C 函数生成可编译的 Rust 函数，其中 69.9% 的函数在 C 和 Rust 版本中产生等价的符号返回值。

Conclusion: RustAssure 有效结合 LLM 与形式化验证技术，显著提升了 C 到 Rust 自动转译的可行性与可靠性，为遗留代码迁移至内存安全语言提供了实用方案。

Abstract: Rust is a memory-safe programming language that significantly improves
software security. Existing codebases written in unsafe memory languages, such
as C, must first be transpiled to Rust to take advantage of Rust's improved
safety guarantees. RustAssure presents a system that uses Large Language Models
(LLMs) to automatically transpile existing C codebases to Rust. RustAssure uses
prompt engineering techniques to maximize the chances of the LLM generating
idiomatic and safe Rust code. Moreover, because LLMs often generate code with
subtle bugs that can be missed under traditional unit or fuzz testing,
RustAssure performs differential symbolic testing to establish the semantic
similarity between the original C and LLM-transpiled Rust code. We evaluated
RustAssure with five real-world applications and libraries, and showed that our
system is able to generate compilable Rust functions for 89.8% of all C
functions, of which 69.9% produced equivalent symbolic return values for both
the C and Rust functions.

</details>


### [4] [AppForge: From Assistant to Independent Developer -- Are GPTs Ready for Software Development?](https://arxiv.org/abs/2510.07740)
*Dezhi Ran,Yuan Cao,Mengzhou Wu,Simin Chen,Yuzhe Guo,Jun Ren,Zihe Song,Hao Yu,Jialei Wei,Linyi Li,Wei Yang,Baishakhi Ray,Tao Xie*

Main category: cs.SE

TL;DR: 本文提出了 APPFORGE，一个包含101个真实Android应用开发任务的新基准，用于评估大语言模型（LLMs）从零开始构建完整软件系统的能力。实验表明，当前最先进的模型（如GPT-5）在此任务上表现不佳，仅能正确实现18.8%的应用，揭示了LLMs在复杂软件工程任务中的根本局限。


<details>
  <summary>Details</summary>
Motivation: 现有基准无法有效评估大语言模型是否具备从自然语言描述出发，构建完整软件系统（如Android应用）的能力，而真实世界软件开发涉及组件交互、状态一致性、生命周期管理等复杂问题，亟需新基准填补这一空白。

Method: 作者构建了APPFORGE基准，包含101个基于真实Android应用的开发任务。通过多智能体系统自动从应用文档中提取功能并生成测试用例，并经Android专家人工验证后，集成到自动化评估框架中，实现无需人工干预的可复现评估。

Result: 在12个主流大语言模型上的评估显示，所有模型表现均较差，性能最佳的GPT-5也仅能生成18.8%功能正确的Android应用。

Conclusion: 当前大语言模型在构建完整、多组件、上下文敏感的软件系统方面存在显著不足，APPFORGE为未来研究提供了可复现、自动化且贴近真实开发场景的评估基准。

Abstract: Large language models (LLMs) have demonstrated remarkable capability in
function-level code generation tasks. Unlike isolated functions, real-world
applications demand reasoning over the entire software system: developers must
orchestrate how different components interact, maintain consistency across
states over time, and ensure the application behaves correctly within the
lifecycle and framework constraints. Yet, no existing benchmark adequately
evaluates whether LLMs can bridge this gap and construct entire software
systems from scratch. To address this gap, we propose APPFORGE, a benchmark
consisting of 101 software development problems drawn from real-world Android
apps. Given a natural language specification detailing the app functionality, a
language model is tasked with implementing the functionality into an Android
app from scratch. Developing an Android app from scratch requires understanding
and coordinating app states, lifecycle management, and asynchronous operations,
calling for LLMs to generate context-aware, robust, and maintainable code. To
construct APPFORGE, we design a multi-agent system to automatically summarize
the main functionalities from app documents and navigate the app to synthesize
test cases validating the functional correctness of app implementation.
Following rigorous manual verification by Android development experts, APPFORGE
incorporates the test cases within an automated evaluation framework that
enables reproducible assessment without human intervention, making it easily
adoptable for future research. Our evaluation on 12 flagship LLMs show that all
evaluated models achieve low effectiveness, with the best-performing model
(GPT-5) developing only 18.8% functionally correct applications, highlighting
fundamental limitations in current models' ability to handle complex,
multi-component software engineering challenges.

</details>


### [5] [Bug Histories as Sources of Compiler Fuzzing Mutators](https://arxiv.org/abs/2510.07834)
*Lingjun Liu,Feiran Qin,Owolabi Legunsen,Marcelo d'Amorim*

Main category: cs.SE

TL;DR: IssueMut 是首个从编译器历史缺陷报告中自动提取变异算子用于编译器模糊测试的方法，实验证明其能有效发现 GCC 和 LLVM 中现有模糊测试工具遗漏的新缺陷。


<details>
  <summary>Details</summary>
Motivation: 编译器作为关键基础设施，其缺陷影响巨大；现有变异模糊测试的效果依赖于变异算子质量，但此前尚无工作利用编译器缺陷历史来生成变异算子。

Method: 提出 IssueMut 方法，通过自动化手段从 GCC 和 LLVM 的缺陷报告中挖掘变异算子，并将其集成到现有的变异型编译器模糊测试工具中。

Result: 从 1760 份缺陷报告中挖掘出 587 个变异算子，在 GCC 和 LLVM 上分别发现了 28 和 37 个新缺陷，其中 60 个已被确认或修复。

Conclusion: 编译器缺陷历史蕴含丰富信息，可有效指导模糊测试，IssueMut 验证了利用历史缺陷生成变异算子的可行性和有效性。

Abstract: Bugs in compilers, which are critical infrastructure today, can have outsized
negative impacts. Mutational fuzzers aid compiler bug detection by
systematically mutating compiler inputs, i.e., programs. Their effectiveness
depends on the quality of the mutators used. Yet, no prior work used compiler
bug histories as a source of mutators. We propose IssueMut, the first approach
for extracting compiler fuzzing mutators from bug histories. Our insight is
that bug reports contain hints about program elements that induced compiler
bugs; they can guide fuzzers towards similar bugs. IssueMut uses an automated
method to mine mutators from bug reports and retrofit such mutators into
existing mutational compiler fuzzers. Using IssueMut, we mine 587 mutators from
1760 GCC and LLVM bug reports. Then, we run IssueMut on these compilers, with
all their test inputs as seed corpora. We find that "bug history" mutators are
effective: they find new bugs that a state-of-the-art mutational compiler
fuzzer misses-28 in GCC and 37 in LLVM. Of these, 60 were confirmed or fixed,
validating our idea that bug histories have rich information that compiler
fuzzers should leverage.

</details>


### [6] [An AUTOSAR-Aligned Architectural Study of Vulnerabilities in Automotive SoC Software](https://arxiv.org/abs/2510.07941)
*Srijita Basu,Haraldsson Bengt,Miroslaw Staron,Christian Berger,Jennifer Horkoff,Magnus Almgren*

Main category: cs.SE

TL;DR: 本文系统分析了180个公开报告的汽车SoC漏洞，将其映射到符合AUTOSAR架构的SoC软件模型中，识别出16类根本原因和56个受影响模块，并揭示了不同CWE类别和架构层中的修复延迟问题，为汽车CPS平台的安全加固提供了可操作的检测、优先级排序与定位策略。


<details>
  <summary>Details</summary>
Motivation: 尽管AUTOSAR标准旨在管理汽车SoC软硬件的复杂性，但集成化的SoC软件架构在实时、安全关键环境中仍面临严峻的安全挑战。近期SoC相关漏洞激增，但缺乏对其根本原因及在AUTOSAR架构中影响的系统性分析。

Method: 作者分析了180个公开披露的汽车SoC漏洞，将其映射到一个符合AUTOSAR分层抽象与面向服务原则的代表性SoC软件架构模型上，识别根本原因与受影响模块，并评估不同CWE类别和架构层中的缓解延迟情况。

Result: 研究识别出16类漏洞根本原因和56个受影响的软件模块，揭示了主导性的漏洞模式以及存在长期修复延迟的关键模块。

Conclusion: 该研究为基于SoC的车辆平台提供了切实可行的安全加固建议，包括改进的漏洞检测、优先级排序和定位策略，有助于提升汽车CPS平台的整体安全性。

Abstract: Cooperative, Connected and Automated Mobility (CCAM) are complex
cyber-physical systems (CPS) that integrate computation, communication, and
control in safety-critical environments. At their core, System-on-Chip (SoC)
platforms consolidate processing units, communication interfaces, AI
accelerators, and security modules into a single chip. AUTOSAR (AUTomotive Open
System ARchitecture) standard was developed in the automotive domain to better
manage this complexity, defining layered software structures and interfaces to
facilitate reuse of HW/SW components. However, in practice, this integrated SoC
software architecture still poses security challenges, particularly in
real-time, safety-critical environments. Recent reports highlight a surge in
SoC-related vulnerabilities, yet systematic analysis of their root causes and
impact within AUTOSAR-aligned architectures is lacking. This study fills that
gap by analyzing 180 publicly reported automotive SoC vulnerabilities, mapped
to a representative SoC software architecture model that is aligned with
AUTOSAR principles for layered abstraction and service orientation. We identify
16 root causes and 56 affected software modules, and examine mitigation delays
across Common Weakness Enumeration (CWE) categories and architectural layers.
We uncover dominant vulnerability patterns and critical modules with prolonged
patch delays, and provide actionable insights for securing automotive CPS
platforms, including guides for improved detection, prioritization, and
localization strategies for SoC software architectures in SoC-based vehicle
platforms.

</details>


### [7] [Past, Present, and Future of Bug Tracking in the Generative AI Era](https://arxiv.org/abs/2510.08005)
*Utku Boran Torun,Mehmet Taha Demircan,Mahmut Furkan Gön,Eray Tüzün*

Main category: cs.SE

TL;DR: 本文提出一个基于大语言模型（LLM）的智能缺陷跟踪框架，通过自动化各阶段流程（如报告优化、复现尝试、分类、修复建议等），减少修复时间和人工负担，提升用户与开发团队间的协作效率。


<details>
  <summary>Details</summary>
Motivation: 传统缺陷跟踪系统依赖人工操作，涉及多个角色之间的协调，沟通成本高、响应慢，且用户常需等待数小时甚至数天才能获得反馈，影响修复效率和用户体验。

Method: 构建一个AI驱动的缺陷跟踪框架，利用大语言模型处理用户以自然语言提交的问题报告，自动优化报告内容、尝试复现问题、补充缺失信息，并对报告进行分类；无效报告通过无代码方式修复，有效报告则定位问题并分配给开发者，同时生成候选补丁供人工审核。

Result: 该框架在缺陷跟踪的每个阶段引入自动化，显著加快响应速度，减少人工干预，提升协作效率和软件维护质量。

Conclusion: 集成LLM的智能缺陷跟踪系统能有效缩短修复周期、降低人力开销，并推动软件维护向更高效、以用户为中心的方向发展。

Abstract: Traditional bug tracking systems rely heavily on manual reporting,
reproduction, triaging, and resolution, each carried out by different
stakeholders such as end users, customer support, developers, and testers. This
division of responsibilities requires significant coordination and widens the
communication gap between non-technical users and technical teams, slowing the
process from bug discovery to resolution. Moreover, current systems are highly
asynchronous; users often wait hours or days for a first response, delaying
fixes and contributing to frustration. This paper examines the evolution of bug
tracking, from early paper-based reporting to today's web-based and SaaS
platforms. Building on this trajectory, we propose an AI-powered bug tracking
framework that augments existing tools with intelligent, large language model
(LLM)-driven automation. Our framework addresses two main challenges: reducing
time-to-fix and minimizing human overhead. Users report issues in natural
language, while AI agents refine reports, attempt reproduction, and request
missing details. Reports are then classified, invalid ones resolved through
no-code fixes, and valid ones localized and assigned to developers. LLMs also
generate candidate patches, with human oversight ensuring correctness. By
integrating automation into each phase, our framework accelerates response
times, improves collaboration, and strengthens software maintenance practices
for a more efficient, user-centric future.

</details>


### [8] [Building Whitespace-Sensitive Languages Using Whitespace-Insensitive Components](https://arxiv.org/abs/2510.08200)
*Alexander Hellwig,Nico Jansen,Bernhard Rumpe*

Main category: cs.SE

TL;DR: 本文提出一种通过预处理语言构件将模块化的空白不敏感语言组件用于构建空白敏感语言的技术，以提升语言组件的复用性。


<details>
  <summary>Details</summary>
Motivation: 当前在软件语言工程中，空白敏感与空白不敏感语言组件之间缺乏统一的集成方法，导致语言库难以复用，常需从头开发空白敏感语言。

Method: 通过在解析前对语言构件进行预处理，利用模块化的空白不敏感语言组件构建空白敏感语言。

Result: 通过重构简化版Python语言验证了该方法的可行性。

Conclusion: 该方法有助于提升现有语言组件的复用性，从而减少开发时间并提高软件语言的整体质量。

Abstract: In Software Language Engineering, there is a trend towards reusability by
composing modular language components. However, this reusability is severely
inhibited by a gap in integrating whitespace-sensitive and
whitespace-insensitive languages. There is currently no consistent procedure
for seamlessly reusing such language components in both cases, such that
libraries often cannot be reused, and whitespacesensitive languages are
developed from scratch. This paper presents a technique for using modular,
whitespaceinsensitive language modules to construct whitespace sensitive
languages by pre-processing language artifacts before parsing. The approach is
evaluated by reconstructing a simplified version of the programming language
Python. Our solution aims to increase the reusability of existing language
components to reduce development time and increase the overall quality of
software languages.

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [9] [Adaptive Execution Scheduler for DataDios SmartDiff](https://arxiv.org/abs/2510.07811)
*Aryan Poduri*

Main category: cs.DC

TL;DR: 本文提出了一种自适应调度器，用于在固定CPU和内存预算下，为具有内存线程和Dask并行两种执行模式的SmartDiff差分引擎动态调整批大小和工作线程数，以最小化p95延迟。该调度器结合预检分析、在线成本/内存模型和带防护的爬山策略，在多个基准测试中显著降低了延迟和峰值内存使用。


<details>
  <summary>Details</summary>
Motivation: 在资源受限（CPU和内存）的环境下，如何为具有多种执行模式的差分引擎动态选择最优执行策略，以在避免内存溢出的同时最小化高百分位延迟（如p95）。

Method: 提出一种自适应调度器，包含：1）轻量级预检分析器估计每行字节数和I/O速率；2）在线成本/内存模型剔除不安全操作；3）带防护的爬山策略优化延迟，并结合背压和慢节点缓解；4）基于保守工作集估计选择后端（内存或Dask）。

Result: 在合成和公开表格基准测试中，相比调优后的预热启发式方法，该调度器将p95延迟降低23-28%，峰值内存降低16-22%；相比固定网格基线，延迟降低35-40%，内存降低25-32%，且无内存溢出，吞吐量相当。

Conclusion: 所提出的自适应调度器能有效在资源约束下自动选择执行模式并调优参数，在显著降低延迟和内存使用的同时保证系统稳定性。

Abstract: We present an adaptive scheduler for a single differencing engine (SmartDiff)
with two execution modes: (i) in-memory threads and (ii) Dask based
parallelism. The scheduler continuously tunes batch size and worker/thread
count within fixed CPU and memory budgets to minimize p95 latency. A
lightweight preflight profiler estimates bytes/row and I/O rate; an online
cost/memory model prunes unsafe actions; and a guarded hill-climb policy favors
lower latency with backpressure and straggler mitigation. Backend selection is
gated by a conservative working-set estimate so that in-memory execution is
chosen when safe, otherwise Dask is used. Across synthetic and public tabular
benchmarks, the scheduler reduces p95 latency by 23 to 28 percent versus a
tuned warm-up heuristic (and by 35 to 40 percent versus fixed grid baselines),
while lowering peak memory by 16 to 22 percent (25 to 32 percent vs. fixed)
with zero OOMs and comparable throughput.

</details>


### [10] [A Multi-Simulation Bridge for IoT Digital Twins](https://arxiv.org/abs/2510.08164)
*Marco Picone,Samuele Burattini,Marco Melloni,Prasad Talasila,Davide Ziglioli,Matteo Martinelli,Nicola Bicocchi,Alessandro Ricci,Peter Gorm Larsen*

Main category: cs.DC

TL;DR: 本文提出了一种名为“数字孪生仿真桥”（DT Simulation Bridge）的软件框架，用于实现数字孪生（DT）与仿真环境之间的双向交互，支持系统设计、验证和实时运行。


<details>
  <summary>Details</summary>
Motivation: 随着物联网（IoT）和工业物联网（IIoT）中数字孪生能力的增强，亟需将其与仿真平台无缝集成，以支持系统设计、验证和实时操作。

Method: 设计并实现了一个支持多种交互模式的软件框架——DT Simulation Bridge，通过双向数据交换机制，使仿真环境能动态更新数字孪生模型，同时数字孪生也能实时反馈以调整仿真参数。

Result: 实验结果表明，该框架提升了设计敏捷性，支持虚拟调试，并能在真实条件下进行实时行为分析，在多种工业场景中展现出有效性。

Conclusion: DT Simulation Bridge 框架有效实现了数字孪生与仿真环境的灵活互操作和可扩展部署，显著增强了工业系统的设计与运行能力。

Abstract: The increasing capabilities of Digital Twins (DTs) in the context of the
Internet of Things (IoT) and Industrial IoT (IIoT) call for seamless
integration with simulation platforms to support system design, validation, and
real-time operation. This paper introduces the concept, design, and
experimental evaluation of the DT Simulation Bridge - a software framework that
enables diverse interaction patterns between active DTs and simulation
environments. The framework supports both the DT development lifecycle and the
incorporation of simulations during active operation. Through bidirectional
data exchange, simulations can update DT models dynamically, while DTs provide
real-time feedback to adapt simulation parameters. We describe the
architectural design and core software components that ensure flexible
interoperability and scalable deployment. Experimental results show that the DT
Simulation Bridge enhances design agility, facilitates virtual commissioning,
and supports live behavioral analysis under realistic conditions, demonstrating
its effectiveness across a range of industrial scenarios.

</details>


### [11] [Towards Energy-Efficient Serverless Computing with Hardware Isolation](https://arxiv.org/abs/2510.08180)
*Natalie Carl,Tobias Pfandzelter,David Bermbach*

Main category: cs.DC

TL;DR: 本文提出通过使用基于硬件隔离的专用处理器替代传统软件隔离机制，重构无服务器计算的硬件架构，从而显著降低能耗，在初步评估中可减少90.63%的能耗开销。


<details>
  <summary>Details</summary>
Motivation: 当前无服务器平台在传统服务器硬件上运行大量租户函数，依赖昂贵的软件隔离和高度资源预留，而现有服务器架构针对大单体工作负载优化，不适合高效运行大量隔离函数，导致能效低下。

Method: 提出一种新的无服务器硬件架构，为每个函数分配独立处理器，利用硬件隔离替代软件隔离，使硬件仅在函数实际执行时消耗能量。

Result: 在真实硬件和典型无服务器工作负载的初步评估中，该方法可将能耗开销降低90.63%，平均节省70.8兆瓦。

Conclusion: 通过将无服务器硬件架构与软件需求对齐，采用硬件隔离和专用处理器，能显著提升能效，验证了该架构在节能方面的巨大潜力。

Abstract: Serverless computing provides just-in-time infrastructure provisioning with
rapid elasticity and a finely-grained pricing model. As full control of
resource allocation is in the hands of the cloud provider and applications only
consume resources when they actually perform work, we believe that serverless
computing is uniquely positioned to maximize energy efficiency.
  However, the focus of current serverless platforms is to run hundreds or
thousands of serverless functions from different tenants on traditional server
hardware, requiring expensive software isolation mechanisms and a high degree
of overprovisioning, i.e., idle servers, to anticipate load spikes. With shared
caches, high clock frequencies, and many-core architectures, servers today are
optimized for large, singular workloads but not to run thousands of isolated
functions.
  We propose rethinking the serverless hardware architecture to align it with
the requirements of serverless software. Specifically, we propose using
hardware isolation with individual processors per function instead of software
isolation resulting in a serverless hardware stack that consumes energy only
when an application actually performs work. In preliminary evaluation with real
hardware and a typical serverless workload we find that this could reduce
energy consumption overheads by 90.63% or an average 70.8MW.

</details>


### [12] [Investigating Matrix Repartitioning to Address the Over- and Undersubscription Challenge for a GPU-based CFD Solver](https://arxiv.org/abs/2510.08536)
*Gregor Olenik,Marcel Koch,Hartwig Anzt*

Main category: cs.DC

TL;DR: 本文提出一种针对OpenFOAM中插件式GPU加速的矩阵重划分策略，通过优化CPU组装与GPU求解之间的负载平衡，显著提升异构环境下的求解器性能与资源利用率。


<details>
  <summary>Details</summary>
Motivation: 现有OpenFOAM中GPU加速方法在完全重构代码和插件式GPU求解器之间存在性能与开发成本的权衡，而插件式方法常因负载不均导致GPU过载或资源浪费。

Method: 提出一种新的矩阵重划分与更新流程，结合计算模型对CPU矩阵组装和GPU线性求解进行更合理的任务分配。

Result: 在大规模CFD模拟中验证了该方法能有效缓解GPU过载问题，显著提升求解器性能和异构系统资源利用率。

Conclusion: 所提出的重划分策略有效优化了OpenFOAM在CPU-GPU异构架构下的计算负载分配，为插件式GPU加速提供了高效且低侵入性的解决方案。

Abstract: Modern high-performance computing (HPC) increasingly relies on GPUs, but
integrating GPU acceleration into complex scientific frameworks like OpenFOAM
remains a challenge. Existing approaches either fully refactor the codebase or
use plugin-based GPU solvers, each facing trade-offs between performance and
development effort. In this work, we address the limitations of plugin-based
GPU acceleration in OpenFOAM by proposing a repartitioning strategy that better
balances CPU matrix assembly and GPU-based linear solves. We present a detailed
computational model, describe a novel matrix repartitioning and update
procedure, and evaluate its performance on large-scale CFD simulations. Our
results show that the proposed method significantly mitigates oversubscription
issues, improving solver performance and resource utilization in heterogeneous
CPU-GPU environments.

</details>


<div id='cs.NI'></div>

# cs.NI [[Back]](#toc)

### [13] [DRACO: Data Replication and Collection Framework for Enhanced Data Availability and Robustness in IoT Networks](https://arxiv.org/abs/2510.07464)
*Waleed Bin Qaim,Oznur Ozkasap,Rabia Qadar,Moncef Gabbouj*

Main category: cs.NI

TL;DR: 本文提出了DRACO框架，通过分布式逐跳数据复制与无开销的移动汇聚节点策略，有效提升物联网中数据的可用性、副本放置效率和收集性能。


<details>
  <summary>Details</summary>
Motivation: 物联网设备资源受限且不可靠，导致数据生成、收集与管理面临挑战，尤其容易发生数据丢失，亟需一种高效、可靠的数据管理机制。

Method: DRACO结合了分布式逐跳数据复制方法与无开销的移动汇聚节点数据收集策略，优化副本放置并提升数据检索效率。

Result: ns-3仿真表明，相比贪婪和随机复制方法，DRACO在数据可用性上分别提升最多15%和34%，副本创建效率提升最多18%和40%；在不同节点密度和故障场景下，其数据收集效率优于随机游走等传统移动策略。

Conclusion: DRACO为物联网数据管理提供了可扩展且具有弹性的解决方案，适用于新兴应用场景。

Abstract: The Internet of Things (IoT) bridges the gap between the physical and digital
worlds, enabling seamless interaction with real-world objects via the Internet.
However, IoT systems face significant challenges in ensuring efficient data
generation, collection, and management, particularly due to the
resource-constrained and unreliable nature of connected devices, which can lead
to data loss. This paper presents DRACO (Data Replication and Collection), a
framework that integrates a distributed hop-by-hop data replication approach
with an overhead-free mobile sink-based data collection strategy. DRACO
enhances data availability, optimizes replica placement, and ensures efficient
data retrieval even under node failures and varying network densities.
Extensive ns-3 simulations demonstrate that DRACO outperforms state-of-the-art
techniques, improving data availability by up to 15% and 34%, and replica
creation by up to 18% and 40%, compared to greedy and random replication
techniques, respectively. DRACO also ensures efficient data dissemination
through optimized replica distribution and achieves superior data collection
efficiency under varying node densities and failure scenarios as compared to
commonly used uncontrolled sink mobility approaches namely random walk and
self-avoiding random walk. By addressing key IoT data management challenges,
DRACO offers a scalable and resilient solution well-suited for emerging use
cases.

</details>


### [14] [TDoA-Based Self-Supervised Channel Charting with NLoS Mitigation](https://arxiv.org/abs/2510.08001)
*Mohsen Ahadi,Omid Esrafilian,Florian Kaltenberger,Adeel Malik*

Main category: cs.NI

TL;DR: 本文提出了一种结合信道脉冲响应（CIR）、到达时间差（TDoA）和传输接收点（TRP）位置等实用特征的新型信道绘图（Channel Charting, CC）方法，通过自监督方式实现全球尺度的无线定位，并利用用户设备（UE）短时位移信息增强定位函数的连续性和鲁棒性。该方法还引入了识别并屏蔽非直视路径（NLoS）噪声的机制，在真实5G测试平台上的实验表明，其在多种NLoS条件下90%的定位误差为2-4米，优于当前最先进的半监督和自监督CC方法。


<details>
  <summary>Details</summary>
Motivation: 现有信道绘图方法在全球扩展性和非直视路径（NLoS）引起的失真处理方面存在不足，限制了其在实际无线定位中的性能和适用性。

Method: 提出一种基于CIR数据并融合TDoA、TRP位置等实用特征的自监督信道绘图框架，结合UE短时位移测量提升定位函数的连续性，并设计NLoS噪声识别与屏蔽机制。

Result: 在基于OpenAirInterface的真实5G O-RAN测试平台上，以厘米级RTK定位为基准进行评估，所提方法在多种NLoS比例下90%的定位精度达到2-4米，优于现有半监督和自监督CC方法。

Conclusion: 该方法有效提升了信道绘图在全球尺度和复杂NLoS环境下的定位性能，具有良好的实用性和鲁棒性，并公开了相关CIR数据集及真实位置标签以促进后续研究。

Abstract: Channel Charting (CC) has emerged as a promising framework for data-driven
radio localization, yet existing approaches often struggle to scale globally
and to handle the distortions introduced by non-line-of-sight (NLoS)
conditions. In this work, we propose a novel CC method that leverages Channel
Impulse Response (CIR) data enriched with practical features such as Time
Difference of Arrival (TDoA) and Transmission Reception Point (TRP) locations,
enabling a self-supervised localization function on a global scale. The
proposed framework is further enhanced with short-interval User Equipment (UE)
displacement measurements, which improve the continuity and robustness of the
learned positioning function. Our algorithm incorporates a mechanism to
identify and mask NLoS-induced noisy measurements, leading to significant
performance gains. We present the evaluations of our proposed models in a real
5G testbed and benchmarked against centimeter-accurate Real-Time Kinematic
(RTK) positioning, in an O-RAN--based 5G network by OpenAirInterface (OAI)
software at EURECOM. It demonstrated outperforming results against the
state-of-the-art semi-supervised and self-supervised CC approaches in a
real-world scenario. The results show localization accuracies of 2-4 meters in
90% of cases, across a range of NLoS ratios. Furthermore, we provide public
datasets of CIR recordings, along with the true position labels used in this
paper's evaluation.

</details>


### [15] [When Light Bends to the Collective Will: A Theory and Vision for Adaptive Photonic Scale-up Domains](https://arxiv.org/abs/2510.08072)
*Vamsi Addanki*

Main category: cs.NI

TL;DR: 本文提出一个理论框架，用于分析可重构光互连在集体通信中的性能权衡，揭示重配置延迟与自适应拓扑性能增益之间的关系，并建立Birkhoff–von Neumann分解、最大并发流与集体通信α-β成本模型之间的联系。


<details>
  <summary>Details</summary>
Motivation: 随着芯片间硅光子技术因其带宽和能效优势而受到关注，集体通信成为扩展系统中的关键瓶颈。可编程光互连通过动态重构互连结构，有望为集体操作（如AllReduce）提供同步、高带宽的直连光路，但需解决重配置延迟与性能增益之间的基本权衡问题。

Method: 作者构建了一个简洁的理论框架，明确刻画自适应光互连域中重配置延迟与性能收益之间的权衡，并利用Birkhoff–von Neumann分解、最大并发流理论以及经典的α-β集体通信成本模型进行分析。

Result: 该框架清晰地阐明了在何种条件下进行光互连重配置是值得的，并揭示了BvN分解、最大并发流与α-β模型之间的内在联系。

Conclusion: 本文为面向集体通信的自适应光互连系统提供了理论基础，并提出了未来在算法设计与系统集成方面的研究方向。

Abstract: As chip-to-chip silicon photonics gain traction for their bandwidth and
energy efficiency, collective communication has emerged as a critical
bottleneck in scale-up systems. Programmable photonic interconnects offer a
promising path forward: by dynamically reconfiguring the fabric, they can
establish direct, high-bandwidth optical paths between communicating endpoints
-- \emph{synchronously and guided by the structure of collective operations}
(e.g., AllReduce). However, realizing this vision -- \emph{when light bends to
the collective will} -- requires navigating a fundamental trade-off between
reconfiguration delay and the performance gains of adaptive topologies.
  In this paper, we present a simple theoretical framework for adaptive
photonic scale-up domains that makes this trade-off explicit and clarifies when
reconfiguration is worthwhile. Along the way, we highlight a connection -- not
surprising but still powerful -- between the Birkhoff--von Neumann (BvN)
decomposition, maximum concurrent flow (a classic measure of network
throughput), and the well-known $\alpha$-$\beta$ cost model for collectives.
Finally, we outline a research agenda in algorithm design and systems
integration that can build on this foundation.

</details>


### [16] [BlockSDN: Towards a High-Performance Blockchain via Software-Defined Cross Networking optimization](https://arxiv.org/abs/2510.08139)
*Wenyang Jia,Jingjing Wang,Ziwei Yan,Xiangli Peng,Guohui Yuan*

Main category: cs.NI

TL;DR: BlockSDN is a novel SDN-based architecture that improves blockchain scalability by integrating physical network awareness into block broadcasting, achieving up to 65% faster synchronization than existing protocols.


<details>
  <summary>Details</summary>
Motivation: Existing blockchain systems suffer from scalability issues due to inefficient P2P broadcasting that ignores physical network conditions; most optimizations are limited to the logical layer.

Method: BlockSDN introduces an SDN-based integrated architecture featuring a distributed control plane for global network visibility, a graph engine for hierarchical clustering, and a hybrid macro-micro neighbor selection strategy with hierarchical broadcasting.

Result: Simulations demonstrate that BlockSDN reduces global block synchronization time by 65% compared to Gossip and by 55% compared to Mercury.

Conclusion: SDN-enabled cross-layer coordination can significantly enhance blockchain scalability and performance by aligning logical broadcast strategies with physical network topology.

Abstract: The scalability of blockchain systems is constrained by inefficient P2P
broadcasting, as most existing optimizations focus only on the logical layer
without considering physical network conditions. To address this, we propose
BlockSDN, the first SDN-based integrated architecture for blockchain. BlockSDN
employs a distributed control plane for a global network view, a graph engine
for hierarchical clustering, and a hybrid macro-micro neighbor selection with
hierarchical broadcasting. A dedicated simulation platform shows that BlockSDN
reduces global block synchronization time by 65% and 55% compared to Gossip and
Mercury, respectively.These results highlight the potential of SDN-enabled
cross-layer coordination to significantly enhance blockchain scalability and
performance.

</details>


<div id='cs.MA'></div>

# cs.MA [[Back]](#toc)

### [17] [Network Topology and Information Efficiency of Multi-Agent Systems: Study based on MARL](https://arxiv.org/abs/2510.07888)
*Xinren Zhang,Sixi Cheng,Zixin Zhong,Jiadong Yu*

Main category: cs.MA

TL;DR: 该论文研究多智能体系统中通信拓扑结构与信息效率对协作性能的影响，提出定向与顺序拓扑可提升性能并降低通信开销，并引入IEI和SEI两个指标优化训练目标，从而提高成功率与收敛速度。


<details>
  <summary>Details</summary>
Motivation: 多智能体强化学习面临非平稳性和部分可观测性挑战，尽管通信可缓解这些问题，但其最优结构与评估方式尚不明确，尤其在通信拓扑和信息效率方面缺乏深入研究。

Method: 分析不同通信拓扑（如定向和顺序结构）对多智能体任务性能的影响，并提出信息熵效率指数（IEI）和专业化效率指数（SEI）作为评估消息紧凑性与角色分化的指标，将其融入训练目标以优化学习过程。

Result: 定向和顺序通信拓扑在同构与异构任务中均能提升性能并减少通信开销；引入IEI和SEI指标后，系统成功率和收敛速度显著提高。

Conclusion: 设计具有自适应通信拓扑和信息高效消息机制的多智能体系统，对实现复杂任务中的高效协作至关重要。

Abstract: Multi-agent systems (MAS) solve complex problems through coordinated
autonomous entities with individual decision-making capabilities. While
Multi-Agent Reinforcement Learning (MARL) enables these agents to learn
intelligent strategies, it faces challenges of non-stationarity and partial
observability. Communications among agents offer a solution, but questions
remain about its optimal structure and evaluation. This paper explores two
underexamined aspects: communication topology and information efficiency. We
demonstrate that directed and sequential topologies improve performance while
reducing communication overhead across both homogeneous and heterogeneous
tasks. Additionally, we introduce two metrics -- Information Entropy Efficiency
Index (IEI) and Specialization Efficiency Index (SEI) -- to evaluate message
compactness and role differentiation. Incorporating these metrics into training
objectives improves success rates and convergence speed. Our findings highlight
that designing adaptive communication topologies with information-efficient
messaging is essential for effective coordination in complex MAS.

</details>


<div id='cs.AR'></div>

# cs.AR [[Back]](#toc)

### [18] [How long can you sleep? Idle Time System Inefficiencies and Opportunities](https://arxiv.org/abs/2510.07449)
*Georgia Antoniou,Haris Volos,Jawad Haj Yahya,Yiannakis Sazeides*

Main category: cs.AR

TL;DR: 本文提出一种基于排队模型的框架，用于揭示运行延迟敏感型应用的现代服务器在CPU核心和系统层级上未被利用的空闲机会，并指出当前空闲管理机制的不足。


<details>
  <summary>Details</summary>
Motivation: 现代服务器在运行延迟关键型应用时存在大量未被利用的深度空闲状态机会，主要受限于空闲调控器的不准确性和传统深度空闲状态转换延迟过高。

Method: 采用三种排队模型（M/M/1、cxM/M/1 和 M/M/c）来估计CPU核心和系统层级的理论空闲时间分布，并将其与真实服务器的实际空闲情况进行对比分析。

Result: 理论模型与实际测量结果对比显示，服务器错过了大量进入深度空闲状态的机会。

Conclusion: 所提出的建模方法可用于服务器系统早期设计阶段的探索，为不同配置和负载下的空闲行为提供深入洞察，并指导能效优化。

Abstract: This work introduces a model-based framework that reveals the idle
opportunity of modern servers running latency-critical applications.
Specifically, three queuing models, M/M/1, cxM/M/1, and M/M/c, are used to
estimate the theoretical idle time distribution at the CPU core and system
(package) level. A comparison of the actual idleness of a real server and that
from the theoretical models reveals significant missed opportunities to enter
deep idle states. This inefficiency is attributed to the idle-governor
inaccuracy and the high latency to transition to/from legacy deep-idle states.
The proposed methodology offers the means for an early-stage design exploration
and insights into idle time behavior and opportunities for varying server
system configurations and load.

</details>


### [19] [DL-PIM: Improving Data Locality in Processing-in-Memory Systems](https://arxiv.org/abs/2510.07719)
*Parker Hao Tian,Zahra Yousefijamarani,Alaa Alameldeen*

Main category: cs.AR

TL;DR: 本文提出DL-PIM架构，通过动态检测数据迁移开销并主动将数据移至处理单元本地内存，结合自适应地址重定向机制，在HMC和HBM上分别平均降低54%和50%的内存请求延迟，提升系统性能。


<details>
  <summary>Details</summary>
Motivation: 现有PIM架构虽能提升能效与性能，但远程内存访问引发的数据迁移和排队延迟严重削弱其优势，亟需提升数据局部性以减少开销。

Method: 提出DL-PIM架构：1）动态检测数据迁移开销，主动迁移数据至请求处理单元的本地保留内存区；2）采用分布式地址间接硬件查找表重定向访问；3）设计自适应机制，根据间接访问的代价与收益动态启停该机制。

Result: 在HMC和HBM上，DL-PIM分别将平均内存请求延迟降低54%和50%；对高数据复用负载，性能提升15%（HMC）和5%（HBM）；所有代表性负载平均提速6%（HMC）和3%（HBM）。

Conclusion: DL-PIM通过增强数据局部性有效缓解PIM架构中远程访问带来的延迟问题，在多种3D堆叠内存中实现显著性能提升，且自适应机制避免了对不利负载的负面影响。

Abstract: PIM architectures aim to reduce data transfer costs between processors and
memory by integrating processing units within memory layers. Prior PIM
architectures have shown potential to improve energy efficiency and
performance. However, such advantages rely on data proximity to the processing
units performing computations. Data movement overheads can degrade PIM's
performance and energy efficiency due to the need to move data between a
processing unit and a distant memory location. %they face challenges due to the
overhead of transferring data from remote memory locations to processing units
inside memory for computation. In this paper, we demonstrate that a large
fraction of PIM's latency per memory request is attributed to data transfers
and queuing delays from remote memory accesses. To improve PIM's data locality,
we propose DL-PIM, a novel architecture that dynamically detects the overhead
of data movement, and proactively moves data to a reserved area in the local
memory of the requesting processing unit. DL-PIM uses a distributed
address-indirection hardware lookup table to redirect traffic to the current
data location. We propose DL-PIM implementations on two 3D stacked memories:
HMC and HBM. While some workloads benefit from DL-PIM, others are negatively
impacted by the additional latency due to indirection accesses. Therefore, we
propose an adaptive mechanism that assesses the cost and benefit of indirection
and dynamically enables or disables it to prevent degrading workloads that
suffer from indirection. Overall, DL-PIM reduces the average memory latency per
request by 54% in HMC and 50% in HBM which resulted in performance improvement
of 15% for workloads with substantial data reuse in HMC and 5% in HBM. For all
representative workloads, DL-PIM achieved a 6% speedup in HMC and a 3% speedup
in HBM, showing that DL-PIM enhances data locality and overall system
performance.

</details>


### [20] [FMCache: File-System Metadata Caching in Programmable Switches](https://arxiv.org/abs/2510.08351)
*Qingxiu Liu,Jiazhen Cai,Siyuan Sheng,Yuhui Chen,Lu Tang,Zhirong Shen,Patrick P. C. Lee*

Main category: cs.AR

TL;DR: FMCache 是一种基于可编程交换机的文件系统元数据缓存框架，通过在交换机数据平面直接处理元数据请求，显著提升吞吐量并降低延迟和资源开销。


<details>
  <summary>Details</summary>
Motivation: 分布式文件系统在面对大量文件和目录时，需要高效且可扩展的跨多台元数据服务器的管理机制。客户端缓存虽可减轻服务器负载，但在客户端数量增加时会带来高昂的一致性维护开销和复杂性。

Method: 提出 FMCache 框架，利用可编程交换机在数据平面直接响应多个客户端的文件系统元数据请求，并针对文件系统特有的路径依赖问题在严格的交换机资源限制下进行优化。

Result: 在 Hadoop HDFS 上实现并在 Tofino 交换机测试平台上评估，FMCache 相比原生 HDFS 吞吐量最高提升 181.6%，与客户端缓存结合可额外提升最多 139.6% 的吞吐量，同时保持低延迟和有限的交换机资源占用。

Conclusion: FMCache 有效解决了分布式文件系统中元数据管理的可扩展性和一致性难题，在提升性能的同时兼顾资源效率，为未来高性能存储系统提供了新思路。

Abstract: Fast and scalable metadata management across multiple metadata servers is
crucial for distributed file systems to handle numerous files and directories.
Client-side caching of frequently accessed metadata can mitigate server loads,
but incurs significant overhead and complexity in maintaining cache consistency
when the number of clients increases. We propose FMCache, an in-switch
file-system metadata caching framework that leverages programmable switches to
serve file-system metadata requests from multiple clients directly in the
switch data plane. Unlike prior in-switch key-value caching approaches, FMCache
addresses file-system-specific path dependencies under stringent switch
resource constraints. We implement FMCache atop Hadoop HDFS and evaluate it on
a Tofino-switch testbed using real-world file-system metadata workloads.
FMCache achieves up to 181.6% higher throughput than vanilla HDFS and
complements client-side caching with additional throughput gains of up to
139.6%. It also incurs low latencies and limited switch resource usage.

</details>


### [21] [SPAD: Specialized Prefill and Decode Hardware for Disaggregated LLM Inference](https://arxiv.org/abs/2510.08544)
*Hengrui Zhang,Pratyush Patel,August Ning,David Wentzlaff*

Main category: cs.AR

TL;DR: 本文提出SPAD架构，通过为大语言模型推理的prefill和decode阶段分别设计专用硬件芯片，在保持性能的同时显著降低硬件成本和功耗。


<details>
  <summary>Details</summary>
Motivation: 现有数据中心GPU和TPU采用“越多越好”的设计理念，导致在LLM推理的prefill阶段内存带宽利用率低，decode阶段计算资源利用率低，从而增加服务成本。

Method: 提出SPAD（Specialized Prefill and Decode hardware）架构，采用“少即是多”的方法：Prefill芯片配备更大的脉动阵列和成本较低的GDDR内存，Decode芯片保留高内存带宽但减少计算能力。

Result: 与模拟的H100相比，Prefill芯片平均提升8%性能且硬件成本降低52%，Decode芯片达到97%性能但TDP降低28%；端到端仿真显示SPAD在相同性能下可降低19%-41%硬件成本和2%-17% TDP。

Conclusion: SPAD通过针对LLM推理不同阶段特性定制硬件，显著提升资源利用率并降低成本和功耗，且在模型和负载变化时仍具良好适应性和长期有效性。

Abstract: Large Language Models (LLMs) have gained popularity in recent years, driving
up the demand for inference. LLM inference is composed of two phases with
distinct characteristics: a compute-bound prefill phase followed by a
memory-bound decode phase. To efficiently serve LLMs, prior work proposes
prefill-decode disaggregation to run each phase on separate hardware. However,
existing hardware poorly matches the different requirements of each phase.
Current datacenter GPUs and TPUs follow a more-is-better design philosophy that
maximizes compute and memory resources, causing memory bandwidth
underutilization in the prefill phase and compute underutilization in the
decode phase. Such underutilization directly translates into increased serving
costs.
  This paper proposes SPAD (Specialized Prefill and Decode hardware), adopting
a less-is-more methodology to design specialized chips tailored to the distinct
characteristics of prefill and decode phases. The proposed Prefill Chips have
larger systolic arrays and use cost-effective GDDR memory, whereas the proposed
Decode Chips retain high memory bandwidth but reduce compute capacity. Compared
to modeled H100s, simulations show that the proposed Prefill Chips deliver 8%
higher prefill performance on average at 52% lower hardware cost, while the
proposed Decode Chips achieve 97% of the decode performance with 28% lower TDP.
  End-to-end simulations on production traces show that SPAD reduces hardware
cost by 19%-41% and TDP by 2%-17% compared to modeled baseline clusters while
offering the same performance. Even when models and workloads change, SPAD can
reallocate either type of chip to run either phase and still achieve 11%-43%
lower hardware costs, demonstrating the longevity of the SPAD design.

</details>
