{"id": "2510.01285", "categories": ["cs.MA", "cs.AI", "cs.CL", "cs.IR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.01285", "abs": "https://arxiv.org/abs/2510.01285", "authors": ["Alireza Salemi", "Mihir Parmar", "Palash Goyal", "Yiwen Song", "Jinsung Yoon", "Hamed Zamani", "Hamid Palangi", "Tomas Pfister"], "title": "LLM-based Multi-Agent Blackboard System for Information Discovery in Data Science", "comment": null, "summary": "The rapid advancement of Large Language Models (LLMs) has opened new\nopportunities in data science, yet their practical deployment is often\nconstrained by the challenge of discovering relevant data within large\nheterogeneous data lakes. Existing methods struggle with this: single-agent\nsystems are quickly overwhelmed by large, heterogeneous files in the large data\nlakes, while multi-agent systems designed based on a master-slave paradigm\ndepend on a rigid central controller for task allocation that requires precise\nknowledge of each sub-agent's capabilities. To address these limitations, we\npropose a novel multi-agent communication paradigm inspired by the blackboard\narchitecture for traditional AI models. In this framework, a central agent\nposts requests to a shared blackboard, and autonomous subordinate agents --\neither responsible for a partition of the data lake or general information\nretrieval -- volunteer to respond based on their capabilities. This design\nimproves scalability and flexibility by eliminating the need for a central\ncoordinator to have prior knowledge of all sub-agents' expertise. We evaluate\nour method on three benchmarks that require explicit data discovery: KramaBench\nand modified versions of DS-Bench and DA-Code to incorporate data discovery.\nExperimental results demonstrate that the blackboard architecture substantially\noutperforms baselines, including RAG and the master-slave multi-agent paradigm,\nachieving between 13% to 57% relative improvement in end-to-end task success\nand up to a 9% relative gain in F1 score for data discovery over the\nbest-performing baselines across both proprietary and open-source LLMs. Our\nfindings establish the blackboard paradigm as a scalable and generalizable\ncommunication framework for multi-agent systems."}
{"id": "2510.01297", "categories": ["cs.MA"], "pdf": "https://arxiv.org/pdf/2510.01297", "abs": "https://arxiv.org/abs/2510.01297", "authors": ["Yeqi Feng", "Yucheng Lu", "Hongyu Su", "Tianxing He"], "title": "SimCity: Multi-Agent Urban Development Simulation with Rich Interactions", "comment": "32 pages, 8 figures", "summary": "Large Language Models (LLMs) open new possibilities for constructing\nrealistic and interpretable macroeconomic simulations. We present SimCity, a\nmulti-agent framework that leverages LLMs to model an interpretable\nmacroeconomic system with heterogeneous agents and rich interactions. Unlike\nclassical equilibrium models that limit heterogeneity for tractability, or\ntraditional agent-based models (ABMs) that rely on hand-crafted decision rules,\nSimCity enables flexible, adaptive behavior with transparent natural-language\nreasoning. Within SimCity, four core agent types (households, firms, a central\nbank, and a government) deliberate and participate in a frictional labor\nmarket, a heterogeneous goods market, and a financial market. Furthermore, a\nVision-Language Model (VLM) determines the geographic placement of new firms\nand renders a mapped virtual city, allowing us to study both macroeconomic\nregularities and urban expansion dynamics within a unified environment. To\nevaluate the framework, we compile a checklist of canonical macroeconomic\nphenomena, including price elasticity of demand, Engel's Law, Okun's Law, the\nPhillips Curve, and the Beveridge Curve, and show that SimCity naturally\nreproduces these empirical patterns while remaining robust across simulation\nruns."}
{"id": "2510.02185", "categories": ["cs.SE", "cs.CR", "cs.MA", "D.2.4; F.3.1"], "pdf": "https://arxiv.org/pdf/2510.02185", "abs": "https://arxiv.org/abs/2510.02185", "authors": ["Paschal C. Amusuo", "Dongge Liu", "Ricardo Andres Calvo Mendez", "Jonathan Metzman", "Oliver Chang", "James C. Davis"], "title": "FalseCrashReducer: Mitigating False Positive Crashes in OSS-Fuzz-Gen Using Agentic AI", "comment": "12 pages, 2 figures", "summary": "Fuzz testing has become a cornerstone technique for identifying software bugs\nand security vulnerabilities, with broad adoption in both industry and\nopen-source communities. Directly fuzzing a function requires fuzz drivers,\nwhich translate random fuzzer inputs into valid arguments for the target\nfunction. Given the cost and expertise required to manually develop fuzz\ndrivers, methods exist that leverage program analysis and Large Language Models\nto automatically generate these drivers. However, the generated fuzz drivers\nfrequently lead to false positive crashes, especially in functions highly\nstructured input and complex state requirements. This problem is especially\ncrucial in industry-scale fuzz driver generation efforts like OSS-Fuzz-en, as\nreporting false positive crashes to maintainers impede trust in both the system\nand the team.\n  This paper presents two AI-driven strategies to reduce false positives in\nOSS-Fuzz-Gen, a multi-agent system for automated fuzz driver generation. First,\nconstraint-based fuzz driver generation proactively enforces constraints on a\nfunction's inputs and state to guide driver creation. Second, context-based\ncrash validation reactively analyzes function callers to determine whether\nreported crashes are feasible from program entry points. Using 1,500 benchmark\nfunctions from OSS-Fuzz, we show that these strategies reduce spurious crashes\nby up to 8%, cut reported crashes by more than half, and demonstrate that\nfrontier LLMs can serve as reliable program analysis agents. Our results\nhighlight the promise and challenges of integrating AI into large-scale fuzzing\npipelines."}
{"id": "2510.01379", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01379", "abs": "https://arxiv.org/abs/2510.01379", "authors": ["Huashan Chen", "Zhenyu Qi", "Haotang Li", "Hong Chen", "Jinfu Chen", "Kebin Peng", "In Kee Kim", "Kyu Hyung Lee", "Sen He"], "title": "Beyond Single LLMs: Enhanced Code Generation via Multi-Stage Performance-Guided LLM Orchestration", "comment": null, "summary": "While Large Language Models (LLMs) have become the predominant paradigm for\nautomated code generation, current single-model approaches fundamentally ignore\nthe heterogeneous computational strengths that different models exhibit across\nprogramming languages, algorithmic domains, and development stages. This paper\nchallenges the single-model convention by introducing a multi-stage,\nperformance-guided orchestration framework that dynamically routes coding tasks\nto the most suitable LLMs within a structured generate-fix-refine workflow. Our\napproach is grounded in a comprehensive empirical study of 17 state-of-the-art\nLLMs across five programming languages (Python, Java, C++, Go, and Rust) using\nHumanEval-X benchmark. The study, which evaluates both functional correctness\nand runtime performance metrics (execution time, mean/max memory utilization,\nand CPU efficiency), reveals pronounced performance heterogeneity by language,\ndevelopment stage, and problem category. Guided by these empirical insights, we\npresent PerfOrch, an LLM agent that orchestrates top-performing LLMs for each\ntask context through stage-wise validation and rollback mechanisms. Without\nrequiring model fine-tuning, PerfOrch achieves substantial improvements over\nstrong single-model baselines: average correctness rates of 96.22% and 91.37%\non HumanEval-X and EffiBench-X respectively, surpassing GPT-4o's 78.66% and\n49.11%. Beyond correctness gains, the framework delivers consistent performance\noptimizations, improving execution time for 58.76% of problems with median\nspeedups ranging from 17.67% to 27.66% across languages on two benchmarks. The\nframework's plug-and-play architecture ensures practical scalability, allowing\nnew LLMs to be profiled and integrated seamlessly, thereby offering a paradigm\nfor production-grade automated software engineering that adapts to the rapidly\nevolving generative AI landscape."}
{"id": "2510.01730", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.01730", "abs": "https://arxiv.org/abs/2510.01730", "authors": ["Ashiyana Abdul Majeed", "Mahmoud Meribout", "Safa Mohammed Sali"], "title": "Edge GPU Aware Multiple AI Model Pipeline for Accelerated MRI Reconstruction and Analysis", "comment": "11 pages. 14 figures. This work has been submitted to IEEE for\n  possible publication", "summary": "Advancements in AI have greatly enhanced the medical imaging process, making\nit quicker to diagnose patients. However, very few have investigated the\noptimization of a multi-model system with hardware acceleration. As specialized\nedge devices emerge, the efficient use of their accelerators is becoming\nincreasingly crucial. This paper proposes a hardware-accelerated method for\nsimultaneous reconstruction and diagnosis of \\ac{MRI} from \\ac{CT} images.\nReal-time performance of achieving a throughput of nearly 150 frames per second\nwas achieved by leveraging hardware engines available in modern NVIDIA edge\nGPU, along with scheduling techniques. This includes the GPU and the \\ac{DLA}\navailable in both Jetson AGX Xavier and Jetson AGX Orin, which were considered\nin this paper. The hardware allocation of different layers of the multiple AI\nmodels was done in such a way that the ideal time between the hardware engines\nis reduced. In addition, the AI models corresponding to the \\ac{GAN} model were\nfine-tuned in such a way that no fallback execution into the GPU engine is\nrequired without compromising accuracy. Indeed, the accuracy corresponding to\nthe fine-tuned edge GPU-aware AI models exhibited an accuracy enhancement of\n5\\%. A further hardware allocation of two fine-tuned GPU-aware GAN models\nproves they can double the performance over the original model, leveraging\nadequate partitioning on the NVIDIA Jetson AGX Xavier and Orin devices. The\nresults prove the effectiveness of employing hardware-aware models in parallel\nfor medical image analysis and diagnosis."}
{"id": "2510.01216", "categories": ["cs.DC", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.01216", "abs": "https://arxiv.org/abs/2510.01216", "authors": ["Preston Vander Vos"], "title": "Odontoceti: Ultra-Fast DAG Consensus with Two Round Commitment", "comment": "MSc thesis. Supervisors: Philipp Jovanovic and Alberto Sonnino", "summary": "Users of blockchains value scalability, expecting fast confirmations and\nimmediate transaction processing. Odontoceti, the latest in DAG-based\nconsensus, addresses these concerns by prioritizing low latency and high\nthroughput, making a strategic trade-off in security by operating with a 20%\nfault tolerance instead of the established 33% level. It is the first DAG-based\nprotocol to achieve commitment in just two communication rounds, delivering\nmedian latency of 300 milliseconds while processing 10,000 transactions per\nsecond under realistic network conditions. Odontoceti operates with n = 5f + 1\nvalidators and creates an uncertified DAG with a novel decision rule for\ncommitting blocks. The protocol includes an optimization that advances progress\nwhen participants are slow, benefiting crash fault scenarios which are more\ncommon in practice than Byzantine faults. Evaluation results demonstrate 20-25%\nlatency improvements compared to an existing production protocol, validating\nthat reducing wave length from three rounds to two rounds yields meaningful\nperformance benefits. This paper establishes the practical viability of lower\nfault tolerance consensus protocols for blockchains."}
{"id": "2510.01579", "categories": ["cs.NI"], "pdf": "https://arxiv.org/pdf/2510.01579", "abs": "https://arxiv.org/abs/2510.01579", "authors": ["Abhishek Kumar Singh", "Kyle Jamieson"], "title": "MMGaP: Multi-User MIMO Detection and Precoding using GPU-assisted Physics-inspired Computation", "comment": null, "summary": "Physics-inspired and quantum compute based methods for processing in the\nphysical layer of next-generation cellular radio access networks have\ndemonstrated theoretical advances in spectral efficiency in recent years, but\nhave stopped short of practical realization on commodity processors, leaving a\ngap between the throughput practical systems can achieve and the projected\nthroughput the state-of-the-art should achieve. To fill this gap, this paper\nproposes MMGaP, an uplink multi-user MIMO detector and downlink Vector\nperturbation precoder for next-generation cellular networks. MMGaP realizes\nthese large MIMO processing algorithms for the first time on bare-metal CUDA\nkernels that scale to run on large GPU processing platforms, and can be\npackaged as TensorFlow modules, allowing easy integration with a variety of\nsystems. We integrate MMGaP with NVIDIA's software-defined, GPU-accelerated 5G\nplatform and evaluate its performance against the state-of-the-art. In a 5G\ncellular network using 100 MHz of radio bandwidth, eight antennas at the base\nstation and eight concurrent users, we show that MMGaP improves uplink\nthroughput by approximately 50 Mbps per user and downlink throughput by 100\nMbps per user over a wide range of SNR. We further show that MMGaP can also\nsupport larger MIMO sizes: for 16 antennas at the base station and 16\nconcurrent users, MMGaP provides more than 50 Mbps higher uplink throughput per\nuser. We measure the execution time of MMGaP on different NVIDIA GPUs and show\nthat it can operate at line-rate and meet the timing requirements of\nstate-of-the-art 5G systems."}
{"id": "2510.01514", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01514", "abs": "https://arxiv.org/abs/2510.01514", "authors": ["J. Alexander Curtis", "Sharadha Kasiviswanathan", "Nasir Eisty"], "title": "Deciphering WONTFIX: A Mixed-Method Study on Why GitHub Issues Get Rejected", "comment": null, "summary": "Context: The ``wontfix'' label is a widely used yet narrowly understood tool\nin GitHub repositories, indicating that an issue will not be pursued further.\nDespite its prevalence, the impact of this label on project management and\ncommunity dynamics within open-source software development is not clearly\ndefined. Objective: This study examines the prevalence and reasons behind\nissues being labeled as wontfix across various open-source repositories on\nGitHub. Method: Employing a mixed-method approach, we analyze both quantitative\ndata to assess the prevalence of the wontfix label and qualitative data to\nexplore the reasoning that it was used. Data were collected from 3,132 of\nGitHub's most-popular repositories. Later, we employ open coding and thematic\nanalysis to categorize the reasons behind wontfix labels, providing a\nstructured understanding of the issue management landscape. Results: Our\nfindings show that about 30% of projects on GitHub apply the wontfix label to\nsome issues. These issues most often occur on user-submitted issues for bug\nreports and feature requests. The study identified eight common themes behind\nlabeling issues as wontfix, ranging from user-specific control factors to\nmaintainer-specific decisions. Conclusions: The wontfix label is a critical\ntool for managing resources and guiding contributor efforts in GitHub projects.\nHowever, it can also discourage community involvement and obscure the\ntransparency of project management. Understanding these reasons aids project\nmanagers in making informed decisions and fostering efficient collaboration\nwithin open-source communities."}
{"id": "2510.02099", "categories": ["cs.AR", "cs.NE", "B.3; B.7; I.4"], "pdf": "https://arxiv.org/pdf/2510.02099", "abs": "https://arxiv.org/abs/2510.02099", "authors": ["Felix Zeller", "John Reuben", "Dietmar Fey"], "title": "Multiplier-free In-Memory Vector-Matrix Multiplication Using Distributed Arithmetic", "comment": "9 pages, 10 figures", "summary": "Vector-Matrix Multiplication (VMM) is the fundamental and frequently required\ncomputation in inference of Neural Networks (NN). Due to the large data\nmovement required during inference, VMM can benefit greatly from in-memory\ncomputing. However, ADC/DACs required for in-memory VMM consume significant\npower and area. `Distributed Arithmetic (DA)', a technique in computer\narchitecture prevalent in 1980s was used to achieve inner product or dot\nproduct of two vectors without using a hard-wired multiplier when one of the\nvectors is a constant. In this work, we extend the DA technique to multiply an\ninput vector with a constant matrix. By storing the sum of the weights in\nmemory, DA achieves VMM using shift-and-add circuits in the periphery of ReRAM\nmemory. We verify functional and also estimate non-functional properties\n(latency, energy, area) by performing transistor-level simulations. Using\nenergy-efficient sensing and fine grained pipelining, our approach achieves 4.5\nx less latency and 12 x less energy than VMM performed in memory conventionally\nby bit slicing. Furthermore, DA completely eliminated the need for power-hungry\nADCs which are the main source of area and energy consumption in the current\nVMM implementations in memory."}
{"id": "2510.01256", "categories": ["cs.DC", "cs.AI", "cs.IT", "cs.LG", "math.IT", "I.2.6; I.2.7; C.2.4; C.1.4"], "pdf": "https://arxiv.org/pdf/2510.01256", "abs": "https://arxiv.org/abs/2510.01256", "authors": ["Lingling Zeng", "Gen Zhang", "Jialin Peng", "Xiang Xu", "Yuan Xu", "Lijun Ma"], "title": "Kant: An Efficient Unified Scheduling System for Large-Scale AI Clusters", "comment": "25 pages,15 figures", "summary": "As AI cluster sizes continue to expand and the demand for\nlarge-language-model (LLM) training and inference workloads grows rapidly,\ntraditional scheduling systems face significant challenges in balancing\nresource utilization, scheduling efficiency, and service quality. This paper\npresents and evaluates Kant: an efficient unified scheduling platform designed\nfor large-scale AI container clusters, supporting the co-scheduling of both\ntraining and inference jobs. Based on the practical implementation of the Kant\nsystem, we systematically define a set of key evaluation metrics for AI\nclusters, including GPU Allocation Ratio (GAR), Scheduling Occupancy Rate\n(SOR), GPU Node Fragmentation Ratio (GFR), Job Waiting Time Distribution\n(JWTD), and Job Training Time Estimation Distribution (JTTED), providing a\nfoundation for quantitative performance analysis. Experimental results\ndemonstrate that Kant achieves exceptional performance in clusters ranging from\nhundreds to tens of thousands of GPUs. By leveraging scheduling strategies such\nas Backfill and Enhanced Binpack (E-Binpack), the system significantly improves\nresource utilization and scheduling efficiency, while effectively reducing\nresource fragmentation and communication overhead in distributed training. The\nsystem has been deployed in multiple AI data center clusters, where it stably\nsupports large-scale intelligent computing workloads. This work provides a\npractical engineering approach for building high-performance, highly available,\nAI-native scheduling infrastructure."}
{"id": "2510.01885", "categories": ["cs.DC", "cs.NI"], "pdf": "https://arxiv.org/pdf/2510.01885", "abs": "https://arxiv.org/abs/2510.01885", "authors": ["Jamie Cotter", "Ignacio Castineiras", "Victor Cionca"], "title": "Accuracy vs Performance: An abstraction model for deadline constrained offloading at the mobile-edge", "comment": "Presented at in Irish Signals and Systems Conference 2025", "summary": "In this paper, we present a solution for low-latency deadline-constrained DNN\noffloading on mobile edge devices. We design a scheduling algorithm with\nlightweight network state representation, considering device availability,\ncommunication on the network link, priority-aware pre-emption, and task\ndeadlines. The scheduling algorithm aims to reduce latency by designing a\nresource availability representation, as well as a network discretisation and a\ndynamic bandwidth estimation mechanism. We implement the scheduling algorithm\ninto a system composed of four Raspberry Pi 2 (model Bs) mobile edge devices,\nsampling a waste classification conveyor belt at a set frame rate. The system\nis evaluated and compared to a previous approach of ours, which was proven to\noutcompete work-stealers and a non-pre-emption based scheduling heuristic under\nthe aforementioned waste classification scenario. Our findings show the novel\nlower latency abstraction models yield better performance under high-volume\nworkloads, with the dynamic bandwidth estimation assisting the task placement\nwhile, ultimately, increasing task throughput in times of resource scarcity."}
{"id": "2510.01635", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01635", "abs": "https://arxiv.org/abs/2510.01635", "authors": ["Yifei Chen", "Sarra Habchi", "Lili Wei"], "title": "MIMIC: Integrating Diverse Personality Traits for Better Game Testing Using Large Language Model", "comment": "13 pages, 7 figures, 6 tables. This paper is accepted by the 40th\n  IEEE/ACM International Conference on Automated Software Engineering, ASE 2025", "summary": "Modern video games pose significant challenges for traditional automated\ntesting algorithms, yet intensive testing is crucial to ensure game quality. To\naddress these challenges, researchers designed gaming agents using\nReinforcement Learning, Imitation Learning, or Large Language Models. However,\nthese agents often neglect the diverse strategies employed by human players due\nto their different personalities, resulting in repetitive solutions in similar\nsituations. Without mimicking varied gaming strategies, these agents struggle\nto trigger diverse in-game interactions or uncover edge cases.\n  In this paper, we present MIMIC, a novel framework that integrates diverse\npersonality traits into gaming agents, enabling them to adopt different gaming\nstrategies for similar situations. By mimicking different playstyles, MIMIC can\nachieve higher test coverage and richer in-game interactions across different\ngames. It also outperforms state-of-the-art agents in Minecraft by achieving a\nhigher task completion rate and providing more diverse solutions. These results\nhighlight MIMIC's significant potential for effective game testing."}
{"id": "2510.01260", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.01260", "abs": "https://arxiv.org/abs/2510.01260", "authors": ["Ningyuan Yang", "Guanliang Lyu", "Mingchen Ma", "Yiyi Lu", "Yiming Li", "Zhihui Gao", "Hancheng Ye", "Jianyi Zhang", "Tingjun Chen", "Yiran Chen"], "title": "IoT-MCP: Bridging LLMs and IoT Systems Through Model Context Protocol", "comment": null, "summary": "The integration of Large Language Models (LLMs) with Internet-of-Things (IoT)\nsystems faces significant challenges in hardware heterogeneity and control\ncomplexity. The Model Context Protocol (MCP) emerges as a critical enabler,\nproviding standardized communication between LLMs and physical devices. We\npropose IoT-MCP, a novel framework that implements MCP through edge-deployed\nservers to bridge LLMs and IoT ecosystems. To support rigorous evaluation, we\nintroduce IoT-MCP Bench, the first benchmark containing 114 Basic Tasks (e.g.,\n``What is the current temperature?'') and 1,140 Complex Tasks (e.g., ``I feel\nso hot, do you have any ideas?'') for IoT-enabled LLMs. Experimental validation\nacross 22 sensor types and 6 microcontroller units demonstrates IoT-MCP's 100%\ntask success rate to generate tool calls that fully meet expectations and\nobtain completely accurate results, 205ms average response time, and 74KB peak\nmemory footprint. This work delivers both an open-source integration framework\n(https://github.com/Duke-CEI-Center/IoT-MCP-Servers) and a standardized\nevaluation methodology for LLM-IoT systems."}
{"id": "2510.01740", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01740", "abs": "https://arxiv.org/abs/2510.01740", "authors": ["Kypros Iacovou", "Georgia M. Kapitsaki", "Evangelia Vanezi"], "title": "FOSS-chain: using blockchain for Open Source Software license compliance", "comment": null, "summary": "Open Source Software (OSS) is widely used and carries licenses that indicate\nthe terms under which the software is provided for use, also specifying\nmodification and distribution rules. Ensuring that users are respecting OSS\nlicense terms when creating derivative works is a complex process. Compliance\nissues arising from incompatibilities among licenses may lead to legal\ndisputes. At the same time, the blockchain technology with immutable entries\noffers a mechanism to provide transparency when it comes to licensing and\nensure software changes are recorded. In this work, we are introducing an\nintegration of blockchain and license management when creating derivative\nworks, in order to tackle the issue of OSS license compatibility. We have\ndesigned, implemented and performed a preliminary evaluation of FOSS-chain, a\nweb platform that uses blockchain and automates the license compliance process,\ncovering 14 OSS licenses. We have evaluated the initial prototype version of\nthe FOSS-chain platform via a small scale user study. Our preliminary results\nare promising, demonstrating the potential of the platform for adaptation on\nrealistic software systems."}
{"id": "2510.01536", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.01536", "abs": "https://arxiv.org/abs/2510.01536", "authors": ["Hasan Heydari", "Alysson Bessani", "Kartik Nayak"], "title": "QScale: Probabilistic Chained Consensus for Moderate-Scale Systems", "comment": null, "summary": "Existing distributed ledger protocols either incur a high communication\ncomplexity and are thus suited to systems with a small number of processes\n(e.g., PBFT), or rely on committee-sampling-based approaches that only work for\na very large number of processes (e.g., Algorand). Neither of these lines of\nwork is well-suited for moderate-scale distributed ledgers ranging from a few\nhundred to a thousand processes, which are common in production (e.g, Redbelly,\nSui). The goal of this work is to design a distributed ledger with sub-linear\ncommunication complexity per process, sub-quadratic total communication\ncomplexity, and low latency for finalizing a block into the ledger, such that\nit can be used for moderate-scale systems. We propose QScale, a protocol in\nwhich every process incurs only $\\widetilde{O}(\\kappa \\sqrt{n})$ communication\ncomplexity per-block in expectation, $\\widetilde{O}(n\\kappa)$ total\ncommunication complexity per-block in expectation, and a best-case latency of\n$O(\\kappa)$ rounds while ensuring safety and liveness with overwhelming\nprobability, with $\\kappa$ being a small security parameter."}
{"id": "2510.01754", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01754", "abs": "https://arxiv.org/abs/2510.01754", "authors": ["Hina Anwar"], "title": "ARENA: A tool for measuring and analysing the energy efficiency of Android apps", "comment": null, "summary": "To build energy-efficient apps, there is a need to estimate and analyze their\nenergy consumption in typical usage scenarios. The energy consumption of\nAndroid apps could be estimated via software-based and hardware-based\napproaches. Software-based approaches, while easier to implement, are not as\naccurate as hardware-based approaches. The process of measuring the energy\nconsumption of an Android app via a hardware-based approach typically involves\n1) setting up a measurement environment, 2) executing the app under test on a\nmobile device, 3) recording current/voltage data via a hardware device to\nmeasure energy consumption, and 4) cleaning and aggregating data for analyses,\nreports, and visualizations. Specialized scripts are written for selected\nhardware and software components to ensure reliable energy measurements. The\nenergy measurement process is repeated many times and aggregated to remove\nnoise. These steps make the hardware-based energy measurement process\ntime-consuming and not easy to adapt or reproduce. There is a lack of\nopen-source tools available for developers and researchers to take reliable\nenergy measurements via hardware devices. In this paper, we present and\ndemonstrate ARENA, a support tool that enables developers and researchers to\nconnect to a physical measurement device without leaving the comfort of their\nIDE. Developers could use ARENA during development to compare energy\nconsumption between different apps or versions of the same app. ARENA\ncalculates energy consumption on an Android smartphone by executing a test\nscenario on the app under development. Further, ARENA helps aggregate,\nstatistically analyze, report, and visualize the data, allowing developers and\nresearchers to dig into the data directly or visually. We implemented ARENA as\nan IntelliJ and Android Studio plugin."}
{"id": "2510.01885", "categories": ["cs.DC", "cs.NI"], "pdf": "https://arxiv.org/pdf/2510.01885", "abs": "https://arxiv.org/abs/2510.01885", "authors": ["Jamie Cotter", "Ignacio Castineiras", "Victor Cionca"], "title": "Accuracy vs Performance: An abstraction model for deadline constrained offloading at the mobile-edge", "comment": "Presented at in Irish Signals and Systems Conference 2025", "summary": "In this paper, we present a solution for low-latency deadline-constrained DNN\noffloading on mobile edge devices. We design a scheduling algorithm with\nlightweight network state representation, considering device availability,\ncommunication on the network link, priority-aware pre-emption, and task\ndeadlines. The scheduling algorithm aims to reduce latency by designing a\nresource availability representation, as well as a network discretisation and a\ndynamic bandwidth estimation mechanism. We implement the scheduling algorithm\ninto a system composed of four Raspberry Pi 2 (model Bs) mobile edge devices,\nsampling a waste classification conveyor belt at a set frame rate. The system\nis evaluated and compared to a previous approach of ours, which was proven to\noutcompete work-stealers and a non-pre-emption based scheduling heuristic under\nthe aforementioned waste classification scenario. Our findings show the novel\nlower latency abstraction models yield better performance under high-volume\nworkloads, with the dynamic bandwidth estimation assisting the task placement\nwhile, ultimately, increasing task throughput in times of resource scarcity."}
{"id": "2510.01825", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01825", "abs": "https://arxiv.org/abs/2510.01825", "authors": ["Zhenyu Yang", "Yue Pan", "Zhen Yang", "Zhongxing Yu"], "title": "Towards Speeding up Program Repair with Non-Autoregressive Model", "comment": "30 pages, 8 figures, 7 tables. arXiv admin note: substantial text\n  overlap with arXiv:2406.16526", "summary": "Enlightened by the success of machine learning techniques in various\napplication areas, recent years have witnessed a surge of research efforts on\nautomatic program repair (APR) using machine learning techniques. Previous\nmachine learning-based APR techniques essentially modified bugs in the\nautoregressive (AR) manner, which predicts future values based on past values.\nDue to the manner of token-by-token generation, the AR-based APR technique has\na huge time delay. In particular, the delay of the APR model with a large\nnumber of parameters is more serious. To address the issue, we aim to apply the\nnon-autoregressive (NAR) method to the APR task, which can output target code\nin a parallel manner to avoid huge repair delays. However, the naive use of the\nNAR manner for the APR task suffers from the issue of compromised patch\nquality. To effectively adapt the NAR manner for the APR task, we in this paper\npropose NARRepair, the first customized NAR code generation model for the APR\ntask. The NARRepair model features three major novelties, including 1) the\nrepair action predictor for alleviating the over-correction issue, 2) the\ninter-token dependency extractor for alleviating the issue of lacking\ninter-token dependency information, and 3) the two-stage decoder for\nalleviating the issue of lacking contextual information. We evaluated NARRepair\non three widely used datasets in the APR community, and the results show that\n1) compared to other APR techniques, the NARRepair model has the best\nperformance within the limited repair time, and 2) compared to AR-based APR\ntechniques, the repair speed of NARRepair has been increased by 1.4-6.4 times\nin the GPU environment. Overall, the results show that NARRepair has achieved\nstate-of-the-art comprehensive performance in terms of repair speed and\naccuracy."}
{"id": "2510.02170", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.02170", "abs": "https://arxiv.org/abs/2510.02170", "authors": ["Nick Brown", "Jake Davies", "Felix LeClair"], "title": "Programming RISC-V accelerators via Fortran", "comment": "Accepted extended abstract to the RISC-V Summit Europe 2025", "summary": "A range of RISC-V based accelerators are available and coming to market, and\nthere is strong potential for these to be used for High Performance Computing\n(HPC) workloads. However, such accelerators tend to provide bespoke programming\nmodels and APIs that require codes to be rewritten. In scientific computing,\nwhere many of the simulation code are highly complex, extensive, and written in\nFortran, this is not realistic. In this extended abstract we present an\napproach that enables driving such architectures via Fortran, avoiding code\nredevelopment."}
{"id": "2510.01960", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01960", "abs": "https://arxiv.org/abs/2510.01960", "authors": ["Victor Lira", "Paulo Borba", "Rodrigo Bonifácio", "Galileu Santos e Matheus barbosa"], "title": "RefFilter: Improving Semantic Conflict Detection via Refactoring-Aware Static Analysis", "comment": null, "summary": "Detecting semantic interference remains a challenge in collaborative software\ndevelopment. Recent lightweight static analysis techniques improve efficiency\nover SDG-based methods, but they still suffer from a high rate of false\npositives. A key cause of these false positives is the presence of\nbehavior-preserving code refactorings, which current techniques cannot\neffectively distinguish from changes that impact behavior and can interfere\nwith others. To handle this problem we present RefFilter, a refactoring-aware\ntool for semantic interference detection. It builds on existing static\ntechniques by incorporating automated refactoring detection to improve\nprecision. RefFilter discards behavior-preserving refactorings from reports,\nreducing false positives while preserving detection coverage. To evaluate\neffectiveness and scalability, use two datasets: a labeled dataset with 99\nscenarios and ground truth, and a novel dataset of 1,087 diverse merge\nscenarios that we have built. Experimental results show that RefFilter reduces\nfalse positives by nearly 32% on the labeled dataset. While this reduction\ncomes with a non significant increase in false negatives, the overall gain in\nprecision significantly outweighs the minor trade-off in recall. These findings\ndemonstrate that refactoring-aware interference detection is a practical and\neffective strategy for improving merge support in modern development workflows."}
{"id": "2510.01994", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.01994", "abs": "https://arxiv.org/abs/2510.01994", "authors": ["Chen Yang", "Lin Yang", "Ziqi Wang", "Dong Wang", "Jianyi Zhou", "Junjie Chen"], "title": "Clarifying Semantics of In-Context Examples for Unit Test Generation", "comment": "accepted in the research track of ASE 2025", "summary": "Recent advances in large language models (LLMs) have enabled promising\nperformance in unit test generation through in-context learning (ICL). However,\nthe quality of in-context examples significantly influences the effectiveness\nof generated tests-poorly structured or semantically unclear test examples\noften lead to suboptimal outputs. In this paper, we propose CLAST, a novel\ntechnique that systematically refines unit tests to improve their semantic\nclarity, thereby enhancing their utility as in-context examples. The approach\ndecomposes complex tests into logically clearer ones and improves semantic\nclarity through a combination of program analysis and LLM-based rewriting. We\nevaluated CLAST on four open-source and three industrial projects. The results\ndemonstrate that CLAST largely outperforms UTgen, the state-of-the-art\nrefinement technique, in both preserving test effectiveness and enhancing\nsemantic clarity. Specifically, CLAST fully retains the original effectiveness\nof unit tests, while UTgen reduces compilation success rate (CSR), pass rate\n(PR), test coverage (Cov), and mutation score (MS) by an average of 12.90%,\n35.82%, 4.65%, and 5.07%, respectively. Over 85.33% of participants in our user\nstudy preferred the semantic clarity of CLAST-refined tests. Notably,\nincorporating CLAST-refined tests as examples effectively improves ICL-based\nunit test generation approaches such as RAGGen and TELPA, resulting in an\naverage increase of 25.97% in CSR, 28.22% in PR, and 45.99% in Cov for\ngenerated tests, compared to incorporating UTgen-refined tests. The insights\nfrom the follow-up user study not only reinforce CLAST's potential impact in\nsoftware testing practice but also illuminate avenues for future research."}
{"id": "2510.02002", "categories": ["cs.SE", "D.2.1; D.2.2; D.2.3; D.3.4; G.1.6"], "pdf": "https://arxiv.org/pdf/2510.02002", "abs": "https://arxiv.org/abs/2510.02002", "authors": ["Maximilian Kratz", "Steffen Zschaler", "Jens Kosiol", "Gabriele Taentzer"], "title": "Automatic Generation of Combinatorial Reoptimisation Problem Specifications: A Vision", "comment": null, "summary": "Once an optimisation problem has been solved, the solution may need\nadaptation when contextual factors change. This challenge, also known as\nreoptimisation, has been addressed in various problem domains, such as railway\ncrew rescheduling, nurse rerostering, or aircraft recovery. This requires a\nmodified problem to be solved again to ensure that the adapted solution is\noptimal in the new context. However, the new optimisation problem differs\nnotably from the original problem: (i) we want to make only minimal changes to\nthe original solution to minimise the impact; (ii) we may be unable to change\nsome parts of the original solution (e.g., because they refer to past\nallocations); and (iii) we need to derive a change script from the original\nsolution to the new solution. In this paper, we argue that Model-Driven\nEngineering (MDE) - in particular, the use of declarative modelling languages\nand model transformations for the high-level specification of optimisation\nproblems - offers new opportunities for the systematic derivation of\nreoptimisation problems from the original optimisation problem specification.\nWe focus on combinatorial reoptimisation problems and provide an initial\ncategorisation of changing problems and strategies for deriving the\ncorresponding reoptimisation specifications. We introduce an initial\nproof-of-concept implementation based on the GIPS (Graph-Based (Mixed) Integer\nLinear Programming Problem Specification) tool and apply it to an example\nresource-allocation problem: the allocation of teaching assistants to teaching\nsessions."}
{"id": "2510.02007", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02007", "abs": "https://arxiv.org/abs/2510.02007", "authors": ["Justus Bogner", "Roberto Verdecchia"], "title": "ACM SIGSOFT SEN Empirical Software Engineering: Introducing Our New Regular Column", "comment": "Published in ACM SIGSOFT Software Engineering Notes (SIGSOFT-SEN).\n  Volume 50, Issue 4, 2025", "summary": "From its early foundations in the 1970s, empirical software engineering (ESE)\nhas evolved into a mature research discipline that embraces a plethora of\ndifferent topics, methodologies, and industrial practices. Despite its\nremarkable progress, the ESE research field still needs to keep evolving, as\nnew impediments, shortcoming, and technologies emerge. Research\nreproducibility, limited external validity, subjectivity of reviews, and\nporting research results to industrial practices are just some examples of the\ndrivers for improvements to ESE research. Additionally, several facets of ESE\nresearch are not documented very explicitly, which makes it difficult for\nnewcomers to pick them up. With this new regular ACM SIGSOFT SEN column\n(SEN-ESE), we introduce a venue for discussing meta-aspects of ESE research,\nranging from general topics such as the nature and best practices for\nreplication packages, to more nuanced themes such as statistical methods,\ninterview transcription tools, and publishing interdisciplinary research. Our\naim for the column is to be a place where we can regularly spark conversations\non ESE topics that might not often be touched upon or are left implicit.\nContributions to this column will be grounded in expert interviews, focus\ngroups, surveys, and position pieces, with the goal of encouraging reflection\nand improvement in how we conduct, communicate, teach, and ultimately improve\nESE research. Finally, we invite feedback from the ESE community on\nchallenging, controversial, or underexplored topics, as well as suggestions for\nvoices you would like to hear from. While we cannot promise to act on every\nidea, we aim to shape this column around the community interests and are\ngrateful for all contributions."}
{"id": "2510.02165", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02165", "abs": "https://arxiv.org/abs/2510.02165", "authors": ["Peter Wauyo", "Dalia Bwiza", "Alain Murara", "Edwin Mugume", "Eric Umuhoza"], "title": "Towards fairer public transit: Real-time tensor-based multimodal fare evasion and fraud detection", "comment": "10 pages", "summary": "This research introduces a multimodal system designed to detect fraud and\nfare evasion in public transportation by analyzing closed circuit television\n(CCTV) and audio data. The proposed solution uses the Vision Transformer for\nVideo (ViViT) model for video feature extraction and the Audio Spectrogram\nTransformer (AST) for audio analysis. The system implements a Tensor Fusion\nNetwork (TFN) architecture that explicitly models unimodal and bimodal\ninteractions through a 2-fold Cartesian product. This advanced fusion technique\ncaptures complex cross-modal dynamics between visual behaviors (e.g.,\ntailgating,unauthorized access) and audio cues (e.g., fare transaction sounds).\nThe system was trained and tested on a custom dataset, achieving an accuracy of\n89.5%, precision of 87.2%, and recall of 84.0% in detecting fraudulent\nactivities, significantly outperforming early fusion baselines and exceeding\nthe 75% recall rates typically reported in state-of-the-art transportation\nfraud detection systems. Our ablation studies demonstrate that the tensor\nfusion approach provides a 7.0% improvement in the F1 score and an 8.8% boost\nin recall compared to traditional concatenation methods. The solution supports\nreal-time detection, enabling public transport operators to reduce revenue\nloss, improve passenger safety, and ensure operational compliance."}
{"id": "2510.02166", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.02166", "abs": "https://arxiv.org/abs/2510.02166", "authors": ["Fatou Ndiaye Mbodji", "El-hacen Diallo", "Jordan Samhi", "Kui Liu", "Jacques Klein", "Tegawendé F. Bissyande"], "title": "SIEVE: Towards Verifiable Certification for Code-datasets", "comment": "5", "summary": "Code agents and empirical software engineering rely on public code datasets,\nyet these datasets lack verifiable quality guarantees. Static 'dataset cards'\ninform, but they are neither auditable nor do they offer statistical\nguarantees, making it difficult to attest to dataset quality. Teams build\nisolated, ad-hoc cleaning pipelines. This fragments effort and raises cost. We\npresent SIEVE, a community-driven framework. It turns per-property checks into\nConfidence Cards-machine-readable, verifiable certificates with anytime-valid\nstatistical bounds. We outline a research plan to bring SIEVE to maturity,\nreplacing narrative cards with anytime-verifiable certification. This shift is\nexpected to lower quality-assurance costs and increase trust in code-datasets."}
{"id": "2510.02169", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.02169", "abs": "https://arxiv.org/abs/2510.02169", "authors": ["Vadim Safronov", "Anthony McCaigue", "Nicholas Allott", "Andrew Martin"], "title": "TAIBOM: Bringing Trustworthiness to AI-Enabled Systems", "comment": "This paper has been accepted at the First International Workshop on\n  Security and Privacy-Preserving AI/ML (SPAIML 2025), co-located with the 28th\n  European Conference on Artificial Intelligence (ECAI 2025)", "summary": "The growing integration of open-source software and AI-driven technologies\nhas introduced new layers of complexity into the software supply chain,\nchallenging existing methods for dependency management and system assurance.\nWhile Software Bills of Materials (SBOMs) have become critical for enhancing\ntransparency and traceability, current frameworks fall short in capturing the\nunique characteristics of AI systems -- namely, their dynamic, data-driven\nnature and the loosely coupled dependencies across datasets, models, and\nsoftware components. These challenges are compounded by fragmented governance\nstructures and the lack of robust tools for ensuring integrity, trust, and\ncompliance in AI-enabled environments.\n  In this paper, we introduce Trusted AI Bill of Materials (TAIBOM) -- a novel\nframework extending SBOM principles to the AI domain. TAIBOM provides (i) a\nstructured dependency model tailored for AI components, (ii) mechanisms for\npropagating integrity statements across heterogeneous AI pipelines, and (iii) a\ntrust attestation process for verifying component provenance. We demonstrate\nhow TAIBOM supports assurance, security, and compliance across AI workflows,\nhighlighting its advantages over existing standards such as SPDX and CycloneDX.\nThis work lays the foundation for trustworthy and verifiable AI systems through\nstructured software transparency."}
{"id": "2510.02185", "categories": ["cs.SE", "cs.CR", "cs.MA", "D.2.4; F.3.1"], "pdf": "https://arxiv.org/pdf/2510.02185", "abs": "https://arxiv.org/abs/2510.02185", "authors": ["Paschal C. Amusuo", "Dongge Liu", "Ricardo Andres Calvo Mendez", "Jonathan Metzman", "Oliver Chang", "James C. Davis"], "title": "FalseCrashReducer: Mitigating False Positive Crashes in OSS-Fuzz-Gen Using Agentic AI", "comment": "12 pages, 2 figures", "summary": "Fuzz testing has become a cornerstone technique for identifying software bugs\nand security vulnerabilities, with broad adoption in both industry and\nopen-source communities. Directly fuzzing a function requires fuzz drivers,\nwhich translate random fuzzer inputs into valid arguments for the target\nfunction. Given the cost and expertise required to manually develop fuzz\ndrivers, methods exist that leverage program analysis and Large Language Models\nto automatically generate these drivers. However, the generated fuzz drivers\nfrequently lead to false positive crashes, especially in functions highly\nstructured input and complex state requirements. This problem is especially\ncrucial in industry-scale fuzz driver generation efforts like OSS-Fuzz-en, as\nreporting false positive crashes to maintainers impede trust in both the system\nand the team.\n  This paper presents two AI-driven strategies to reduce false positives in\nOSS-Fuzz-Gen, a multi-agent system for automated fuzz driver generation. First,\nconstraint-based fuzz driver generation proactively enforces constraints on a\nfunction's inputs and state to guide driver creation. Second, context-based\ncrash validation reactively analyzes function callers to determine whether\nreported crashes are feasible from program entry points. Using 1,500 benchmark\nfunctions from OSS-Fuzz, we show that these strategies reduce spurious crashes\nby up to 8%, cut reported crashes by more than half, and demonstrate that\nfrontier LLMs can serve as reliable program analysis agents. Our results\nhighlight the promise and challenges of integrating AI into large-scale fuzzing\npipelines."}
