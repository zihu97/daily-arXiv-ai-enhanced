{"id": "2511.09956", "categories": ["cs.DC", "cs.OS", "cs.PF"], "pdf": "https://arxiv.org/pdf/2511.09956", "abs": "https://arxiv.org/abs/2511.09956", "authors": ["Mani Tofigh", "Edward Guo", "Weiwei Jia", "Xiaoning Ding", "Jianchen Shan"], "title": "Optimizing CPU Cache Utilization in Cloud VMs with Accurate Cache Abstraction", "comment": null, "summary": "This paper shows that cache-based optimizations are often ineffective in cloud virtual machines (VMs) due to limited visibility into and control over provisioned caches. In public clouds, CPU caches can be partitioned or shared among VMs, but a VM is unaware of cache provisioning details. Moreover, a VM cannot influence cache usage via page placement policies, as memory-to-cache mappings are hidden. The paper proposes a novel solution, CacheX, which probes accurate and fine-grained cache abstraction within VMs using eviction sets without requiring hardware or hypervisor support, and showcases the utility of the probed information with two new techniques: LLC contention-aware task scheduling and virtual color-aware page cache management. Our evaluation of CacheX's implementation in x86 Linux kernel demonstrates that it can effectively improve cache utilization for various workloads in public cloud VMs.", "AI": {"tldr": "\u672c\u6587\u6307\u51fa\u4e91\u865a\u62df\u673a\u4e2d\u7f13\u5b58\u4f18\u5316\u5e38\u56e0\u7f3a\u4e4f\u5bf9\u7f13\u5b58\u5206\u914d\u7684\u53ef\u89c1\u6027\u4e0e\u63a7\u5236\u800c\u5931\u6548\uff0c\u5e76\u63d0\u51fa\u540d\u4e3aCacheX\u7684\u65b0\u65b9\u6848\uff0c\u901a\u8fc7\u9a71\u9010\u96c6\u5728\u65e0\u9700\u786c\u4ef6\u6216\u865a\u62df\u673a\u76d1\u63a7\u5668\u652f\u6301\u7684\u60c5\u51b5\u4e0b\u63a2\u6d4b\u7ec6\u7c92\u5ea6\u7f13\u5b58\u4fe1\u606f\uff0c\u8fdb\u800c\u5b9e\u73b0LLC\u4e89\u7528\u611f\u77e5\u7684\u4efb\u52a1\u8c03\u5ea6\u548c\u865a\u62df\u989c\u8272\u611f\u77e5\u7684\u9875\u7f13\u5b58\u7ba1\u7406\uff0c\u663e\u8457\u63d0\u5347\u516c\u6709\u4e91VM\u4e2d\u7684\u7f13\u5b58\u5229\u7528\u7387\u3002", "motivation": "\u5728\u516c\u6709\u4e91\u73af\u5883\u4e2d\uff0c\u865a\u62df\u673a\u65e0\u6cd5\u83b7\u77e5CPU\u7f13\u5b58\u7684\u5206\u914d\u7ec6\u8282\uff08\u5982\u662f\u5426\u88ab\u5206\u533a\u6216\u5171\u4eab\uff09\uff0c\u4e5f\u65e0\u6cd5\u901a\u8fc7\u9875\u9762\u653e\u7f6e\u7b56\u7565\u5f71\u54cd\u7f13\u5b58\u4f7f\u7528\uff0c\u56e0\u4e3a\u5185\u5b58\u5230\u7f13\u5b58\u7684\u6620\u5c04\u5bf9\u865a\u62df\u673a\u662f\u9690\u85cf\u7684\uff0c\u5bfc\u81f4\u4f20\u7edf\u7f13\u5b58\u4f18\u5316\u65b9\u6cd5\u6548\u679c\u6709\u9650\u3002", "method": "\u63d0\u51faCacheX\u7cfb\u7edf\uff0c\u5229\u7528\u9a71\u9010\u96c6\uff08eviction sets\uff09\u5728\u865a\u62df\u673a\u5185\u90e8\u63a2\u6d4b\u7cbe\u786e\u4e14\u7ec6\u7c92\u5ea6\u7684\u7f13\u5b58\u62bd\u8c61\uff0c\u65e0\u9700\u4f9d\u8d56\u786c\u4ef6\u6216Hypervisor\u652f\u6301\uff1b\u5e76\u57fa\u4e8e\u6240\u83b7\u53d6\u7684\u4fe1\u606f\u5b9e\u73b0\u4e24\u79cd\u65b0\u6280\u672f\uff1a\u672b\u7ea7\u7f13\u5b58\uff08LLC\uff09\u4e89\u7528\u611f\u77e5\u7684\u4efb\u52a1\u8c03\u5ea6\u548c\u865a\u62df\u989c\u8272\u611f\u77e5\u7684\u9875\u7f13\u5b58\u7ba1\u7406\u3002", "result": "\u5728x86 Linux\u5185\u6838\u4e2d\u5b9e\u73b0\u5e76\u8bc4\u4f30CacheX\uff0c\u7ed3\u679c\u8868\u660e\u5176\u80fd\u6709\u6548\u63d0\u5347\u591a\u79cd\u5de5\u4f5c\u8d1f\u8f7d\u5728\u516c\u6709\u4e91\u865a\u62df\u673a\u4e2d\u7684\u7f13\u5b58\u5229\u7528\u7387\u3002", "conclusion": "CacheX\u901a\u8fc7\u5728\u865a\u62df\u673a\u5185\u90e8\u81ea\u4e3b\u63a2\u6d4b\u7f13\u5b58\u7ed3\u6784\uff0c\u514b\u670d\u4e86\u4e91\u73af\u5883\u4e2d\u7f13\u5b58\u4fe1\u606f\u4e0d\u53ef\u89c1\u7684\u95ee\u9898\uff0c\u4e3a\u63d0\u5347\u7f13\u5b58\u6027\u80fd\u63d0\u4f9b\u4e86\u5b9e\u7528\u4e14\u65e0\u9700\u5e95\u5c42\u652f\u6301\u7684\u65b0\u9014\u5f84\u3002"}}
{"id": "2511.09688", "categories": ["cs.AR", "cs.CR"], "pdf": "https://arxiv.org/pdf/2511.09688", "abs": "https://arxiv.org/abs/2511.09688", "authors": ["Hiroshi Nakano", "Hiroaki Nishi"], "title": "History-Aware Trajectory k-Anonymization Using an FPGA-Based Hardware Accelerator for Real-Time Location Services", "comment": null, "summary": "Our previous work established the feasibility of FPGA-based real-time trajectory anonymization, a critical task for protecting user privacy in modern location-based services (LBS). However, that pioneering approach relied exclusively on shortest-path computations, which can fail to capture re- alistic travel behavior and thus reduce the utility of the anonymized data. To address this limitation, this paper introduces a novel, history-aware trajectory k-anonymization methodology and presents an advanced FPGA-based hardware architecture to implement it. Our proposed architecture uniquely integrates par- allel history-based trajectory searches with conventional shortest- path finding, using a custom fixed-point counting module to ac- curately weigh contributions from historical data. This approach enables the system to prioritize behaviorally common routes over geometrically shorter but less-traveled paths. The FPGA implementation demonstrates that our new architecture achieves a real-time throughput of over 6,000 records/s, improves data retention by up to 1.2% compared to our previous shortest-path- only design, and preserves major arterial roads more effectively. These results signify a key advancement, enabling high-fidelity, history-aware anonymization that preserves both privacy and behavioral accuracy under the strict latency constraints of LBS.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u7ed3\u5408\u5386\u53f2\u8f68\u8ff9\u4fe1\u606f\u7684k-\u533f\u540d\u5316\u65b9\u6cd5\uff0c\u5e76\u5728FPGA\u4e0a\u5b9e\u73b0\u4e86\u652f\u6301\u8be5\u65b9\u6cd5\u7684\u786c\u4ef6\u67b6\u6784\uff0c\u5728\u4fdd\u8bc1\u5b9e\u65f6\u6027\u7684\u540c\u65f6\u63d0\u5347\u4e86\u8f68\u8ff9\u6570\u636e\u7684\u6548\u7528\u548c\u4fdd\u771f\u5ea6\u3002", "motivation": "\u5148\u524d\u57fa\u4e8e\u6700\u77ed\u8def\u5f84\u7684\u8f68\u8ff9\u533f\u540d\u5316\u65b9\u6cd5\u65e0\u6cd5\u51c6\u786e\u53cd\u6620\u7528\u6237\u771f\u5b9e\u51fa\u884c\u884c\u4e3a\uff0c\u5bfc\u81f4\u533f\u540d\u5316\u540e\u6570\u636e\u6548\u7528\u964d\u4f4e\uff0c\u56e0\u6b64\u9700\u8981\u5f15\u5165\u5386\u53f2\u884c\u4e3a\u4fe1\u606f\u4ee5\u63d0\u5347\u5b9e\u7528\u6027\u3002", "method": "\u63d0\u51fa\u4e00\u79cd\u5386\u53f2\u611f\u77e5\u7684\u8f68\u8ff9k-\u533f\u540d\u5316\u65b9\u6cd5\uff0c\u8bbe\u8ba1\u4e86\u96c6\u6210\u5e76\u884c\u5386\u53f2\u8f68\u8ff9\u641c\u7d22\u4e0e\u6700\u77ed\u8def\u5f84\u67e5\u627e\u7684FPGA\u786c\u4ef6\u67b6\u6784\uff0c\u5e76\u91c7\u7528\u81ea\u5b9a\u4e49\u5b9a\u70b9\u8ba1\u6570\u6a21\u5757\u5bf9\u5386\u53f2\u6570\u636e\u8d21\u732e\u8fdb\u884c\u52a0\u6743\u3002", "result": "\u65b0\u67b6\u6784\u5728FPGA\u4e0a\u5b9e\u73b0\u5b9e\u65f6\u5904\u7406\u8d85\u8fc76000\u6761\u8bb0\u5f55/\u79d2\uff0c\u76f8\u6bd4\u4ec5\u4f7f\u7528\u6700\u77ed\u8def\u5f84\u7684\u65b9\u6cd5\uff0c\u6570\u636e\u4fdd\u7559\u7387\u63d0\u5347\u6700\u591a1.2%\uff0c\u5e76\u66f4\u6709\u6548\u5730\u4fdd\u7559\u4e3b\u5e72\u9053\u8def\u4fe1\u606f\u3002", "conclusion": "\u8be5\u7814\u7a76\u5b9e\u73b0\u4e86\u5728LBS\u4e25\u683c\u5ef6\u8fdf\u7ea6\u675f\u4e0b\u517c\u987e\u9690\u79c1\u4fdd\u62a4\u4e0e\u884c\u4e3a\u51c6\u786e\u6027\u7684\u9ad8\u4fdd\u771f\u8f68\u8ff9\u533f\u540d\u5316\uff0c\u662f\u8f68\u8ff9\u9690\u79c1\u4fdd\u62a4\u6280\u672f\u7684\u91cd\u8981\u8fdb\u5c55\u3002"}}
{"id": "2511.10007", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.10007", "abs": "https://arxiv.org/abs/2511.10007", "authors": ["Hongqin Lyu", "Yonghao Wang", "Jiaxin Zhou", "Zhiteng Chao", "Tiancheng Wang", "Huawei Li"], "title": "AssertMiner: Module-Level Spec Generation and Assertion Mining using Static Analysis Guided LLMs", "comment": "6 pages, 8 figures", "summary": "Assertion-based verification (ABV) is a key approach to checking whether a logic design complies with its architectural specifications. Existing assertion generation methods based on design specifications typically produce only top-level assertions, overlooking verification needs on the implementation details in the modules at the micro-architectural level, where design errors occur more frequently. To address this limitation, we present AssertMiner, a module-level assertion generation framework that leverages static information generated from abstract syntax tree (AST) to assist LLMs in mining assertions. Specifically, it performs AST-based structural extraction to derive the module call graph, I/O table, and dataflow graph, guiding the LLM to generate module-level specifications and mine module-level assertions. Our evaluation demonstrates that AssertMiner outperforms existing methods such as AssertLLM and Spec2Assertion in generating high-quality assertions for modules. When integrated with these methods, AssertMiner can enhance the structural coverage and significantly improve the error detection capability, enabling a more comprehensive and efficient verification process.", "AI": {"tldr": "AssertMiner is a module-level assertion generation framework that uses static AST-derived information to guide LLMs in generating detailed, high-quality assertions, improving verification coverage and error detection over existing methods.", "motivation": "Existing assertion generation methods focus only on top-level specifications and neglect micro-architectural implementation details where design errors are more common, creating a need for module-level assertion generation.", "method": "AssertMiner leverages abstract syntax tree (AST) analysis to extract structural information\u2014such as module call graphs, I/O tables, and dataflow graphs\u2014and uses this to guide large language models (LLMs) in mining module-level assertions.", "result": "AssertMiner outperforms prior methods like AssertLLM and Spec2Assertion in generating high-quality module-level assertions and enhances structural coverage and error detection when integrated with them.", "conclusion": "By focusing on module-level details through AST-guided LLM prompting, AssertMiner enables more comprehensive and efficient hardware verification."}}
{"id": "2511.09766", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.09766", "abs": "https://arxiv.org/abs/2511.09766", "authors": ["Michael Dang'ana", "Yuqiu Zhang", "Hans-Arno Jacobsen"], "title": "Ksurf-Drone: Attention Kalman Filter for Contextual Bandit Optimization in Cloud Resource Allocation", "comment": "14 pages, 22 figures, 2 tables", "summary": "Resource orchestration and configuration parameter search are key concerns for container-based infrastructure in cloud data centers. Large configuration search space and cloud uncertainties are often mitigated using contextual bandit techniques for resource orchestration including the state-of-the-art Drone orchestrator. Complexity in the cloud provider environment due to varying numbers of virtual machines introduces variability in workloads and resource metrics, making orchestration decisions less accurate due to increased nonlinearity and noise. Ksurf, a state-of-the-art variance-minimizing estimator method ideal for highly variable cloud data, enables optimal resource estimation under conditions of high cloud variability.\n  This work evaluates the performance of Ksurf on estimation-based resource orchestration tasks involving highly variable workloads when employed as a contextual multi-armed bandit objective function model for cloud scenarios using Drone. Ksurf enables significantly lower latency variance of $41\\%$ at p95 and $47\\%$ at p99, demonstrates a $4\\%$ reduction in CPU usage and 7 MB reduction in master node memory usage on Kubernetes, resulting in a $7\\%$ cost savings in average worker pod count on VarBench Kubernetes benchmark.", "AI": {"tldr": "\u672c\u6587\u8bc4\u4f30\u4e86Ksurf\u5728\u9ad8\u6ce2\u52a8\u4e91\u73af\u5883\u4e0b\u4f5c\u4e3aDrone\u7f16\u6392\u5668\u4e2d\u4e0a\u4e0b\u6587\u591a\u81c2\u8d4c\u535a\u673a\u76ee\u6807\u51fd\u6570\u6a21\u578b\u7684\u6027\u80fd\uff0c\u7ed3\u679c\u8868\u660e\u5176\u663e\u8457\u964d\u4f4e\u4e86\u5ef6\u8fdf\u65b9\u5dee\u5e76\u8282\u7701\u4e86\u8d44\u6e90\u6210\u672c\u3002", "motivation": "\u4e91\u6570\u636e\u4e2d\u5fc3\u4e2d\u5bb9\u5668\u5316\u57fa\u7840\u8bbe\u65bd\u9762\u4e34\u914d\u7f6e\u641c\u7d22\u7a7a\u95f4\u5e9e\u5927\u548c\u4e91\u73af\u5883\u4e0d\u786e\u5b9a\u6027\u9ad8\u7684\u6311\u6218\uff0c\u73b0\u6709\u7f16\u6392\u65b9\u6cd5\uff08\u5982Drone\uff09\u5728\u9ad8\u5ea6\u53ef\u53d8\u7684\u5de5\u4f5c\u8d1f\u8f7d\u4e0b\u51c6\u786e\u6027\u53d7\u9650\u3002", "method": "\u5c06Ksurf\u8fd9\u4e00\u65b9\u5dee\u6700\u5c0f\u5316\u4f30\u8ba1\u65b9\u6cd5\u96c6\u6210\u5230Drone\u7f16\u6392\u5668\u4e2d\uff0c\u4f5c\u4e3a\u4e0a\u4e0b\u6587\u591a\u81c2\u8d4c\u535a\u673a\u7684\u76ee\u6807\u51fd\u6570\u6a21\u578b\uff0c\u7528\u4e8e\u9ad8\u6ce2\u52a8\u6027\u5de5\u4f5c\u8d1f\u8f7d\u4e0b\u7684\u8d44\u6e90\u4f30\u8ba1\u4e0e\u7f16\u6392\u3002", "result": "Ksurf\u5728p95\u548cp99\u5206\u522b\u964d\u4f4e41%\u548c47%\u7684\u5ef6\u8fdf\u65b9\u5dee\uff0c\u51cf\u5c114%\u7684CPU\u4f7f\u7528\u7387\u30017MB\u4e3b\u8282\u70b9\u5185\u5b58\u5360\u7528\uff0c\u5e76\u5728VarBench\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u5b9e\u73b0\u5e73\u57477%\u7684Worker Pod\u6570\u91cf\u6210\u672c\u8282\u7ea6\u3002", "conclusion": "Ksurf\u80fd\u6709\u6548\u63d0\u5347\u9ad8\u6ce2\u52a8\u4e91\u73af\u5883\u4e2d\u8d44\u6e90\u7f16\u6392\u7684\u51c6\u786e\u6027\u548c\u6548\u7387\uff0c\u663e\u8457\u964d\u4f4e\u5ef6\u8fdf\u65b9\u5dee\u4e0e\u8d44\u6e90\u5f00\u9500\uff0c\u5177\u6709\u5b9e\u9645\u90e8\u7f72\u4ef7\u503c\u3002"}}
{"id": "2511.10397", "categories": ["cs.PF"], "pdf": "https://arxiv.org/pdf/2511.10397", "abs": "https://arxiv.org/abs/2511.10397", "authors": ["Josse Van Delm", "Anton Lydike", "Joren Dumoulin", "Jonas Crols", "Xiaoling Yi", "Ryan Antonio", "Jackson Woodruff", "Tobias Grosser", "Marian Verhelst"], "title": "The Configuration Wall: Characterization and Elimination of Accelerator Configuration Overhead", "comment": "To appear in Proceedings of ASPLOS 2026", "summary": "Contemporary compute platforms increasingly offload compute kernels from CPU to integrated hardware accelerators to reach maximum performance per Watt. Unfortunately, the time the CPU spends on setup control and synchronization has increased with growing accelerator complexity. For systems with complex accelerators, this means that performance can be configuration-bound. Faster accelerators are more severely impacted by this overlooked performance drop, which we call the configuration wall. Prior work evidences this wall and proposes ad-hoc solutions to reduce configuration overhead. However, these solutions are not universally applicable, nor do they offer comprehensive insights into the underlying causes of performance degradation. In this work, we first introduce a widely-applicable variant of the well-known roofline model to quantify when system performance is configuration-bound. To move systems out of the performance-bound region, we subsequently propose a domain-specific compiler abstraction and associated optimization passes. We implement the abstraction and passes in the MLIR compiler framework to run optimized binaries on open-source architectures to prove its effectiveness and generality. Experiments demonstrate a geomean performance boost of 2x on the open-source OpenGeMM system, by eliminating redundant configuration cycles and by automatically hiding the remaining configuration cycles. Our work provides key insights in how accelerator performance is affected by setup mechanisms, thereby facilitating automatic code generation for circumventing the configuration wall.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u6269\u5c55\u7684roofline\u6a21\u578b\u6765\u8bc6\u522b\u7cfb\u7edf\u662f\u5426\u53d7\u914d\u7f6e\u74f6\u9888\u9650\u5236\uff0c\u5e76\u5f15\u5165\u4e00\u79cd\u9886\u57df\u7279\u5b9a\u7684\u7f16\u8bd1\u5668\u62bd\u8c61\u4e0e\u4f18\u5316\u65b9\u6cd5\uff0c\u901a\u8fc7MLIR\u6846\u67b6\u5b9e\u73b0\uff0c\u5728OpenGeMM\u7cfb\u7edf\u4e0a\u5b9e\u73b0\u4e862\u500d\u7684\u51e0\u4f55\u5e73\u5747\u6027\u80fd\u63d0\u5347\uff0c\u6709\u6548\u7f13\u89e3\u201c\u914d\u7f6e\u5899\u201d\u95ee\u9898\u3002", "motivation": "\u968f\u7740\u786c\u4ef6\u52a0\u901f\u5668\u590d\u6742\u5ea6\u589e\u52a0\uff0cCPU\u5728\u63a7\u5236\u8bbe\u7f6e\u548c\u540c\u6b65\u4e0a\u7684\u5f00\u9500\u663e\u8457\u4e0a\u5347\uff0c\u5bfc\u81f4\u7cfb\u7edf\u6027\u80fd\u53d7\u9650\u4e8e\u914d\u7f6e\u8fc7\u7a0b\uff0c\u5f62\u6210\u6240\u8c13\u7684\u201c\u914d\u7f6e\u5899\u201d\u3002\u73b0\u6709\u65b9\u6848\u7f3a\u4e4f\u666e\u9002\u6027\u4e14\u672a\u80fd\u6df1\u5165\u63ed\u793a\u6027\u80fd\u4e0b\u964d\u7684\u6839\u672c\u539f\u56e0\u3002", "method": "\u4f5c\u8005\u9996\u5148\u63d0\u51fa\u4e00\u79cd\u9002\u7528\u4e8e\u5e7f\u6cdb\u573a\u666f\u7684roofline\u6a21\u578b\u53d8\u4f53\uff0c\u7528\u4e8e\u91cf\u5316\u7cfb\u7edf\u662f\u5426\u5904\u4e8e\u914d\u7f6e\u53d7\u9650\u72b6\u6001\uff1b\u968f\u540e\u8bbe\u8ba1\u4e86\u4e00\u79cd\u9886\u57df\u7279\u5b9a\u7684\u7f16\u8bd1\u5668\u62bd\u8c61\u53ca\u914d\u5957\u4f18\u5316\u6d41\u7a0b\uff0c\u5e76\u5728MLIR\u7f16\u8bd1\u5668\u6846\u67b6\u4e2d\u5b9e\u73b0\uff0c\u4ee5\u81ea\u52a8\u751f\u6210\u9ad8\u6548\u4ee3\u7801\u3002", "result": "\u5728\u5f00\u6e90\u7684OpenGeMM\u7cfb\u7edf\u4e0a\u5b9e\u9a8c\u8868\u660e\uff0c\u8be5\u65b9\u6cd5\u901a\u8fc7\u6d88\u9664\u5197\u4f59\u914d\u7f6e\u5468\u671f\u5e76\u81ea\u52a8\u9690\u85cf\u5269\u4f59\u914d\u7f6e\u5f00\u9500\uff0c\u5b9e\u73b0\u4e862\u500d\u7684\u51e0\u4f55\u5e73\u5747\u6027\u80fd\u63d0\u5347\u3002", "conclusion": "\u672c\u7814\u7a76\u63ed\u793a\u4e86\u52a0\u901f\u5668\u6027\u80fd\u53d7\u914d\u7f6e\u673a\u5236\u5f71\u54cd\u7684\u5173\u952e\u673a\u7406\uff0c\u4e3a\u7ed5\u8fc7\u201c\u914d\u7f6e\u5899\u201d\u63d0\u4f9b\u4e86\u901a\u7528\u4e14\u81ea\u52a8\u5316\u7684\u7f16\u8bd1\u5668\u89e3\u51b3\u65b9\u6848\uff0c\u5177\u6709\u826f\u597d\u7684\u6709\u6548\u6027\u4e0e\u666e\u9002\u6027\u3002"}}
{"id": "2511.09794", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.09794", "abs": "https://arxiv.org/abs/2511.09794", "authors": ["Wasique Islam Shafin", "Md Nakhla Rafi", "Zhenhao Li", "Tse-Hsun Chen"], "title": "Evaluating Software Process Models for Multi-Agent Class-Level Code Generation", "comment": null, "summary": "Modern software systems require code that is not only functional but also maintainable and well-structured. Although Large Language Models (LLMs) are increasingly used to automate software development, most studies focus on isolated, single-agent function-level generation. This work examines how process structure and role specialization shape multi-agent LLM workflows for class-level code generation. We simulate a Waterfall-style development cycle covering Requirement, Design, Implementation, and Testing using three LLMs (GPT-4o-mini, DeepSeek-Chat, and Claude-3.5-Haiku) on 100 Python tasks from the ClassEval benchmark. Our findings show that multi-agent workflows reorganize, rather than consistently enhance, model performance. Waterfall-style collaboration produces cleaner and more maintainable code but often reduces functional correctness (-37.8\\% for GPT-4o-mini and -39.8\\% for DeepSeek-Chat), with Claude-3.5-Haiku as a notable exception (+9.5\\%). Importantly, process constraints shift failure characteristics: structural issues such as missing code decrease, while semantic and validation errors become more frequent. Among all stages, Testing exerts the strongest influence by improving verification coverage but also introducing new reasoning failures, whereas Requirement and Design have comparatively modest effects. Overall, this study provides empirical evidence that software process structure fundamentally alters how LLMs reason, collaborate, and fail, revealing inherent trade-offs between rigid workflow discipline and flexible problem-solving in multi-agent code generation.", "AI": {"tldr": "\u8be5\u7814\u7a76\u63a2\u8ba8\u4e86\u591a\u667a\u80fd\u4f53\u5927\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u5728\u7c7b\u7ea7\u4ee3\u7801\u751f\u6210\u4e2d\u5982\u4f55\u53d7\u8f6f\u4ef6\u5f00\u53d1\u6d41\u7a0b\u7ed3\u6784\u548c\u89d2\u8272\u5206\u5de5\u5f71\u54cd\uff0c\u53d1\u73b0\u7011\u5e03\u5f0f\u534f\u4f5c\u867d\u63d0\u5347\u4ee3\u7801\u53ef\u7ef4\u62a4\u6027\uff0c\u4f46\u901a\u5e38\u964d\u4f4e\u529f\u80fd\u6b63\u786e\u6027\uff0c\u5e76\u6539\u53d8\u9519\u8bef\u7c7b\u578b\u5206\u5e03\u3002", "motivation": "\u73b0\u6709\u7814\u7a76\u591a\u5173\u6ce8\u5355\u667a\u80fd\u4f53\u3001\u51fd\u6570\u7ea7\u4ee3\u7801\u751f\u6210\uff0c\u7f3a\u4e4f\u5bf9\u591a\u667a\u80fd\u4f53\u534f\u4f5c\u4e0b\u8f6f\u4ef6\u8fc7\u7a0b\u7ed3\u6784\uff08\u5982\u9700\u6c42\u3001\u8bbe\u8ba1\u3001\u5b9e\u73b0\u3001\u6d4b\u8bd5\u9636\u6bb5\uff09\u5982\u4f55\u5f71\u54cdLLM\u4ee3\u7801\u751f\u6210\u8d28\u91cf\u7684\u7406\u89e3\u3002", "method": "\u5728ClassEval\u57fa\u51c6\u7684100\u4e2aPython\u4efb\u52a1\u4e0a\uff0c\u4f7f\u7528GPT-4o-mini\u3001DeepSeek-Chat\u548cClaude-3.5-Haiku\u4e09\u4e2aLLM\uff0c\u6a21\u62df\u7011\u5e03\u5f0f\u5f00\u53d1\u6d41\u7a0b\uff08\u9700\u6c42\u3001\u8bbe\u8ba1\u3001\u5b9e\u73b0\u3001\u6d4b\u8bd5\uff09\u8fdb\u884c\u591a\u667a\u80fd\u4f53\u534f\u4f5c\u5b9e\u9a8c\u3002", "result": "\u7011\u5e03\u5f0f\u591a\u667a\u80fd\u4f53\u5de5\u4f5c\u6d41\u63d0\u5347\u4e86\u4ee3\u7801\u7684\u7ed3\u6784\u6027\u4e0e\u53ef\u7ef4\u62a4\u6027\uff0c\u4f46\u591a\u6570\u6a21\u578b\u529f\u80fd\u6b63\u786e\u6027\u663e\u8457\u4e0b\u964d\uff08GPT-4o-mini -37.8%\uff0cDeepSeek-Chat -39.8%\uff09\uff0c\u4ec5Claude-3.5-Haiku\u63d0\u53479.5%\uff1b\u9519\u8bef\u7c7b\u578b\u4ece\u7ed3\u6784\u6027\u7f3a\u5931\u8f6c\u5411\u8bed\u4e49\u4e0e\u9a8c\u8bc1\u9519\u8bef\uff1b\u6d4b\u8bd5\u9636\u6bb5\u5bf9\u7ed3\u679c\u5f71\u54cd\u6700\u5927\u3002", "conclusion": "\u8f6f\u4ef6\u8fc7\u7a0b\u7ed3\u6784\u6df1\u523b\u5f71\u54cd\u591a\u667a\u80fd\u4f53LLM\u7684\u63a8\u7406\u3001\u534f\u4f5c\u4e0e\u5931\u8d25\u6a21\u5f0f\uff0c\u5728\u6d41\u7a0b\u7eaa\u5f8b\u6027\u4e0e\u7075\u6d3b\u95ee\u9898\u89e3\u51b3\u4e4b\u95f4\u5b58\u5728\u56fa\u6709\u6743\u8861\uff0c\u9700\u8c28\u614e\u8bbe\u8ba1\u591a\u667a\u80fd\u4f53\u534f\u4f5c\u673a\u5236\u4ee5\u5e73\u8861\u4ee3\u7801\u8d28\u91cf\u7ef4\u5ea6\u3002"}}
{"id": "2511.10283", "categories": ["cs.MA"], "pdf": "https://arxiv.org/pdf/2511.10283", "abs": "https://arxiv.org/abs/2511.10283", "authors": ["Won Ik Cho", "Woonghee Han", "Kyung Seo Ki", "Young Min Kim"], "title": "Behavior Modeling for Training-free Building of Private Domain Multi Agent System", "comment": "10 pages, 1 figure, 2 tables", "summary": "The rise of agentic systems that combine orchestration, tool use, and conversational capabilities, has been more visible by the recent advent of large language models (LLMs). While open-domain frameworks exist, applying them in private domains remains difficult due to heterogeneous tool formats, domain-specific jargon, restricted accessibility of APIs, and complex governance. Conventional solutions, such as fine-tuning on synthetic dialogue data, are burdensome and brittle under domain shifts, and risk degrading general performance. In this light, we introduce a framework for private-domain multi-agent conversational systems that avoids training and data generation by adopting behavior modeling and documentation. Our design simply assumes an orchestrator, a tool-calling agent, and a general chat agent, with tool integration defined through structured specifications and domain-informed instructions. This approach enables scalable adaptation to private tools and evolving contexts without continual retraining. The framework supports practical use cases, including lightweight deployment of multi-agent systems, leveraging API specifications as retrieval resources, and generating synthetic dialogue for evaluation -- providing a sustainable method for aligning agent behavior with domain expertise in private conversational ecosystems.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u65e0\u9700\u8bad\u7ec3\u548c\u6570\u636e\u751f\u6210\u7684\u79c1\u6709\u9886\u57df\u591a\u667a\u80fd\u4f53\u5bf9\u8bdd\u7cfb\u7edf\u6846\u67b6\uff0c\u901a\u8fc7\u884c\u4e3a\u5efa\u6a21\u4e0e\u6587\u6863\u9a71\u52a8\u7684\u65b9\u5f0f\uff0c\u5b9e\u73b0\u5bf9\u79c1\u6709\u5de5\u5177\u548c\u52a8\u6001\u4e0a\u4e0b\u6587\u7684\u53ef\u6269\u5c55\u9002\u914d\u3002", "motivation": "\u5728\u79c1\u6709\u9886\u57df\u90e8\u7f72\u57fa\u4e8e\u5927\u8bed\u8a00\u6a21\u578b\u7684\u667a\u80fd\u4f53\u7cfb\u7edf\u9762\u4e34\u5de5\u5177\u683c\u5f0f\u5f02\u6784\u3001\u9886\u57df\u672f\u8bed\u590d\u6742\u3001API\u8bbf\u95ee\u53d7\u9650\u53ca\u6cbb\u7406\u56f0\u96be\u7b49\u6311\u6218\uff0c\u800c\u4f20\u7edf\u4f9d\u8d56\u5fae\u8c03\u548c\u5408\u6210\u6570\u636e\u7684\u65b9\u6cd5\u6210\u672c\u9ad8\u3001\u6cdb\u5316\u5dee\u4e14\u6613\u635f\u5bb3\u901a\u7528\u6027\u80fd\u3002", "method": "\u8be5\u6846\u67b6\u91c7\u7528\u884c\u4e3a\u5efa\u6a21\u4e0e\u6587\u6863\u9a71\u52a8\u7b56\u7565\uff0c\u4ec5\u5305\u542b\u534f\u8c03\u5668\u3001\u5de5\u5177\u8c03\u7528\u667a\u80fd\u4f53\u548c\u901a\u7528\u804a\u5929\u667a\u80fd\u4f53\uff0c\u901a\u8fc7\u7ed3\u6784\u5316\u5de5\u5177\u89c4\u8303\u548c\u9886\u57df\u6307\u5bfc\u6307\u4ee4\u96c6\u6210\u5de5\u5177\uff0c\u907f\u514d\u4e86\u6301\u7eed\u8bad\u7ec3\u548c\u6570\u636e\u751f\u6210\u3002", "result": "\u8be5\u65b9\u6cd5\u652f\u6301\u8f7b\u91cf\u7ea7\u591a\u667a\u80fd\u4f53\u90e8\u7f72\u3001\u5229\u7528API\u89c4\u8303\u4f5c\u4e3a\u68c0\u7d22\u8d44\u6e90\uff0c\u5e76\u53ef\u751f\u6210\u7528\u4e8e\u8bc4\u4f30\u7684\u5408\u6210\u5bf9\u8bdd\uff0c\u5728\u79c1\u6709\u5bf9\u8bdd\u751f\u6001\u4e2d\u53ef\u6301\u7eed\u5730\u5bf9\u9f50\u667a\u80fd\u4f53\u884c\u4e3a\u4e0e\u9886\u57df\u77e5\u8bc6\u3002", "conclusion": "\u6240\u63d0\u6846\u67b6\u4e3a\u79c1\u6709\u9886\u57df\u591a\u667a\u80fd\u4f53\u7cfb\u7edf\u63d0\u4f9b\u4e86\u4e00\u79cd\u9ad8\u6548\u3001\u53ef\u6269\u5c55\u4e14\u65e0\u9700\u8bad\u7ec3\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u6709\u6548\u5e94\u5bf9\u4e86\u5de5\u5177\u96c6\u6210\u4e0e\u9886\u57df\u9002\u914d\u7684\u73b0\u5b9e\u6311\u6218\u3002"}}
{"id": "2511.09964", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2511.09964", "abs": "https://arxiv.org/abs/2511.09964", "authors": ["Noah van der Vleuten", "Anthony Flores", "Shray Mathur", "Max Rakitin", "Thomas Hopkins", "Kevin G. Yager", "Esther H. R. Tsai"], "title": "EnvTrace: Simulation-Based Semantic Evaluation of LLM Code via Execution Trace Alignment -- Demonstrated at Synchrotron Beamlines", "comment": null, "summary": "Evaluating large language models (LLMs) for instrument control requires methods that go beyond standard, stateless algorithmic benchmarks, since the behavior of physical systems cannot be fully captured by unit tests alone. Here we introduce EnvTrace, a simulation-based method that evaluates execution traces to assess semantic code equivalence. EnvTrace is demonstrated with a beamline control-logic digital twin to facilitate the evaluation of instrument control code, with the digital twin itself also enabling the pre-execution validation of live experiments. Over 30 LLMs were evaluated using trace alignment to generate a multi-faceted score for functional correctness across key behavioral dimensions, showing that many top-tier models can approach human-level performance in rapid control-code generation. This is a first step toward a broader vision where LLMs and digital twins work symbiotically: LLMs providing intuitive control and agentic orchestration, and digital twins offering safe and high-fidelity environments, paving the way towards autonomous embodied AI.", "AI": {"tldr": "\u672c\u6587\u63d0\u51faEnvTrace\u65b9\u6cd5\uff0c\u901a\u8fc7\u57fa\u4e8e\u4eff\u771f\u7684\u6267\u884c\u8f68\u8ff9\u8bc4\u4f30\u8bed\u4e49\u4ee3\u7801\u7b49\u4ef7\u6027\uff0c\u7528\u4e8e\u8bc4\u6d4b\u5927\u8bed\u8a00\u6a21\u578b\u5728\u4eea\u5668\u63a7\u5236\u4efb\u52a1\u4e2d\u7684\u8868\u73b0\uff0c\u5e76\u7ed3\u5408\u6570\u5b57\u5b6a\u751f\u5b9e\u73b0\u5b89\u5168\u9ad8\u6548\u7684\u63a7\u5236\u4ee3\u7801\u9a8c\u8bc1\u3002", "motivation": "\u6807\u51c6\u7684\u65e0\u72b6\u6001\u7b97\u6cd5\u57fa\u51c6\u65e0\u6cd5\u5145\u5206\u8bc4\u4f30\u5927\u8bed\u8a00\u6a21\u578b\u5728\u7269\u7406\u7cfb\u7edf\u63a7\u5236\u4efb\u52a1\u4e2d\u7684\u884c\u4e3a\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u79cd\u80fd\u6355\u6349\u7cfb\u7edf\u52a8\u6001\u884c\u4e3a\u7684\u8bc4\u6d4b\u65b9\u6cd5\u3002", "method": "\u63d0\u51faEnvTrace\u65b9\u6cd5\uff0c\u5229\u7528\u6570\u5b57\u5b6a\u751f\u4eff\u771f\u73af\u5883\u5bf9\u6a21\u578b\u751f\u6210\u7684\u63a7\u5236\u4ee3\u7801\u6267\u884c\u8f68\u8ff9\u8fdb\u884c\u6bd4\u5bf9\uff0c\u901a\u8fc7\u8f68\u8ff9\u5bf9\u9f50\u4ece\u591a\u4e2a\u884c\u4e3a\u7ef4\u5ea6\u8bc4\u4f30\u529f\u80fd\u6b63\u786e\u6027\u3002", "result": "\u5bf930\u591a\u4e2a\u5927\u8bed\u8a00\u6a21\u578b\u7684\u8bc4\u4f30\u8868\u660e\uff0c\u90e8\u5206\u9876\u5c16\u6a21\u578b\u5728\u5feb\u901f\u751f\u6210\u4eea\u5668\u63a7\u5236\u4ee3\u7801\u65b9\u9762\u5df2\u63a5\u8fd1\u4eba\u7c7b\u6c34\u5e73\u3002", "conclusion": "\u8be5\u7814\u7a76\u4e3a\u5927\u8bed\u8a00\u6a21\u578b\u4e0e\u6570\u5b57\u5b6a\u751f\u534f\u540c\u6784\u5efa\u81ea\u4e3b\u5177\u8eab\u667a\u80fd\u7cfb\u7edf\u5960\u5b9a\u4e86\u57fa\u7840\uff0c\u5176\u4e2d\u5927\u6a21\u578b\u63d0\u4f9b\u76f4\u89c2\u63a7\u5236\u4e0e\u667a\u80fd\u7f16\u6392\uff0c\u6570\u5b57\u5b6a\u751f\u63d0\u4f9b\u9ad8\u4fdd\u771f\u3001\u5b89\u5168\u7684\u9a8c\u8bc1\u73af\u5883\u3002"}}
{"id": "2511.09837", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.09837", "abs": "https://arxiv.org/abs/2511.09837", "authors": ["Lu Zhao", "Rong Shi", "Shaoqing Zhang", "Shangchao Su", "Ziqing Yin", "Zhiyan Cui", "Hongfeng Sun", "Baoguo He", "Yueqiang Chen", "Liang Dong", "Xiyuan Li", "Lingbin Wang", "Lijun Ma", "Qiang Huang", "Ting Liu", "Chong Wang", "Can Wei"], "title": "MoFa: A Unified Performance Modeling Framework for LLM Pretraining", "comment": null, "summary": "The exponential growth in LLM scales, with parameters soaring from billions to trillions, has necessitated distributed pretraining across large clusters comprising thousands to tens of thousands of devices. While hybrid parallelization strategies enable such pretraining, the vast combinatorial strategy space introduces significant optimization challenges. Traditional manual tuning methods incur prohibitive trial-and-error costs, and existing performance modeling approaches exhibit critical limitations: they fail to comprehensively account for prevalent optimization features and ignore the substantial overhead imposed by essential fault tolerance mechanisms like checkpoint recovery in long-duration pretraining. To address these gaps, we propose MoFa, a novel pretraining performance modeling framework that unifies multi-dimensional optimization features and fault tolerance. MoFa incorporates an enhanced cost model to accurately capture the effects of key optimizations and integrates a fault tolerance model based on historical cluster reliability data. Besides, a MoFa-based tuning system is developed to explore optimal pretraining performance and potential bottlenecks in various scenarios. Extensive modeling evaluations demonstrate that MoFa can achieve high prediction accuracy across various scenarios. In addition, through comprehensive tuning experiments, our framework systematically reveals the key factors influencing pretraining performance under different configurations, which provides solid a priori guidance for LLM pretraining system design and deployment.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86MoFa\uff0c\u4e00\u79cd\u878d\u5408\u591a\u7ef4\u4f18\u5316\u7279\u5f81\u4e0e\u5bb9\u9519\u673a\u5236\u7684\u5927\u6a21\u578b\u9884\u8bad\u7ec3\u6027\u80fd\u5efa\u6a21\u6846\u67b6\uff0c\u663e\u8457\u63d0\u5347\u4e86\u9884\u6d4b\u51c6\u786e\u6027\uff0c\u5e76\u4e3a\u7cfb\u7edf\u8bbe\u8ba1\u63d0\u4f9b\u5148\u9a8c\u6307\u5bfc\u3002", "motivation": "\u968f\u7740\u5927\u8bed\u8a00\u6a21\u578b\u53c2\u6570\u89c4\u6a21\u6fc0\u589e\u81f3\u4e07\u4ebf\u7ea7\u522b\uff0c\u9884\u8bad\u7ec3\u9700\u5728\u6570\u5343\u81f3\u4e0a\u4e07\u8bbe\u5907\u7ec4\u6210\u7684\u96c6\u7fa4\u4e0a\u8fdb\u884c\u5206\u5e03\u5f0f\u8ba1\u7b97\u3002\u73b0\u6709\u6027\u80fd\u5efa\u6a21\u65b9\u6cd5\u672a\u80fd\u5168\u9762\u8003\u8651\u4e3b\u6d41\u4f18\u5316\u6280\u672f\uff0c\u4e14\u5ffd\u7565\u4e86\u957f\u671f\u8bad\u7ec3\u4e2d\u5bb9\u9519\u673a\u5236\uff08\u5982\u68c0\u67e5\u70b9\u6062\u590d\uff09\u5e26\u6765\u7684\u663e\u8457\u5f00\u9500\uff0c\u5bfc\u81f4\u8c03\u4f18\u6210\u672c\u9ad8\u6602\u3002", "method": "\u63d0\u51faMoFa\u6846\u67b6\uff0c\u5305\u542b\u589e\u5f3a\u7684\u6210\u672c\u6a21\u578b\u4ee5\u7cbe\u786e\u523b\u753b\u5173\u952e\u4f18\u5316\u6548\u679c\uff0c\u5e76\u57fa\u4e8e\u5386\u53f2\u96c6\u7fa4\u53ef\u9760\u6027\u6570\u636e\u6784\u5efa\u5bb9\u9519\u6a21\u578b\uff1b\u540c\u65f6\u5f00\u53d1\u4e86\u57fa\u4e8eMoFa\u7684\u8c03\u4f18\u7cfb\u7edf\uff0c\u7528\u4e8e\u63a2\u7d22\u4e0d\u540c\u573a\u666f\u4e0b\u7684\u6700\u4f18\u9884\u8bad\u7ec3\u6027\u80fd\u548c\u6f5c\u5728\u74f6\u9888\u3002", "result": "\u5927\u91cf\u5b9e\u9a8c\u8868\u660e\uff0cMoFa\u5728\u591a\u79cd\u573a\u666f\u4e0b\u5747\u80fd\u5b9e\u73b0\u9ad8\u7cbe\u5ea6\u6027\u80fd\u9884\u6d4b\uff1b\u8c03\u4f18\u5b9e\u9a8c\u7cfb\u7edf\u6027\u63ed\u793a\u4e86\u4e0d\u540c\u914d\u7f6e\u4e0b\u5f71\u54cd\u9884\u8bad\u7ec3\u6027\u80fd\u7684\u5173\u952e\u56e0\u7d20\u3002", "conclusion": "MoFa\u6709\u6548\u89e3\u51b3\u4e86\u73b0\u6709\u5efa\u6a21\u65b9\u6cd5\u5ffd\u7565\u4f18\u5316\u7279\u5f81\u4e0e\u5bb9\u9519\u5f00\u9500\u7684\u95ee\u9898\uff0c\u4e3a\u5927\u6a21\u578b\u9884\u8bad\u7ec3\u7cfb\u7edf\u7684\u9ad8\u6548\u8bbe\u8ba1\u4e0e\u90e8\u7f72\u63d0\u4f9b\u4e86\u53ef\u9760\u7684\u5148\u9a8c\u6307\u5bfc\u3002"}}
{"id": "2511.10049", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.10049", "abs": "https://arxiv.org/abs/2511.10049", "authors": ["Divyanshu Saxena", "Rishikesh Maurya", "Xiaoxuan Ou", "Gagan Somashekar", "Shachee Mishra Gupta", "Arun Iyer", "Yu Kang", "Chetan Bansal", "Aditya Akella", "Saravan Rajmohan"], "title": "Continuous Benchmark Generation for Evaluating Enterprise-scale LLM Agents", "comment": "5 pages", "summary": "The rapid adoption of AI agents across domains has made systematic evaluation crucial for ensuring their usefulness and successful production deployment. Evaluation of AI agents typically involves using a fixed set of benchmarks and computing multiple evaluation metrics for the agent. While sufficient for simple coding tasks, these benchmarks fall short for enterprise-scale agents, where services and requirements evolve continuously and ground-truth examples are sparse. We propose a process of benchmark generation that helps evolve the benchmarks as the requirements change and perform robust evaluation of evolving AI agents. We instantiate this approach for a case study of service migration from one deployment platform to another at a large public enterprise. Our approach relies on semi-structured documents where developers express the high-level intent, and uses state-of-the-art LLMs to generate benchmarks from just a small number of such documents. Overall, this process results in a maintainable evaluation framework, enabling rapid feedback on agent performance and facilitating targeted improvements.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e00\u79cd\u52a8\u6001\u751f\u6210\u57fa\u51c6\u7684\u65b9\u6cd5\uff0c\u7528\u4e8e\u8bc4\u4f30\u5728\u4f01\u4e1a\u73af\u5883\u4e2d\u6301\u7eed\u6f14\u5316\u7684AI\u667a\u80fd\u4f53\uff0c\u901a\u8fc7\u5c11\u91cf\u534a\u7ed3\u6784\u5316\u6587\u6863\u548c\u5927\u8bed\u8a00\u6a21\u578b\u81ea\u52a8\u751f\u6210\u53ef\u7ef4\u62a4\u7684\u8bc4\u4f30\u57fa\u51c6\u3002", "motivation": "\u4f20\u7edf\u56fa\u5b9a\u57fa\u51c6\u5728\u4f01\u4e1a\u7ea7AI\u667a\u80fd\u4f53\u8bc4\u4f30\u4e2d\u5b58\u5728\u4e0d\u8db3\uff0c\u96be\u4ee5\u5e94\u5bf9\u670d\u52a1\u4e0e\u9700\u6c42\u7684\u6301\u7eed\u53d8\u5316\u53ca\u771f\u5b9e\u6837\u672c\u7a00\u7f3a\u7684\u95ee\u9898\u3002", "method": "\u5229\u7528\u5f00\u53d1\u8005\u63d0\u4f9b\u7684\u5c11\u91cf\u534a\u7ed3\u6784\u5316\u6587\u6863\u8868\u8fbe\u9ad8\u5c42\u610f\u56fe\uff0c\u7ed3\u5408\u5148\u8fdb\u5927\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u81ea\u52a8\u751f\u6210\u9002\u5e94\u9700\u6c42\u53d8\u5316\u7684\u8bc4\u4f30\u57fa\u51c6\u3002", "result": "\u8be5\u65b9\u6cd5\u6784\u5efa\u4e86\u4e00\u4e2a\u53ef\u7ef4\u62a4\u7684\u8bc4\u4f30\u6846\u67b6\uff0c\u5728\u5927\u578b\u516c\u5171\u4f01\u4e1a\u7684\u670d\u52a1\u8fc1\u79fb\u6848\u4f8b\u4e2d\u5b9e\u73b0\u4e86\u5bf9AI\u667a\u80fd\u4f53\u6027\u80fd\u7684\u5feb\u901f\u53cd\u9988\u548c\u9488\u5bf9\u6027\u6539\u8fdb\u3002", "conclusion": "\u6240\u63d0\u51fa\u7684\u52a8\u6001\u57fa\u51c6\u751f\u6210\u6d41\u7a0b\u80fd\u6709\u6548\u652f\u6301\u4f01\u4e1a\u7ea7AI\u667a\u80fd\u4f53\u7684\u9c81\u68d2\u8bc4\u4f30\u4e0e\u6301\u7eed\u4f18\u5316\u3002"}}
{"id": "2511.10563", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.10563", "abs": "https://arxiv.org/abs/2511.10563", "authors": ["Seyed Hadi Mirfarshbafan", "Christoph Studer"], "title": "Beamspace Equalization for mmWave Massive MIMO: Algorithms and VLSI Implementations", "comment": "14 pages", "summary": "Massive multiuser multiple-input multiple-output (MIMO) and millimeter-wave (mmWave) communication are key physical layer technologies in future wireless systems. Their deployment, however, is expected to incur excessive baseband processing hardware cost and power consumption. Beamspace processing leverages the channel sparsity at mmWave frequencies to reduce baseband processing complexity. In this paper, we review existing beamspace data detection algorithms and propose new algorithms as well as corresponding VLSI architectures that reduce data detection power. We present VLSI implementation results for the proposed architectures in a 22nm FDSOI process. Our results demonstrate that a fully-parallelized implementation of the proposed complex sparsity-adaptive equalizer (CSPADE) achieves up to 54% power savings compared to antenna-domain equalization. Furthermore, our fully-parallelized designs achieve the highest reported throughput among existing massive MIMO data detectors, while achieving better energy and area efficiency. We also present a sequential multiply-accumulate (MAC)-based architecture for CSPADE, which enables even higher power savings, i.e., up to 66%, compared to a MAC-based antenna-domain equalizer.", "AI": {"tldr": "\u672c\u6587\u7814\u7a76\u4e86\u9762\u5411\u6beb\u7c73\u6ce2\u5927\u89c4\u6a21MIMO\u7cfb\u7edf\u7684\u6ce2\u675f\u57df\u6570\u636e\u68c0\u6d4b\u7b97\u6cd5\u4e0eVLSI\u67b6\u6784\uff0c\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u578b\u590d\u7a00\u758f\u81ea\u9002\u5e94\u5747\u8861\u5668\uff08CSPADE\uff09\uff0c\u572822nm\u5de5\u827a\u4e0b\u5b9e\u73b0\u663e\u8457\u7684\u529f\u8017\u3001\u80fd\u6548\u4e0e\u9762\u79ef\u4f18\u52bf\uff0c\u5e76\u8fbe\u5230\u5f53\u524d\u6700\u9ad8\u7684\u541e\u5410\u91cf\u3002", "motivation": "\u5927\u89c4\u6a21\u591a\u7528\u6237MIMO\u548c\u6beb\u7c73\u6ce2\u901a\u4fe1\u867d\u662f\u672a\u6765\u65e0\u7ebf\u7cfb\u7edf\u7684\u5173\u952e\u6280\u672f\uff0c\u4f46\u5176\u57fa\u5e26\u5904\u7406\u786c\u4ef6\u6210\u672c\u548c\u529f\u8017\u8fc7\u9ad8\uff1b\u5229\u7528\u6beb\u7c73\u6ce2\u4fe1\u9053\u7a00\u758f\u6027\u8fdb\u884c\u6ce2\u675f\u57df\u5904\u7406\u53ef\u964d\u4f4e\u590d\u6742\u5ea6\uff0c\u56e0\u6b64\u9700\u5f00\u53d1\u9ad8\u6548\u7684\u6570\u636e\u68c0\u6d4b\u7b97\u6cd5\u4e0e\u4f4e\u529f\u8017VLSI\u67b6\u6784\u3002", "method": "\u63d0\u51fa\u65b0\u7684\u6ce2\u675f\u57df\u6570\u636e\u68c0\u6d4b\u7b97\u6cd5CSPADE\uff0c\u5e76\u8bbe\u8ba1\u5bf9\u5e94\u7684\u5168\u5e76\u884c\u4e0e\u57fa\u4e8eMAC\u7684\u4e32\u884cVLSI\u67b6\u6784\uff0c\u572822nm FDSOI\u5de5\u827a\u4e0b\u8fdb\u884c\u5b9e\u73b0\u4e0e\u8bc4\u4f30\u3002", "result": "\u5168\u5e76\u884cCSPADE\u67b6\u6784\u76f8\u6bd4\u5929\u7ebf\u57df\u5747\u8861\u5668\u6700\u591a\u8282\u770154%\u529f\u8017\uff0c\u4e14\u5728\u73b0\u6709\u5927\u89c4\u6a21MIMO\u68c0\u6d4b\u5668\u4e2d\u541e\u5410\u91cf\u6700\u9ad8\u3001\u80fd\u6548\u4e0e\u9762\u79ef\u6548\u7387\u66f4\u4f18\uff1b\u57fa\u4e8eMAC\u7684\u4e32\u884c\u67b6\u6784\u5219\u6700\u591a\u8282\u770166%\u529f\u8017\u3002", "conclusion": "\u6240\u63d0\u51fa\u7684CSPADE\u7b97\u6cd5\u53ca\u5176VLSI\u67b6\u6784\u5728\u529f\u8017\u3001\u541e\u5410\u91cf\u3001\u80fd\u6548\u548c\u9762\u79ef\u65b9\u9762\u5747\u4f18\u4e8e\u73b0\u6709\u65b9\u6848\uff0c\u4e3a\u6beb\u7c73\u6ce2\u5927\u89c4\u6a21MIMO\u7cfb\u7edf\u63d0\u4f9b\u4e86\u9ad8\u6548\u53ef\u884c\u7684\u57fa\u5e26\u5904\u7406\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2511.09861", "categories": ["cs.DC", "cs.AR"], "pdf": "https://arxiv.org/pdf/2511.09861", "abs": "https://arxiv.org/abs/2511.09861", "authors": ["Marco Kurzynski", "Shaizeen Aga", "Di Wu"], "title": "Lit Silicon: A Case Where Thermal Imbalance Couples Concurrent Execution in Multiple GPUs", "comment": null, "summary": "GPU systems are increasingly powering modern datacenters at scale. Despite being highly performant, GPU systems suffer from performance variation at the node and cluster levels. Such performance variation significantly impacts both high-performance computing and artificial intelligence workloads, such as cutting-edge large language models (LLMs). We analyze the performance of a single-node multi-GPU system running LLM training, and observe that the kernel-level performance variation is highly correlated with concurrent computation communication (C3), a technique to overlap computation and communication across GPUs for performance gains. We then take a further step to reason that thermally induced straggling coupling with C3 impacts performance variation, coined as the Lit Silicon effect. Lit Silicon describes that in a multi-GPU node, thermal imbalance across GPUs introduces node-level straggler GPUs, which in turn slow down the leader GPUs. Lit Silicon leads to node-level performance variation and inefficiency, impacting the entire datacenter from the bottom up. We propose analytical performance and power models for Lit Silicon, to understand the potential system-level gains. We further design simple detection and mitigation techniques to effectively address the Lit Silicon problem, and evaluate three different power management solutions, including power optimization under GPU thermal design power, performance optimization under node-level GPU power capping, and performance optimization under node-level CPU power sloshing. We conduct experiments on two workloads on two AMD InstinctTM MI300X GPU systems under two LLM training frameworks, and observe up to 6% performance and 4% power improvements, potentially saving hundreds of millions of dollars in datacenters. Our solution is almost free lunch and can be effortlessly adopted in datacenters as a new node-level power management layer.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63ed\u793a\u4e86\u591aGPU\u7cfb\u7edf\u4e2d\u7531\u70ed\u4e0d\u5e73\u8861\u5f15\u53d1\u7684\u201cLit Silicon\u6548\u5e94\u201d\u2014\u2014\u5373\u70ed\u8026\u5408\u5bfc\u81f4\u7684GPU\u6027\u80fd\u5dee\u5f02\u4f1a\u901a\u8fc7\u8ba1\u7b97\u901a\u4fe1\u91cd\u53e0\uff08C3\uff09\u673a\u5236\u653e\u5927\uff0c\u9020\u6210\u8282\u70b9\u7ea7\u6027\u80fd\u4e0b\u964d\uff1b\u4f5c\u8005\u63d0\u51fa\u4e86\u5206\u6790\u6a21\u578b\u4e0e\u8f7b\u91cf\u7ea7\u68c0\u6d4b\u7f13\u89e3\u65b9\u6848\uff0c\u5728AMD MI300X\u7cfb\u7edf\u4e0a\u5b9e\u73b0\u4e86\u6700\u9ad86%\u7684\u6027\u80fd\u63d0\u5347\u548c4%\u7684\u529f\u8017\u964d\u4f4e\u3002", "motivation": "\u73b0\u4ee3\u6570\u636e\u4e2d\u5fc3\u5e7f\u6cdb\u91c7\u7528GPU\u7cfb\u7edf\uff0c\u4f46\u5176\u5728\u8282\u70b9\u548c\u96c6\u7fa4\u5c42\u9762\u5b58\u5728\u663e\u8457\u6027\u80fd\u6ce2\u52a8\uff0c\u5c24\u5176\u5f71\u54cd\u5927\u8bed\u8a00\u6a21\u578b\u7b49AI\u5de5\u4f5c\u8d1f\u8f7d\u3002\u73b0\u6709\u7814\u7a76\u672a\u5145\u5206\u5173\u6ce8\u70ed\u6548\u5e94\u5bf9\u591aGPU\u534f\u540c\u6027\u80fd\u7684\u5f71\u54cd\uff0c\u56e0\u6b64\u9700\u8981\u6df1\u5165\u5206\u6790\u5e76\u89e3\u51b3\u8fd9\u4e00\u95ee\u9898\u3002", "method": "\u4f5c\u8005\u9996\u5148\u5206\u6790\u5355\u8282\u70b9\u591aGPU\u7cfb\u7edf\u5728LLM\u8bad\u7ec3\u4e2d\u7684\u5185\u6838\u7ea7\u6027\u80fd\u53d8\u5316\uff0c\u53d1\u73b0\u5176\u4e0e\u8ba1\u7b97\u901a\u4fe1\u91cd\u53e0\uff08C3\uff09\u5bc6\u5207\u76f8\u5173\uff1b\u8fdb\u800c\u63d0\u51fa\u201cLit Silicon\u6548\u5e94\u201d\u6982\u5ff5\uff0c\u5e76\u6784\u5efa\u6027\u80fd\u4e0e\u529f\u8017\u5206\u6790\u6a21\u578b\uff1b\u6700\u540e\u8bbe\u8ba1\u4e86\u4e09\u79cd\u57fa\u4e8e\u529f\u7387\u7ba1\u7406\u7684\u7f13\u89e3\u7b56\u7565\uff1aGPU\u70ed\u8bbe\u8ba1\u529f\u8017\u4e0b\u7684\u529f\u8017\u4f18\u5316\u3001\u8282\u70b9\u7ea7GPU\u529f\u8017\u9650\u5236\u4e0b\u7684\u6027\u80fd\u4f18\u5316\uff0c\u4ee5\u53ca\u8282\u70b9\u7ea7CPU\u529f\u8017\u8f6c\u79fb\u4e0b\u7684\u6027\u80fd\u4f18\u5316\u3002", "result": "\u5728\u4e24\u4e2aAMD Instinct\u2122 MI300X GPU\u7cfb\u7edf\u4e0a\uff0c\u4f7f\u7528\u4e24\u79cdLLM\u8bad\u7ec3\u6846\u67b6\u8fdb\u884c\u5b9e\u9a8c\uff0c\u7ed3\u679c\u8868\u660e\u6240\u63d0\u65b9\u6cd5\u53ef\u5b9e\u73b0\u6700\u9ad86%\u7684\u6027\u80fd\u63d0\u5347\u548c4%\u7684\u529f\u8017\u964d\u4f4e\uff0c\u5177\u5907\u5927\u89c4\u6a21\u6570\u636e\u4e2d\u5fc3\u90e8\u7f72\u6f5c\u529b\u3002", "conclusion": "Lit Silicon\u6548\u5e94\u662f\u591aGPU\u7cfb\u7edf\u4e2d\u4e0d\u53ef\u5ffd\u89c6\u7684\u6027\u80fd\u74f6\u9888\uff0c\u901a\u8fc7\u5f15\u5165\u8f7b\u91cf\u7ea7\u7684\u8282\u70b9\u7ea7\u529f\u8017\u7ba1\u7406\u673a\u5236\uff0c\u53ef\u5728\u51e0\u4e4e\u65e0\u989d\u5916\u5f00\u9500\u7684\u60c5\u51b5\u4e0b\u663e\u8457\u63d0\u5347\u7cfb\u7edf\u6548\u7387\uff0c\u5177\u6709\u91cd\u8981\u7684\u5b9e\u9645\u5e94\u7528\u4ef7\u503c\u3002"}}
{"id": "2511.10271", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.10271", "abs": "https://arxiv.org/abs/2511.10271", "authors": ["Xin Sun", "Daniel St\u00e5hl", "Kristian Sandahl", "Christoph Kessler"], "title": "Quality Assurance of LLM-generated Code: Addressing Non-Functional Quality Characteristics", "comment": null, "summary": "In recent years, LLMs have been widely integrated into software engineering workflows, supporting tasks like code generation. However, while these models often generate functionally correct outputs, we still lack a systematic understanding and evaluation of their non-functional qualities. Existing studies focus mainly on whether generated code passes the tests rather than whether it passes with quality. Guided by the ISO/IEC 25010 quality model, this study conducted three complementary investigations: a systematic review of 108 papers, two industry workshops with practitioners from multiple organizations, and an empirical analysis of patching real-world software issues using three LLMs. Motivated by insights from both the literature and practitioners, the empirical study examined the quality of generated patches on security, maintainability, and performance efficiency. Across the literature, we found that security and performance efficiency dominate academic attention, while maintainability and other qualities are understudied. In contrast, industry experts prioritize maintainability and readability, warning that generated code may accelerate the accumulation of technical debt. In our evaluation of functionally correct patches generated by three LLMs, improvements in one quality dimension often come at the cost of others. Runtime and memory results further show high variance across models and optimization strategies. Overall, our findings reveal a mismatch between academic focus, industry priorities, and model performance, highlighting the urgent need to integrate quality assurance mechanisms into LLM code generation pipelines to ensure that future generated code not only passes tests but truly passes with quality.", "AI": {"tldr": "\u8be5\u7814\u7a76\u57fa\u4e8eISO/IEC 25010\u8d28\u91cf\u6a21\u578b\uff0c\u901a\u8fc7\u6587\u732e\u7efc\u8ff0\u3001\u884c\u4e1a\u7814\u8ba8\u4f1a\u548c\u5b9e\u8bc1\u5206\u6790\uff0c\u63ed\u793a\u4e86\u5927\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u751f\u6210\u4ee3\u7801\u5728\u975e\u529f\u80fd\u6027\u8d28\u91cf\uff08\u5982\u5b89\u5168\u6027\u3001\u53ef\u7ef4\u62a4\u6027\u548c\u6027\u80fd\u6548\u7387\uff09\u65b9\u9762\u7684\u73b0\u72b6\u4e0e\u6311\u6218\uff0c\u53d1\u73b0\u5b66\u672f\u5173\u6ce8\u3001\u884c\u4e1a\u9700\u6c42\u4e0e\u6a21\u578b\u8868\u73b0\u4e4b\u95f4\u5b58\u5728\u9519\u4f4d\uff0c\u5e76\u547c\u5401\u5c06\u8d28\u91cf\u4fdd\u969c\u673a\u5236\u6574\u5408\u8fdbLLM\u4ee3\u7801\u751f\u6210\u6d41\u7a0b\u3002", "motivation": "\u5f53\u524d\u5bf9\u5927\u8bed\u8a00\u6a21\u578b\u751f\u6210\u4ee3\u7801\u7684\u8bc4\u4f30\u4e3b\u8981\u5173\u6ce8\u529f\u80fd\u6b63\u786e\u6027\uff08\u662f\u5426\u901a\u8fc7\u6d4b\u8bd5\uff09\uff0c\u800c\u5ffd\u89c6\u5176\u975e\u529f\u80fd\u6027\u8d28\u91cf\uff08\u5982\u53ef\u7ef4\u62a4\u6027\u3001\u5b89\u5168\u6027\u3001\u6027\u80fd\u7b49\uff09\u3002\u4e3a\u7cfb\u7edf\u7406\u89e3\u5e76\u8bc4\u4f30\u8fd9\u4e9b\u8d28\u91cf\u7ef4\u5ea6\uff0c\u4f5c\u8005\u7ed3\u5408\u5b66\u672f\u7814\u7a76\u4e0e\u5de5\u4e1a\u5b9e\u8df5\u5c55\u5f00\u7efc\u5408\u8c03\u67e5\u3002", "method": "\u7814\u7a76\u91c7\u7528\u4e09\u79cd\u4e92\u8865\u65b9\u6cd5\uff1a\uff081\uff09\u7cfb\u7edf\u7efc\u8ff0108\u7bc7\u76f8\u5173\u8bba\u6587\uff1b\uff082\uff09\u4e3e\u529e\u4e24\u573a\u6db5\u76d6\u591a\u5bb6\u673a\u6784\u4ece\u4e1a\u8005\u7684\u884c\u4e1a\u7814\u8ba8\u4f1a\uff1b\uff083\uff09\u4f7f\u7528\u4e09\u4e2aLLM\u5bf9\u771f\u5b9e\u8f6f\u4ef6\u95ee\u9898\u751f\u6210\u8865\u4e01\uff0c\u5e76\u5bf9\u5176\u5728\u5b89\u5168\u6027\u3001\u53ef\u7ef4\u62a4\u6027\u548c\u6027\u80fd\u6548\u7387\u65b9\u9762\u8fdb\u884c\u5b9e\u8bc1\u5206\u6790\u3002", "result": "\u6587\u732e\u4e2d\u5b66\u672f\u754c\u4e3b\u8981\u5173\u6ce8\u5b89\u5168\u6027\u548c\u6027\u80fd\u6548\u7387\uff0c\u800c\u53ef\u7ef4\u62a4\u6027\u7b49\u7ef4\u5ea6\u88ab\u5ffd\u89c6\uff1b\u5de5\u4e1a\u754c\u5219\u66f4\u91cd\u89c6\u53ef\u7ef4\u62a4\u6027\u4e0e\u53ef\u8bfb\u6027\uff0c\u5e76\u62c5\u5fe7\u751f\u6210\u4ee3\u7801\u52a0\u5267\u6280\u672f\u503a\u3002\u5b9e\u8bc1\u7ed3\u679c\u8868\u660e\uff0cLLM\u751f\u6210\u7684\u529f\u80fd\u6b63\u786e\u8865\u4e01\u5728\u67d0\u4e00\u8d28\u91cf\u7ef4\u5ea6\u4e0a\u7684\u63d0\u5347\u5e38\u4ee5\u727a\u7272\u5176\u4ed6\u7ef4\u5ea6\u4e3a\u4ee3\u4ef7\uff0c\u4e14\u4e0d\u540c\u6a21\u578b\u4e0e\u4f18\u5316\u7b56\u7565\u5728\u8fd0\u884c\u65f6\u548c\u5185\u5b58\u8868\u73b0\u4e0a\u5dee\u5f02\u663e\u8457\u3002", "conclusion": "\u5b66\u672f\u5173\u6ce8\u70b9\u3001\u5de5\u4e1a\u4f18\u5148\u7ea7\u4e0eLLM\u5b9e\u9645\u8868\u73b0\u4e4b\u95f4\u5b58\u5728\u660e\u663e\u4e0d\u5339\u914d\uff0c\u4e9f\u9700\u5728LLM\u4ee3\u7801\u751f\u6210\u6d41\u7a0b\u4e2d\u5d4c\u5165\u8d28\u91cf\u4fdd\u969c\u673a\u5236\uff0c\u4ee5\u786e\u4fdd\u751f\u6210\u4ee3\u7801\u4e0d\u4ec5\u529f\u80fd\u6b63\u786e\uff0c\u800c\u4e14\u5177\u5907\u9ad8\u8d28\u91cf\u7684\u975e\u529f\u80fd\u6027\u5c5e\u6027\u3002"}}
{"id": "2511.10323", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.10323", "abs": "https://arxiv.org/abs/2511.10323", "authors": ["D\u00e1vid K\u00f3sz\u00f3", "Tam\u00e1s Aladics", "Rudolf Ferenc", "P\u00e9ter Heged\u0171s"], "title": "A Large-Scale Collection Of (Non-)Actionable Static Code Analysis Reports", "comment": "Under publication to Nature Scientific Data journal", "summary": "Static Code Analysis (SCA) tools, while invaluable for identifying potential coding problems, functional bugs, or vulnerabilities, often generate an overwhelming number of warnings, many of which are non-actionable. This overload of alerts leads to ``alert fatigue'', a phenomenon where developers become desensitized to warnings, potentially overlooking critical issues and ultimately hindering productivity and code quality. Analyzing these warnings and training machine learning models to identify and filter them requires substantial datasets, which are currently scarce, particularly for Java. This scarcity impedes efforts to improve the accuracy and usability of SCA tools and mitigate the effects of alert fatigue. In this paper, we address this gap by introducing a novel methodology for collecting and categorizing SCA warnings, effectively distinguishing actionable from non-actionable ones. We further leverage this methodology to generate a large-scale dataset of over 1 million entries of Java source code warnings, named NASCAR: (Non-)Actionable Static Code Analysis Reports. To facilitate follow-up research in this domain, we make both the dataset and the tools used to generate it publicly available.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u65b9\u6cd5\uff0c\u7528\u4e8e\u6536\u96c6\u548c\u5206\u7c7b\u9759\u6001\u4ee3\u7801\u5206\u6790\uff08SCA\uff09\u8b66\u544a\uff0c\u5e76\u6784\u5efa\u4e86\u4e00\u4e2a\u5305\u542b\u8d85\u8fc7100\u4e07\u6761Java\u4ee3\u7801\u8b66\u544a\u7684\u5927\u89c4\u6a21\u6570\u636e\u96c6NASCAR\uff0c\u4ee5\u533a\u5206\u53ef\u64cd\u4f5c\u4e0e\u4e0d\u53ef\u64cd\u4f5c\u7684\u8b66\u544a\uff0c\u7f13\u89e3\u201c\u8b66\u62a5\u75b2\u52b3\u201d\u95ee\u9898\u3002", "motivation": "\u9759\u6001\u4ee3\u7801\u5206\u6790\u5de5\u5177\u5e38\u4ea7\u751f\u5927\u91cf\u4e0d\u53ef\u64cd\u4f5c\u7684\u8b66\u544a\uff0c\u5bfc\u81f4\u5f00\u53d1\u8005\u51fa\u73b0\u201c\u8b66\u62a5\u75b2\u52b3\u201d\uff0c\u800c\u73b0\u6709\u7814\u7a76\u7f3a\u4e4f\u5927\u89c4\u6a21\u6807\u6ce8\u6570\u636e\u96c6\uff08\u5c24\u5176\u662fJava\uff09\uff0c\u963b\u788d\u4e86\u76f8\u5173\u673a\u5668\u5b66\u4e60\u6a21\u578b\u7684\u53d1\u5c55\u3002", "method": "\u63d0\u51fa\u4e00\u79cd\u65b0\u9896\u7684\u65b9\u6cd5\u8bba\u6765\u6536\u96c6\u548c\u5206\u7c7bSCA\u8b66\u544a\uff0c\u533a\u5206\u5176\u662f\u5426\u53ef\u64cd\u4f5c\uff0c\u5e76\u57fa\u4e8e\u6b64\u65b9\u6cd5\u6784\u5efa\u540d\u4e3aNASCAR\u7684\u5927\u89c4\u6a21Java\u8b66\u544a\u6570\u636e\u96c6\u3002", "result": "\u6210\u529f\u6784\u5efa\u5e76\u516c\u5f00\u4e86\u4e00\u4e2a\u5305\u542b\u8d85100\u4e07\u6761Java SCA\u8b66\u544a\u7684\u6570\u636e\u96c6NASCAR\uff0c\u540c\u65f6\u5f00\u6e90\u4e86\u76f8\u5173\u751f\u6210\u5de5\u5177\uff0c\u652f\u6301\u540e\u7eed\u7814\u7a76\u3002", "conclusion": "\u8be5\u5de5\u4f5c\u586b\u8865\u4e86Java\u9886\u57dfSCA\u8b66\u544a\u6570\u636e\u96c6\u7684\u7a7a\u767d\uff0c\u6709\u52a9\u4e8e\u63d0\u5347SCA\u5de5\u5177\u7684\u51c6\u786e\u6027\u548c\u53ef\u7528\u6027\uff0c\u5e76\u4e3a\u7f13\u89e3\u8b66\u62a5\u75b2\u52b3\u63d0\u4f9b\u57fa\u7840\u652f\u6301\u3002"}}
{"id": "2511.10180", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.10180", "abs": "https://arxiv.org/abs/2511.10180", "authors": ["Tao Tang", "Youfu Jiang", "Yingbo Cui", "Jianbin Fang", "Peng Zhang", "Lin Peng", "Chun Huang"], "title": "Selection of Supervised Learning-based Sparse Matrix Reordering Algorithms", "comment": "14pages", "summary": "Sparse matrix ordering is a vital optimization technique often employed for solving large-scale sparse matrices. Its goal is to minimize the matrix bandwidth by reorganizing its rows and columns, thus enhancing efficiency. Conventional methods for algorithm selection usually depend on brute-force search or empirical knowledge, lacking the ability to adjust to diverse sparse matrix structures.As a result, we have introduced a supervised learning-based model for choosing sparse matrix reordering algorithms. This model grasps the correlation between matrix characteristics and commonly utilized reordering algorithms, facilitating the automated and intelligent selection of the suitable sparse matrix reordering algorithm. Experiments conducted on the Florida sparse matrix dataset reveal that our model can accurately predict the optimal reordering algorithm for various matrices, leading to a 55.37% reduction in solution time compared to solely using the AMD reordering algorithm, with an average speedup ratio of 1.45.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u76d1\u7763\u5b66\u4e60\u7684\u7a00\u758f\u77e9\u9635\u91cd\u6392\u5e8f\u7b97\u6cd5\u9009\u62e9\u6a21\u578b\uff0c\u80fd\u6839\u636e\u77e9\u9635\u7279\u5f81\u81ea\u52a8\u9884\u6d4b\u6700\u4f18\u91cd\u6392\u5e8f\u7b97\u6cd5\uff0c\u5728Florida\u6570\u636e\u96c6\u4e0a\u76f8\u6bd4\u4ec5\u4f7f\u7528AMD\u7b97\u6cd5\u5e73\u5747\u63d0\u901f1.45\u500d\uff0c\u6c42\u89e3\u65f6\u95f4\u51cf\u5c1155.37%\u3002", "motivation": "\u4f20\u7edf\u7a00\u758f\u77e9\u9635\u91cd\u6392\u5e8f\u7b97\u6cd5\u9009\u62e9\u4f9d\u8d56\u66b4\u529b\u641c\u7d22\u6216\u7ecf\u9a8c\u77e5\u8bc6\uff0c\u96be\u4ee5\u9002\u5e94\u4e0d\u540c\u7a00\u758f\u77e9\u9635\u7ed3\u6784\uff0c\u7f3a\u4e4f\u667a\u80fd\u5316\u548c\u81ea\u9002\u5e94\u80fd\u529b\u3002", "method": "\u6784\u5efa\u76d1\u7763\u5b66\u4e60\u6a21\u578b\uff0c\u5b66\u4e60\u7a00\u758f\u77e9\u9635\u7279\u5f81\u4e0e\u5e38\u7528\u91cd\u6392\u5e8f\u7b97\u6cd5\u4e4b\u95f4\u7684\u5173\u8054\uff0c\u5b9e\u73b0\u81ea\u52a8\u667a\u80fd\u7684\u7b97\u6cd5\u9009\u62e9\u3002", "result": "\u5728Florida\u7a00\u758f\u77e9\u9635\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u9a8c\u8868\u660e\uff0c\u8be5\u6a21\u578b\u80fd\u51c6\u786e\u9884\u6d4b\u5404\u7c7b\u77e9\u9635\u7684\u6700\u4f18\u91cd\u6392\u5e8f\u7b97\u6cd5\uff0c\u76f8\u6bd4\u4ec5\u4f7f\u7528AMD\u7b97\u6cd5\uff0c\u5e73\u5747\u6c42\u89e3\u65f6\u95f4\u51cf\u5c1155.37%\uff0c\u5e73\u5747\u52a0\u901f\u6bd4\u8fbe1.45\u3002", "conclusion": "\u57fa\u4e8e\u76d1\u7763\u5b66\u4e60\u7684\u7a00\u758f\u77e9\u9635\u91cd\u6392\u5e8f\u7b97\u6cd5\u9009\u62e9\u65b9\u6cd5\u80fd\u6709\u6548\u63d0\u5347\u6c42\u89e3\u6548\u7387\uff0c\u5177\u6709\u826f\u597d\u7684\u81ea\u9002\u5e94\u6027\u548c\u5b9e\u7528\u6027\u3002"}}
{"id": "2511.10258", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.10258", "abs": "https://arxiv.org/abs/2511.10258", "authors": ["Leszek Sliwko", "Vladimir Getov"], "title": "Workload Schedulers -- Genesis, Algorithms and Differences", "comment": null, "summary": "This paper presents a novel approach to categorization of modern workload schedulers. We provide descriptions of three classes of schedulers: Operating Systems Process Schedulers, Cluster Systems Jobs Schedulers and Big Data Schedulers. We describe their evolution from early adoptions to modern implementations, considering both the use and features of algorithms. In summary, we discuss differences between all presented classes of schedulers and discuss their chronological development. In conclusion we highlight similarities in the focus of scheduling strategies design, applicable to both local and distributed systems.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u5bf9\u73b0\u4ee3\u5de5\u4f5c\u8d1f\u8f7d\u8c03\u5ea6\u5668\u8fdb\u884c\u5206\u7c7b\u7684\u65b0\u65b9\u6cd5\uff0c\u63cf\u8ff0\u4e86\u64cd\u4f5c\u7cfb\u7edf\u8fdb\u7a0b\u8c03\u5ea6\u5668\u3001\u96c6\u7fa4\u7cfb\u7edf\u4f5c\u4e1a\u8c03\u5ea6\u5668\u548c\u5927\u6570\u636e\u8c03\u5ea6\u5668\u4e09\u7c7b\u8c03\u5ea6\u5668\u7684\u6f14\u8fdb\u4e0e\u7279\u5f81\uff0c\u5e76\u603b\u7ed3\u4e86\u5b83\u4eec\u4e4b\u95f4\u7684\u5f02\u540c\u53ca\u8bbe\u8ba1\u7b56\u7565\u7684\u5171\u901a\u70b9\u3002", "motivation": "\u4e3a\u4e86\u66f4\u597d\u5730\u7406\u89e3\u548c\u7ec4\u7ec7\u73b0\u4ee3\u8c03\u5ea6\u5668\u7684\u53d1\u5c55\u8109\u7edc\uff0c\u4f5c\u8005\u65e8\u5728\u5bf9\u4e0d\u540c\u7c7b\u578b\u7684\u8c03\u5ea6\u5668\u8fdb\u884c\u7cfb\u7edf\u6027\u5206\u7c7b\u548c\u6bd4\u8f83\uff0c\u63ed\u793a\u5176\u8bbe\u8ba1\u7b56\u7565\u7684\u5171\u6027\u4e0e\u5dee\u5f02\u3002", "method": "\u901a\u8fc7\u56de\u987e\u548c\u5206\u6790\u64cd\u4f5c\u7cfb\u7edf\u8fdb\u7a0b\u8c03\u5ea6\u5668\u3001\u96c6\u7fa4\u4f5c\u4e1a\u8c03\u5ea6\u5668\u548c\u5927\u6570\u636e\u8c03\u5ea6\u5668\u4ece\u65e9\u671f\u5230\u73b0\u4ee3\u7684\u6f14\u8fdb\u8fc7\u7a0b\uff0c\u6bd4\u8f83\u5176\u7b97\u6cd5\u4f7f\u7528\u4e0e\u529f\u80fd\u7279\u6027\u3002", "result": "\u660e\u786e\u4e86\u4e09\u7c7b\u8c03\u5ea6\u5668\u5728\u53d1\u5c55\u8def\u5f84\u3001\u5e94\u7528\u573a\u666f\u548c\u7b97\u6cd5\u7279\u6027\u4e0a\u7684\u533a\u522b\uff0c\u5e76\u6307\u51fa\u5176\u8c03\u5ea6\u7b56\u7565\u8bbe\u8ba1\u5728\u672c\u5730\u4e0e\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\u7684\u76f8\u4f3c\u5173\u6ce8\u70b9\u3002", "conclusion": "\u5c3d\u7ba1\u8c03\u5ea6\u5668\u7c7b\u578b\u5404\u5f02\uff0c\u4f46\u5176\u8c03\u5ea6\u7b56\u7565\u7684\u8bbe\u8ba1\u6838\u5fc3\u5728\u672c\u5730\u548c\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\u5b58\u5728\u663e\u8457\u5171\u6027\uff0c\u4e3a\u672a\u6765\u8c03\u5ea6\u5668\u7814\u7a76\u63d0\u4f9b\u7edf\u4e00\u89c6\u89d2\u3002"}}
{"id": "2511.10480", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.10480", "abs": "https://arxiv.org/abs/2511.10480", "authors": ["Changhai Man", "Joongun Park", "Hanjiang Wu", "Huan Xu", "Srinivas Sridharan", "Tushar Krishna"], "title": "Scalable Synthesis of distributed LLM workloads through Symbolic Tensor Graphs", "comment": null, "summary": "Optimizing the performance of large language models (LLMs) on large-scale AI training and inference systems requires a scalable and expressive mechanism to model distributed workload execution. Such modeling is essential for pre-deployment system-level optimizations (e.g., parallelization strategies) and design-space explorations. While recent efforts have proposed collecting execution traces from real systems, access to large-scale infrastructure remains limited to major cloud providers. Moreover, traces obtained from existing platforms cannot be easily adapted to study future larger-scale system configurations. We introduce Symbolic Tensor grAph GEnerator(STAGE), a framework that synthesizes high-fidelity execution traces to accurately model LLM workloads. STAGE supports a comprehensive set of parallelization strategies, allowing users to systematically explore a wide spectrum of LLM architectures and system configurations. STAGE demonstrates its scalability by synthesizing high-fidelity LLM traces spanning over 32K GPUs, while preserving tensor-level accuracy in compute, memory, and communication. STAGE will be publicly available to facilitate further research in distributed machine learning systems.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86STAGE\u6846\u67b6\uff0c\u7528\u4e8e\u751f\u6210\u9ad8\u4fdd\u771f\u5ea6\u7684LLM\u6267\u884c\u8f68\u8ff9\uff0c\u4ee5\u652f\u6301\u5927\u89c4\u6a21\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\u5bf9LLM\u5de5\u4f5c\u8d1f\u8f7d\u7684\u5efa\u6a21\u4e0e\u4f18\u5316\u3002", "motivation": "\u73b0\u6709\u65b9\u6cd5\u4f9d\u8d56\u771f\u5b9e\u7cfb\u7edf\u91c7\u96c6\u6267\u884c\u8f68\u8ff9\uff0c\u4f46\u5927\u89c4\u6a21\u57fa\u7840\u8bbe\u65bd\u4ec5\u9650\u5927\u578b\u4e91\u5382\u5546\u8bbf\u95ee\uff0c\u4e14\u73b0\u6709\u5e73\u53f0\u7684\u8f68\u8ff9\u96be\u4ee5\u9002\u914d\u672a\u6765\u66f4\u5927\u89c4\u6a21\u7684\u7cfb\u7edf\u914d\u7f6e\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u79cd\u53ef\u6269\u5c55\u4e14\u8868\u8fbe\u80fd\u529b\u5f3a\u7684\u5efa\u6a21\u673a\u5236\u3002", "method": "\u63d0\u51faSymbolic Tensor grAph GEnerator\uff08STAGE\uff09\u6846\u67b6\uff0c\u901a\u8fc7\u5408\u6210\u9ad8\u4fdd\u771f\u6267\u884c\u8f68\u8ff9\uff0c\u5728\u5f20\u91cf\u7ea7\u522b\u4e0a\u51c6\u786e\u5efa\u6a21\u8ba1\u7b97\u3001\u5185\u5b58\u548c\u901a\u4fe1\u884c\u4e3a\uff0c\u5e76\u652f\u6301\u591a\u79cd\u5e76\u884c\u7b56\u7565\u3002", "result": "STAGE\u80fd\u591f\u751f\u6210\u8986\u76d6\u8d85\u8fc732K GPU\u7684\u9ad8\u4fdd\u771fLLM\u6267\u884c\u8f68\u8ff9\uff0c\u540c\u65f6\u4fdd\u6301\u5f20\u91cf\u7ea7\u7cbe\u5ea6\uff0c\u5e76\u652f\u6301\u5e7f\u6cdb\u7684LLM\u67b6\u6784\u4e0e\u7cfb\u7edf\u914d\u7f6e\u63a2\u7d22\u3002", "conclusion": "STAGE\u4e3a\u5206\u5e03\u5f0f\u673a\u5668\u5b66\u4e60\u7cfb\u7edf\u7814\u7a76\u63d0\u4f9b\u4e86\u53ef\u6269\u5c55\u3001\u9ad8\u4fdd\u771f\u7684\u5efa\u6a21\u5de5\u5177\uff0c\u5c06\u516c\u5f00\u53d1\u5e03\u4ee5\u4fc3\u8fdb\u76f8\u5173\u7814\u7a76\u3002"}}
