<div id=toc></div>

# Table of Contents

- [cs.PF](#cs.PF) [Total: 1]
- [cs.DC](#cs.DC) [Total: 3]
- [cs.AR](#cs.AR) [Total: 3]
- [cs.SE](#cs.SE) [Total: 6]
- [cs.MA](#cs.MA) [Total: 2]
- [cs.NI](#cs.NI) [Total: 1]


<div id='cs.PF'></div>

# cs.PF [[Back]](#toc)

### [1] [Balanced allocation: considerations from large scale service environments](https://arxiv.org/abs/2601.10874)
*Amer Diwan,Prabhakar Raghavan,Eli Upfal*

Main category: cs.PF

TL;DR: 本文研究了d路平衡分配在突发流量、多优先级任务和信息噪声等实际生产环境中的表现，并通过仿真与分析验证其有效性。


<details>
  <summary>Details</summary>
Motivation: 为解决大规模云系统中负载均衡在面对突发请求、任务优先级差异和信息延迟时的适应性问题，扩展d路平衡分配的应用场景。

Method: 结合大规模仿真实验与生成模型的数学分析，评估d路平衡分配在突发、优先级和噪声条件下的性能表现。

Result: 仿真表明该方法能快速从突发中恢复，优雅处理优先级和噪声；理论分析进一步解释了仿真结果背后的机制。

Conclusion: d路平衡分配在复杂生产环境中仍具鲁棒性和实用性，理论与仿真相辅相成，可指导实际系统设计。

Abstract: We study d-way balanced allocation, which assigns each incoming job to the lightest loaded among d randomly chosen servers. While prior work has extensively studied the performance of the basic scheme, there has been less published work on adapting this technique to many aspects of large-scale systems. Based on our experience in building and running planet-scale cloud applications, we extend the understanding of d-way balanced allocation along the following dimensions:
  (i) Bursts: Events such as breaking news can produce bursts of requests that may temporarily exceed the servicing capacity of the system. Thus, we explore what happens during a burst and how long it takes for the system to recover from such bursts. (ii) Priorities: Production systems need to handle jobs with a mix of priorities (e.g., user facing requests may be high priority while other requests may be low priority). We extend d-way balanced allocation to handle multiple priorities. (iii) Noise: Production systems are often typically distributed and thus d-way balanced allocation must work with stale or incorrect information. Thus we explore the impact of noisy information and their interactions with bursts and priorities.
  We explore the above using both extensive simulations and analytical arguments. Specifically we show, (i) using simulations, that d-way balanced allocation quickly recovers from bursts and can gracefully handle priorities and noise; and (ii) that analysis of the underlying generative models complements our simulations and provides insight into our simulation results.

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [2] [AFLL: Real-time Load Stabilization for MMO Game Servers Based on Circular Causality Learning](https://arxiv.org/abs/2601.10998)
*Shinsuk Kang,Youngjae Kim*

Main category: cs.DC

TL;DR: AFLL通过学习服务器消息与客户端请求的因果关系，实现动态预测性限流，在保证关键消息的同时降低服务器负载。


<details>
  <summary>Details</summary>
Motivation: 传统方法在服务器过载时无法智能区分消息优先级，导致游戏体验受损或规则僵化。

Method: 采用反向传播实时调整消息类型权重，结合后台计算与缓存优化实现零学习开销的自适应限流。

Result: 在千人并发实验中，平均CPU时间降低48.3%，峰值降低51.7%，线程争用减少64.4%，所有指标变异系数<2%。

Conclusion: 循环因果学习可为低延迟系统提供实用的实时自适应能力。

Abstract: Massively Multiplayer Online (MMO) game servers must handle thousands of simultaneous players while maintaining sub-100ms response times. When server load exceeds capacity, traditional approaches either uniformly throttle all message types regardless of importance (damaging gameplay) or apply fixed heuristic rules that fail to adapt to dynamic workloads. This paper presents AFLL (Adaptive Feedback Loop Learning), a real-time load stabilization system that learns the causal relationship between outgoing server messages and subsequent incoming client requests. AFLL employs backpropagation to continuously adjust message type weights, enabling predictive throttling that blocks low-priority messages before overload occurs while guaranteeing critical message delivery. Through controlled experiments with 1,000 concurrent players, AFLL reduced average CPU time by 48.3% (13.2ms to 6.8ms), peak CPU time by 51.7% (54.0ms to 26.1ms), and thread contention by 64.4% (19.6% to 7.0%), while maintaining zero learning overhead through background computation and caching optimizations. The system achieved remarkable reproducibility (CV < 2% across all metrics) and identified a three-stage causal chain linking message blocking to load reduction. AFLL demonstrates that circular causality learning enables practical real-time adaptation for latency-critical systems.

</details>


### [3] [Konflux: Optimized Function Fusion for Serverless Applications](https://arxiv.org/abs/2601.11156)
*Niklas Kowallik,Trever Schirmer,David Bermbach*

Main category: cs.DC

TL;DR: 本文提出一种通过模拟FaaS平台本地实验分析所有函数融合配置的系统，以优化成本与延迟权衡。


<details>
  <summary>Details</summary>
Motivation: 解决FaaS部署中因函数组合爆炸导致生产环境穷举测试成本高、耗时长的问题。

Method: 构建平台仿真系统，在本地评估各类资源限制下的所有融合配置，避免实际平台重配置。

Result: 发现仅少数融合配置在成本与延迟上最优，且受计价模型显著影响。

Conclusion: 函数融合优化需结合具体计价策略，本地仿真可高效筛选最优部署方案。

Abstract: Function-as-a-Service (FaaS) has become a central paradigm in serverless cloud computing, yet optimizing FaaS deployments remains challenging. Using function fusion, multiple functions can be combined into a single deployment unit, which can be used to reduce cost and latency of complex serverless applications comprising multiple functions. Even in small-scale applications, the number of possible fusion configurations is vast, making brute-force benchmarking in production both cost- and time-prohibitive.
  In this paper, we present a system that can analyze every possible fusion setup of complex applications. By emulating the FaaS platform, our system enables local experimentation, eliminating the need to reconfigure the live platform and significantly reducing associated cost and time. We evaluate all fusion configurations across a number of example FaaS applications and resource limits. Our results reveal that, when analyzing cost and latency trade-offs, only a limited set of fusion configurations represent optimal solutions, which are strongly influenced by the specific pricing model in use.

</details>


### [4] [Space-Optimal, Computation-Optimal, Topology-Agnostic, Throughput-Scalable Causal Delivery through Hybrid Buffering](https://arxiv.org/abs/2601.11487)
*Paulo Sérgio Almeida*

Main category: cs.DC

TL;DR: 本文提出一种新的混合算法，结合发送方和接收方缓冲策略，以实现因果顺序消息传递，同时保持常数级元数据开销和计算最优性。


<details>
  <summary>Details</summary>
Motivation: 现有因果传递方法要么元数据开销大，要么仅适用于特定拓扑；纯发送方缓冲方案存在吞吐量和活性问题，需改进。

Method: 引入SPS + FIFO策略，设计混合缓冲算法：发送方缓冲实现SPS，接收方缓冲保证FIFO，优化数据结构实现常数均摊开销。

Result: 新算法在不依赖通信拓扑的前提下，实现了常数级元数据大小和计算最优性，克服了纯发送方缓冲的局限。

Conclusion: 该算法是首个兼具常数元数据、计算最优性和拓扑无关性的因果传递方案，显著优于现有方法。

Abstract: Message delivery respecting causal ordering (causal delivery) is one of the most classic and widely useful abstraction for inter-process communication in a distributed system. Most approaches tag messages with causality information and buffer them at the receiver until they can be safely delivered. Except for specific approaches that exploit communication topology, therefore not generally applicable, they incur a metadata overhead which is prohibitive for a large number of processes. Much less used are the approaches that enforce causal order by buffering messages at the sender, until it is safe to release them to the network, as the classic algorithm has too many drawbacks. In this paper, first we discuss the limitations of sender-only buffering approaches and introduce the Sender Permission to Send (SPS) enforcement strategy, showing that SPS + FIFO implies Causal. We analyze a recent sender-buffering algorithm, Cykas, which follows SPS + FIFO, albeit very conservatively, pointing out throughput scalability and liveness issues. Then, we introduce a novel SPS + FIFO based algorithm, which adopts a new hybrid approach: enforcing causality by combining sender-buffering to enforce SPS and receiver-buffering to enforce FIFO. The algorithm overcomes limitations of sender-only buffering, and achieves effectively constant metadata size per message. By a careful choice of data-structures, the algorithm is also computationally-optimal, with amortized effectively constant processing overhead. As far as we know, there is no other topology-agnostic causal delivery algorithm with these properties.

</details>


<div id='cs.AR'></div>

# cs.AR [[Back]](#toc)

### [5] [SwiftKV: An Edge-Oriented Attention Algorithm and Multi-Head Accelerator for Fast, Efficient LLM Decoding](https://arxiv.org/abs/2601.10953)
*Junming Zhang,Qinyan Zhang,Huajun Sun,Feiyang Gao,Sheng Hu,Rui Nie,Xiangshui Miao*

Main category: cs.AR

TL;DR: SwiftKV Attention算法与SwiftKV-MHA加速器显著提升边缘设备上大语言模型的推理速度和效率。


<details>
  <summary>Details</summary>
Motivation: 解决边缘设备资源受限下大语言模型注意力机制推理慢、解码效率低的问题。

Method: 提出单次处理、无需得分物化或二次遍历的SwiftKV Attention算法，并设计支持高低精度混合计算的SwiftKV-MHA加速器。

Result: 实验表明，SwiftKV Attention比原生注意力快7.16倍，SwiftKV-MHA进一步降低延迟13.48倍，生成速度提升17.4%，token效率提高1.98倍。

Conclusion: SwiftKV方案在边缘设备上实现了高效、低延迟的大语言模型注意力推理与多头并行解码。

Abstract: Edge acceleration for large language models is crucial for their widespread application; however, achieving fast attention inference and efficient decoding on resource-constrained edge accelerators remains challenging. This paper presents SwiftKV Attention, a per-token pipelined, low-latency single-pass attention inference algorithm, where every (kt, vt) in the KV cache is processed exactly once in a uniform per-token pipeline without score materialization, blockwise softmax, or a second pass, thereby enabling fast execution on edge accelerators with a single hardware set and no resource-intensive parallelism. Furthermore, to address the limited support for multi-head LLM decoding in existing accelerators, we design the SwiftKV-MHA accelerator, which enables high precision attention and low precision GEMV on the same processor array, achieving fast and efficient multi-head parallel decoding. Experimental results show that, on the edge accelerator, the SwiftKV Attention algorithm achieves a 7.16* speedup over native attention and significantly outperforms other attention algorithms. SwiftKV-MHA further reduces attention latency by 13.48*; under the same settings, it improves generation speed by 17.4% and increases token efficiency by 1.98* compared with state-of-the-art works.

</details>


### [6] [RidgeWalker: Perfectly Pipelined Graph Random Walks on FPGAs](https://arxiv.org/abs/2601.11057)
*Hongshi Tan,Yao Chen,Xinyu Chen,Qizhen Zhang,Cheng Chen,Weng-Fai Wong,Bingsheng He*

Main category: cs.AR

TL;DR: RidgeWalker是一种专为数据中心FPGA设计的高性能图随机游走加速器，通过异步流水线和反馈驱动调度显著提升性能。


<details>
  <summary>Details</summary>
Motivation: 现有FPGA方案因流水线效率低和静态调度无法充分发挥硬件潜力，亟需更高效的GRW加速方法。

Method: 利用GRW的马尔可夫性质分解为无状态细粒度任务，结合基于排队理论的异步流水线与自适应调度架构。

Result: 在真实数据集上平均提速7.0倍于先进FPGA方案、8.1倍于GPU方案，峰值提速分别达71.0倍和22.9倍。

Conclusion: RidgeWalker有效解决了GRW加速中的依赖性与负载不均问题，显著释放了FPGA硬件潜力。

Abstract: Graph Random Walks (GRWs) offer efficient approximations of key graph properties and have been widely adopted in many applications. However, GRW workloads are notoriously difficult to accelerate due to their strong data dependencies, irregular memory access patterns, and imbalanced execution behavior. While recent work explores FPGA-based accelerators for GRWs, existing solutions fall far short of hardware potential due to inefficient pipelining and static scheduling. This paper presents RidgeWalker, a high-performance GRW accelerator designed for datacenter FPGAs. The key insight behind RidgeWalker is that the Markov property of GRWs allows decomposition into stateless, fine-grained tasks that can be executed out-of-order without compromising correctness. Building on this, RidgeWalker introduces an asynchronous pipeline architecture with a feedback-driven scheduler grounded in queuing theory, enabling perfect pipelining and adaptive load balancing. We prototype RidgeWalker on datacenter FPGAs and evaluated it across a range of GRW algorithms and real-world graph datasets. Experimental results demonstrate that RidgeWalker achieves an average speedup of 7.0x over state-of-the-art FPGA solutions and 8.1x over GPU solutions, with peak speedups of up to 71.0x and 22.9x, respectively. The source code is publicly available at https://github.com/Xtra-Computing/RidgeWalker.

</details>


### [7] [OpenACM: An Open-Source SRAM-Based Approximate CiM Compiler](https://arxiv.org/abs/2601.11292)
*Yiqi Zhou,JunHao Ma,Xingyang Li,Yule Sheng,Yue Yuan,Yikai Wang,Bochang Wang,Yiheng Wu,Shan Shen,Wei Xing,Daying Sun,Li Li,Zhiqiang Xiao*

Main category: cs.AR

TL;DR: OpenACM是首个开源、精度感知的SRAM近存计算编译器，支持可配置精度乘法器，实现高达64%能耗节省且精度损失可忽略。


<details>
  <summary>Details</summary>
Motivation: 数据密集型AI负载加剧内存墙瓶颈，现有DCiM编译器未利用近似计算优化潜力。

Method: 集成可调精度乘法器库，结合晶体管级SRAM宏与OpenROAD物理设计流程，自动化生成近似DCiM架构。

Result: 在CNN上实现最高64%能耗降低，同时保持应用精度基本无损。

Conclusion: OpenACM填补了AI误差容忍与硬件自动化之间的空白，提供完全开源可复现的近似计算编译方案。

Abstract: The rise of data-intensive AI workloads has exacerbated the ``memory wall'' bottleneck. Digital Compute-in-Memory (DCiM) using SRAM offers a scalable solution, but its vast design space makes manual design impractical, creating a need for automated compilers. A key opportunity lies in approximate computing, which leverages the error tolerance of AI applications for significant energy savings. However, existing DCiM compilers focus on exact arithmetic, failing to exploit this optimization. This paper introduces OpenACM, the first open-source, accuracy-aware compiler for SRAM-based approximate DCiM architectures. OpenACM bridges the gap between application error tolerance and hardware automation. Its key contribution is an integrated library of accuracy-configurable multipliers (exact, tunable approximate, and logarithmic), enabling designers to make fine-grained accuracy-energy trade-offs. The compiler automates the generation of the DCiM architecture, integrating a transistor-level customizable SRAM macro with variation-aware characterization into a complete, open-source physical design flow based on OpenROAD and the FreePDK45 library. This ensures full reproducibility and accessibility, removing dependencies on proprietary tools. Experimental results on representative convolutional neural networks (CNNs) demonstrate that OpenACM achieves energy savings of up to 64\% with negligible loss in application accuracy. The framework is available on \href{https://github.com/ShenShan123/OpenACM}{OpenACM:URL}

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [8] [Multi-Artifact Analysis of Self-Admitted Technical Debt in Scientific Software](https://arxiv.org/abs/2601.10850)
*Eric L. Melin,Nasir U. Eisty,Gregory Watson,Addi Malviya-Thakur*

Main category: cs.SE

TL;DR: 本研究识别并评估科学软件中的科学债务，发现其无法被传统技术债务分类充分捕捉，需专门检测方法。


<details>
  <summary>Details</summary>
Motivation: 科学软件中的自认技术债务可能影响结果的有效性和可重复性，需针对性分析。

Method: 对23个开源科学软件项目进行多工件分析，构建数据集、开发分类器并开展实践者验证。

Result: 分类器在90万工件中表现良好；科学债务在拉取请求和问题追踪器中最常见，传统模型常遗漏此类债务。

Conclusion: 科学债务是科学软件中独特且需专门管理的技术债务形式，应采用定制化检测方法。

Abstract: Context: Self-admitted technical debt (SATD) occurs when developers acknowledge shortcuts in code. In scientific software (SSW), such debt poses unique risks to the validity and reproducibility of results. Objective: This study aims to identify, categorize, and evaluate scientific debt, a specialized form of SATD in SSW, and assess the extent to which traditional SATD categories capture these domain-specific issues. Method: We conduct a multi-artifact analysis across code comments, commit messages, pull requests, and issue trackers from 23 open-source SSW projects. We construct and validate a curated dataset of scientific debt, develop a multi-source SATD classifier, and conduct a practitioner validation to assess the practical relevance of scientific debt. Results: Our classifier performs strongly across 900,358 artifacts from 23 SSW projects. SATD is most prevalent in pull requests and issue trackers, underscoring the value of multi-artifact analysis. Models trained on traditional SATD often miss scientific debt, emphasizing the need for its explicit detection in SSW. Practitioner validation confirmed that scientific debt is both recognizable and useful in practice. Conclusions: Scientific debt represents a unique form of SATD in SSW that that is not adequately captured by traditional categories and requires specialized identification and management. Our dataset, classification analysis, and practitioner validation results provide the first formal multi-artifact perspective on scientific debt, highlighting the need for tailored SATD detection approaches in SSW.

</details>


### [9] [Change And Cover: Last-Mile, Pull Request-Based Regression Test Augmentation](https://arxiv.org/abs/2601.10942)
*Zitong Zhou,Matteo Paltenghi,Miryung Kim,Michael Pradel*

Main category: cs.SE

TL;DR: ChaCo 是一种基于 LLM 的测试增强技术，专门针对 PR 中未覆盖代码行生成测试，提升补丁覆盖率并融入现有测试框架。


<details>
  <summary>Details</summary>
Motivation: PR 修改的代码行常缺乏测试覆盖，现有工具未针对性解决此‘最后一公里’回归测试缺口。

Method: ChaCo 结合 PR 补丁上下文，提取相关测试内容辅助 LLM 生成测试，并按现有风格集成测试、提供摘要供审查。

Result: 在 SciPy、Qiskit、Pandas 的 145 个 PR 上评估，30% 实现完整补丁覆盖，成本 $0.11；人工评分高，8/12 测试被合并，发现并修复 2 个未知 bug。

Conclusion: ChaCo 高效实用，适合集成到 CI 工作流中，自动化完成回归测试的最后一环。

Abstract: Software is in constant evolution, with developers frequently submitting pull requests (PRs) to introduce new features or fix bugs. Testing PRs is critical to maintaining software quality. Yet, even in projects with extensive test suites, some PR-modified lines remain untested, leaving a "last-mile" regression test gap. Existing test generators typically aim to improve overall coverage, but do not specifically target the uncovered lines in PRs. We present Change And Cover (ChaCo), an LLM-based test augmentation technique that addresses this gap. It makes three contributions: (i) ChaCo considers the PR-specific patch coverage, offering developers augmented tests for code just when it is on the developers' mind. (ii) We identify providing suitable test context as a crucial challenge for an LLM to generate useful tests, and present two techniques to extract relevant test content, such as existing test functions, fixtures, and data generators. (iii) To make augmented tests acceptable for developers, ChaCo carefully integrates them into the existing test suite, e.g., by matching the test's structure and style with the existing tests, and generates a summary of the test addition for developer review. We evaluate ChaCo on 145 PRs from three popular and complex open-source projects - SciPy, Qiskit, and Pandas. The approach successfully helps 30% of PRs achieve full patch coverage, at the cost of $0.11, showing its effectiveness and practicality. Human reviewers find the tests to be worth adding (4.53/5.0), well integrated (4.2/5.0), and relevant to the PR (4.7/5.0). Ablations show test context is crucial for context-aware test generation, leading to 2x coverage. We submitted 12 tests, of which 8 have already been merged, and two previously unknown bugs were exposed and fixed. We envision our approach to be integrated into CI workflows, automating the last mile of regression test augmentation.

</details>


### [10] [Patterns of Bot Participation and Emotional Influence in Open-Source Development](https://arxiv.org/abs/2601.11138)
*Matteo Vaccargiu,Riccardo Lai,Maria Ilaria Lunesu,Andrea Pinna,Giuseppe Destefanis*

Main category: cs.SE

TL;DR: 研究以太坊生态系统中机器人对开源讨论的影响，发现少量机器人能改变开发者沟通的时间和情感动态。


<details>
  <summary>Details</summary>
Motivation: 探讨机器人在开源社区中的作用及其对开发者情感语气的影响。

Method: 分析36,875个账户的数据，识别105个机器人，并使用27种情绪类别的模型评估情感变化。

Result: 机器人更中立，但其介入后人类评论的情感中立性降低，转向感激、钦佩和乐观。

Conclusion: 即使少量机器人也能显著影响开发者沟通的时间安排和情感动态。

Abstract: We study how bots contribute to open-source discussions in the Ethereum ecosystem and whether they influence developers' emotional tone. Our dataset covers 36,875 accounts across ten repositories with 105 validated bots (0.28%). Human participation follows a U-shaped pattern, while bots engage in uniform (pull requests) or late-stage (issues) activity. Bots respond faster than humans in pull requests but play slower maintenance roles in issues. Using a model trained on 27 emotion categories, we find bots are more neutral, yet their interventions are followed by reduced neutrality in human comments, with shifts toward gratitude, admiration, and optimism and away from confusion. These findings indicate that even a small number of bots are associated with changes in both timing and emotional dynamics of developer communication.

</details>


### [11] [Automation and Reuse Practices in GitHub Actions Workflows: A Practitioner's Perspective](https://arxiv.org/abs/2601.11299)
*Hassan Onsori Delicheh,Guillaume Cardoen,Alexandre Decan,Tom Mens*

Main category: cs.SE

TL;DR: 该研究调查了419名开发者在GitHub Actions工作流开发中的实践与挑战，发现自动化集中于CI/CD，但忽视安全与性能监控；可重用组件使用不足且存在版本管理问题，亟需改进工具支持。


<details>
  <summary>Details</summary>
Motivation: 帮助开发者减轻工作流维护负担，识别当前GitHub Actions实践中存在的优劣做法及改进机会。

Method: 通过问卷调查419名实际使用GitHub Actions的开发者，分析其自动化任务偏好、创建方式、非功能需求及复用机制的使用情况与挑战。

Result: 发现开发者主要自动化CI/CD任务，较少关注安全与性能；偏好使用可重用Actions但较少采用可重用工作流；存在版本控制困难，常依赖复制粘贴以规避复杂性。

Conclusion: 需提升工具支持，扩展自动化任务范围，并优化可重用组件的发现、管理与信任机制，以改善工作流开发与维护体验。

Abstract: GitHub natively supports workflow automation through GitHub Actions. Yet, workflow maintenance is often considered a burden for software developers, who frequently face difficulties in writing, testing, debugging, and maintaining workflows. Little knowledge exists concerning the automation and reuse practices favoured by workflow practitioners. We therefore surveyed 419 practitioners to elucidate good and bad workflow development practices and to identify opportunities for supporting workflow maintenance. Specifically, we investigate the tasks that practitioners tend to automate using GitHub Actions, their preferred workflow creation mechanisms, and the non-functional characteristics they prioritise. We also examine the practices and challenges associated with GitHub's workflow reuse mechanisms. We observe a tendency to focus automation efforts on core CI/CD tasks, with less emphasis on crucial areas like security analysis and performance monitoring. Practitioners strongly rely on reusable Actions, but reusable workflows see less frequent adoption. Furthermore, we observed challenges with Action versioning and maintenance. Copy-pasting remains a common practice to have more control and avoid the complexity of depending on reusable components. These insights suggest the need for improved tooling, enhanced support for a wide range of automation tasks, and better mechanisms for discovering, managing, and trusting reusable workflow components.

</details>


### [12] [RITA: A Tool for Automated Requirements Classification and Specification from Online User Feedback](https://arxiv.org/abs/2601.11362)
*Manjeshwar Aniruddh Mallya,Alessio Ferrari,Mohammad Amin Zadenoori,Jacek Dąbrowski*

Main category: cs.SE

TL;DR: RITA是一个集成轻量级开源大语言模型的工具，用于从在线用户反馈中自动化生成需求规格，并支持与Jira集成。


<details>
  <summary>Details</summary>
Motivation: 在线用户反馈虽有价值，但因数据量大且噪声多，难以有效分析；现有工具缺乏端到端整合，限制了实际应用。

Method: RITA通过统一工作流整合LLM技术，实现反馈分类、非功能性需求识别及自然语言需求生成，并提供友好界面和Jira集成。

Result: RITA能高效将原始反馈转化为需求制品，弥合研究与实践之间的鸿沟。

Conclusion: RITA展示了LLM在需求工程中的实用价值，推动了反馈驱动型RE工具的实际落地。

Abstract: Context and motivation. Online user feedback is a valuable resource for requirements engineering, but its volume and noise make analysis difficult. Existing tools support individual feedback analysis tasks, but their capabilities are rarely integrated into end-to-end support. Problem. The lack of end-to-end integration limits the practical adoption of existing RE tools and makes it difficult to assess their real-world usefulness. Solution. To address this challenge, we present RITA, a tool that integrates lightweight open-source large language models into a unified workflow for feedback-driven RE. RITA supports automated request classification, non-functional requirement identification, and natural-language requirements specification generation from online feedback via a user-friendly interface, and integrates with Jira for seamless transfer of requirements specifications to development tools. Results and conclusions. RITA exploits previously evaluated LLM-based RE techniques to efficiently transform raw user feedback into requirements artefacts, helping bridge the gap between research and practice. A demonstration is available at: https://youtu.be/8meCLpwQWV8.

</details>


### [13] [A Practical Guide to Establishing Technical Debt Management](https://arxiv.org/abs/2601.11430)
*Marion Wiese*

Main category: cs.SE

TL;DR: 本文提供了一个关于技术债务管理的实用指南，基于作者博士论文的研究成果，旨在帮助团队建立适合自身需求的技术债务管理体系。


<details>
  <summary>Details</summary>
Motivation: 将学术研究成果转化为实际可操作的团队指导，以应对技术债务问题。

Method: 与多家公司的三个团队合作，根据其具体需求调整并建立技术债务管理系统，同时筛选和补充研究结果。

Result: 形成了一套包含‘最佳实践’和‘可选实践’的灵活指南，强调团队共同决策的重要性。

Conclusion: 该指南专注于团队层面的技术债务管理，虽不涵盖全公司范围，但提供了扩展建议。

Abstract: This white paper provides an overview of the topic of "technical debt" and presents an approach for managing technical debt in teams. The white paper is based on the results of my dissertation, which aimed to translate scientific findings into practical guidance. To this end, I collaborated with other researchers to support three teams from different companies in adapting and establishing a technical debt management system tailored to their specific needs. Research findings were supplemented with details or additional approaches. Research results that were less practical were discarded. The result is a guide on establishing technical debt management within a team. The guide is intended to provide orientation and not be a rigid framework. We distinguish between "best practices" and "nice-to-haves." "Best practices" are understood to be all approaches that were adopted by all three teams. "Nice-to-haves" were used by at least one team. In many places, it is explicitly mentioned that the team should decide together how to design the process. This also applies, of course, to all areas where this was not explicitly mentioned. This white paper explicitly does not cover the establishment of technical debt management across the entire company, but provides suggestions for this at the end.

</details>


<div id='cs.MA'></div>

# cs.MA [[Back]](#toc)

### [14] [Cooperative UAVs for Remote Data Collection under Limited Communications: An Asynchronous Multiagent Learning Framework](https://arxiv.org/abs/2601.10849)
*Cuong Le,Symeon Chatzinotas,Thang X. Vu*

Main category: cs.MA

TL;DR: 本文提出一种异步多智能体学习算法，用于优化无人机轨迹与带宽分配，提升数据采集能效与任务完成速度。


<details>
  <summary>Details</summary>
Motivation: 现有方法难以应对无人机间无法同步行动的现实场景，亟需适应异步环境的学习方案。

Method: 将轨迹规划建模为分散部分可观测半马尔可夫决策过程，结合本地观测优化带宽分配。

Result: 实验表明该方法在能效与任务时间上优于基线方法，且策略对环境变化具有鲁棒性。

Conclusion: 所提异步学习框架有效解决了多无人机协同数据采集中的轨迹与资源联合优化问题。

Abstract: This paper addresses the joint optimization of trajectories and bandwidth allocation for multiple Unmanned Aerial Vehicles (UAVs) to enhance energy efficiency in the cooperative data collection problem. We focus on an important yet underestimated aspect of the system, where action synchronization across all UAVs is impossible. Since most existing learning-based solutions are not designed to learn in this asynchronous environment, we formulate the trajectory planning problem as a Decentralized Partially Observable Semi-Markov Decision Process and introduce an asynchronous multi-agent learning algorithm to learn UAVs' cooperative policies. Once the UAVs' trajectory policies are learned, the bandwidth allocation can be optimally solved based on local observations at each collection point. Comprehensive empirical results demonstrate the superiority of the proposed method over other learning-based and heuristic baselines in terms of both energy efficiency and mission completion time. Additionally, the learned policies exhibit robustness under varying environmental conditions.

</details>


### [15] [Can Small Agent Collaboration Beat a Single Big LLM?](https://arxiv.org/abs/2601.11327)
*Agata Żywot,Xinyi Chen,Maarten de Rijke*

Main category: cs.MA

TL;DR: 小规模工具增强智能体在GAIA基准测试中可超越大规模单体模型，工具使用带来最显著提升，而显式推理效果依赖配置与任务难度。


<details>
  <summary>Details</summary>
Motivation: 探究小规模工具增强智能体是否能在性能上匹敌或超越大规模单体模型。

Method: 在Agentic-Reasoning框架下使用Qwen3系列模型（4B-32B），控制变量分析模型规模、显式推理方式和工具使用的影响。

Result: 工具增强带来最大且最稳定的性能提升，4B模型配合工具可超越无工具的32B模型；显式推理效果不稳定，完整推理常因破坏工具协调而降低性能。

Conclusion: 工具使用是提升小模型性能的关键因素，显式推理需谨慎设计以避免负面效应。

Abstract: This report studies whether small, tool-augmented agents can match or outperform larger monolithic models on the GAIA benchmark. Using Qwen3 models (4B-32B) within an adapted Agentic-Reasoning framework, we isolate the effects of model scale, explicit thinking (no thinking, planner-only, or full), and tool use (search, code, mind-map). Tool augmentation provides the largest and most consistent gains. Using tools, 4B models can outperform 32B models without tool access on GAIA in our experimental setup. In contrast, explicit thinking is highly configuration- and difficulty-dependent: planner-only thinking can improve decomposition and constraint tracking, while unrestricted full thinking often degrades performance by destabilizing tool orchestration, leading to skipped verification steps, excessive tool calls, non-termination, and output-format drift.

</details>


<div id='cs.NI'></div>

# cs.NI [[Back]](#toc)

### [16] [X-raying the arXiv: A Large-Scale Analysis of arXiv Submissions' Source Files](https://arxiv.org/abs/2601.11385)
*Giovanni Apruzzese,Aurore Fass*

Main category: cs.NI

TL;DR: 本文分析了arXiv上60万篇论文源文件，发现平均27%内容为非必要数据，总计超580GB冗余，并提出自动化工具提升数据整洁性。


<details>
  <summary>Details</summary>
Motivation: 揭示arXiv论文源文件中可能包含的无关或敏感信息，以改善平台数据管理。

Method: 对2015-2025年间约60万份提交进行纵向分析，检查源文件并量化非必要数据，辅以定性审查。

Result: 发现大量冗余数据及潜在不当内容，已通知相关作者与arXiv团队，并开发自动化检测工具。

Conclusion: 需加强arXiv生态系统的数据卫生，防止无意泄露或资源浪费。

Abstract: arXiv is the largest open-access repository for scientific literature. When submitting a paper, authors upload the manuscript's source files, from which the final PDF is compiled. These source files are also publicly downloadable, potentially exposing data unrelated to the published paper -- such as figures, documents, or comments -- that may unintentionally reveal confidential information or simply waste storage space. We thus ask ourselves: "What can be found within the source files of arXiv submissions?"
  We present a longitudinal analysis of ~600,000 submissions appeared on arXiv between 2015--2025. For each submission, we examine the uploaded source files to quantify and characterize data not required for producing the respective PDF. On average, 27% of the data in each submission are unnecessary, totaling >580 GB of redundant content across our dataset. Qualitative inspection reveals the presence of offensive/inappropriate text (e.g., "WTF does this mean?") and experimental details that could disclose ongoing research. We have contacted arXiv's leadership team, as well as the authors of affected papers to alert them of these issues. Finally, we propose recommendations and an automated tool to detect and analyze arXiv submissions residual data at scale, aiming to improve data hygiene in the arXiv's ecosystem.

</details>
