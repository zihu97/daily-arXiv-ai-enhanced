<div id=toc></div>

# Table of Contents

- [cs.DC](#cs.DC) [Total: 9]
- [cs.NI](#cs.NI) [Total: 6]
- [cs.AR](#cs.AR) [Total: 6]
- [cs.MA](#cs.MA) [Total: 2]
- [cs.SE](#cs.SE) [Total: 18]
- [cs.PF](#cs.PF) [Total: 1]


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [1] [Communication-Avoiding Linear Algebraic Kernel K-Means on GPUs](https://arxiv.org/abs/2601.17136)
*Julian Bellavita,Matthew Rubino,Nakul Iyer,Andrew Chang,Aditya Devarakonda,Flavio Vella,Giulia Guidi*

Main category: cs.DC

TL;DR: è¯¥è®ºæ–‡æå‡ºä¸€å¥—åˆ†å¸ƒå¼å†…å­˜å¹¶è¡Œç®—æ³•ï¼Œç”¨äºåœ¨å¤šGPUç³»ç»Ÿä¸Šå®ç°å¤§è§„æ¨¡Kernel K-meansèšç±»ï¼Œè§£å†³äº†å•GPUå†…å­˜é™åˆ¶é—®é¢˜ï¼Œä½¿æ•°æ®é›†è§„æ¨¡æå‡ä¸€åˆ°ä¸¤ä¸ªæ•°é‡çº§ã€‚


<details>
  <summary>Details</summary>
Motivation: Kernel K-meansèƒ½å¤„ç†éçº¿æ€§å¯åˆ†é›†ç¾¤ï¼Œä½†ç°æœ‰å•GPUå®ç°å—é™äºæ˜¾å­˜ï¼Œæ— æ³•å¤„ç†è¶…è¿‡çº¦8ä¸‡ä¸ªæ ·æœ¬çš„æ•°æ®é›†ï¼Œé™åˆ¶äº†å…¶å¯æ‰©å±•æ€§ã€‚

Method: è®¾è®¡äº†åˆ†å¸ƒå¼å¹¶è¡Œç®—æ³•åŠåˆ†åŒºæ–¹æ¡ˆï¼Œå°†è®¡ç®—å¯†é›†å‹ç»„ä»¶æ˜ å°„åˆ°é«˜æ•ˆé€šä¿¡çš„ä»£æ•°åŸè¯­ä¸Šï¼Œä¼˜åŒ–å¯¹æ ¸çŸ©é˜µçš„å¤„ç†ã€‚å…³é”®åˆ›æ–°æ˜¯1.5Dåˆ†åŒºç­–ç•¥ï¼Œä»¥å‡å°‘é€šä¿¡å¼€é”€ã€‚

Result: 1.5Dç®—æ³•æ€§èƒ½æœ€ä½³ï¼š256ä¸ªGPUæ—¶å‡ ä½•å¹³å‡å¼±æ‰©å±•æ•ˆç‡è¾¾79.7%ï¼Œå¼ºæ‰©å±•åŠ é€Ÿæ¯”ä¸º4.2å€ï¼›æ¯”1Dç®—æ³•å¿«3.6å€ï¼Œèšç±»æ—¶é—´ä»å°æ—¶çº§é™è‡³ç§’çº§ã€‚å¯æœ‰æ•ˆå¤„ç†ç™¾ä¸‡çº§æ•°æ®é›†ã€‚

Conclusion: ç»“åˆåº”ç”¨ç‰¹å®šä»£æ•°å…¬å¼è®¾è®¡çš„åˆ†å¸ƒå¼ç®—æ³•å¯å¤§å¹…æå‡æ€§èƒ½ï¼Œè¯æ˜å…¶åœ¨å¤„ç†å¤§æ•°æ®èšç±»ä¸­çš„å®ç”¨æ€§ã€‚

Abstract: Clustering is an important tool in data analysis, with K-means being popular for its simplicity and versatility. However, it cannot handle non-linearly separable clusters. Kernel K-means addresses this limitation but requires a large kernel matrix, making it computationally and memory intensive. Prior work has accelerated Kernel K-means by formulating it using sparse linear algebra primitives and implementing it on a single GPU. However, that approach cannot run on datasets with more than approximately 80,000 samples due to limited GPU memory.
  In this work, we address this issue by presenting a suite of distributed-memory parallel algorithms for large-scale Kernel K-means clustering on multi-GPU systems. Our approach maps the most computationally expensive components of Kernel K-means onto communication-efficient distributed linear algebra primitives uniquely tailored for Kernel K-means, enabling highly scalable implementations that efficiently cluster million-scale datasets. Central to our work is the design of partitioning schemes that enable communication-efficient composition of the linear algebra primitives that appear in Kernel K-means.
  Our 1.5D algorithm consistently achieves the highest performance, enabling Kernel K-means to scale to data one to two orders of magnitude larger than previously practical. On 256 GPUs, it achieves a geometric mean weak scaling efficiency of $79.7\%$ and a geometric mean strong scaling speedup of $4.2\times$. Compared to our 1D algorithm, the 1.5D approach achieves up to a $3.6\times$ speedup on 256 GPUs and reduces clustering time from over an hour to under two seconds relative to a single-GPU sliding window implementation. Our results show that distributed algorithms designed with application-specific linear algebraic formulations can achieve substantial performance improvement.

</details>


### [2] [Push Down Optimization for Distributed Multi Cloud Data Integration](https://arxiv.org/abs/2601.17546)
*Ravi Kiran Kodali,Vinoth Punniyamoorthy,Akash Kumar Agarwal,Bikesh Kumar,Balakrishna Pothineni,Aswathnarayan Muthukrishnan Kirubakaran,Sumit Saha,Nachiappan Chockalingam*

Main category: cs.DC

TL;DR: æœ¬æ–‡ç ”ç©¶åœ¨å¤šäº‘ETLç®¡é“ä¸­æ¨å¼ä¼˜åŒ–çš„å¯è¡Œæ€§ï¼Œåˆ†æå…¶ä¼˜ç‚¹å’Œå±€é™ï¼Œå¹¶é€šè¿‡Redshiftã€BigQueryæ¡ˆä¾‹å±•ç¤ºæ€§èƒ½æå‡ç­–ç•¥ã€‚


<details>
  <summary>Details</summary>
Motivation: ä¼ä¸šé‡‡ç”¨å¤šäº‘æ¶æ„é¢ä¸´æ•°æ®ç§»åŠ¨ã€å¼‚æ„SQLå¼•æ“å’Œå®‰å…¨æ€§ç­‰æŒ‘æˆ˜ï¼Œæ¨å¼ä¼˜åŒ–åœ¨å•äº‘ä¸­æœ‰æ•ˆï¼Œä½†åœ¨å¤šäº‘ç¯å¢ƒä¸­å­˜åœ¨éšœç¢ï¼Œéœ€æ¢ç´¢å…¶åº”ç”¨æ½œåŠ›ä»¥æå‡ETLæ•ˆç‡ã€‚

Method: è¯„ä¼°æœ¬åœ°åŒ–æ¨å¼ã€æ··åˆæ¨¡å‹ä¸æ•°æ®è”é‚¦æŠ€æœ¯ï¼Œä»¥å‡å°‘è·¨äº‘æµé‡ï¼›ç»“åˆRedshiftã€BigQueryæ¡ˆä¾‹è¿›è¡Œå®è¯åˆ†æä»¥ä¼˜åŒ–æ€§èƒ½å’Œæˆæœ¬ã€‚

Result: æ¡ˆä¾‹ç ”ç©¶æ˜¾ç¤ºæ˜¾è‘—å¢ç›Šï¼šç«¯åˆ°ç«¯è¿è¡Œæ—¶ç¼©çŸ­ã€ä¼ è¾“æ•°æ®é‡é™ä½ã€æˆæœ¬æ•ˆç›Šæé«˜ï¼Œè¯æ˜ç­–ç•¥æœ‰æ•ˆå‡å°‘äº†å¤šäº‘ETLçš„å»¶è¿Ÿå’Œå¼€æ”¯ã€‚

Conclusion: ç ”ç©¶è¡¨æ˜å®ç”¨ç­–ç•¥å¯å¢å¼ºåˆ†å¸ƒå¼äº‘ç¯å¢ƒä¸­ETLçš„å¯æ‰©å±•æ€§å’Œå¯é æ€§ï¼Œä¸ºä¼ä¸šå®æ–½å¤šäº‘æ•°æ®åˆ†ææä¾›å¯å€Ÿé‰´æ–¹æ¡ˆã€‚

Abstract: Enterprises increasingly adopt multi cloud architectures to take advantage of diverse database engines, regional availability, and cost models. In these environments, ETL pipelines must process large, distributed datasets while minimizing latency and transfer cost. Push down optimization, which executes transformation logic within database engines rather than within the ETL tool, has proven highly effective in single cloud systems. However, when applied across multiple clouds, it faces challenges related to data movement, heterogeneous SQL engines, orchestration complexity, and fragmented security controls. This paper examines the feasibility of push down optimization in multi cloud ETL pipelines and analyzes its benefits and limitations. It evaluates localized push down, hybrid models, and data federation techniques that reduce cross cloud traffic while improving performance. A case study across Redshift and BigQuery demonstrates measurable gains, including lower end to end runtime, reduced transfer volume, and improved cost efficiency. The study highlights practical strategies that organizations can adopt to improve ETL scalability and reliability in distributed cloud environments.

</details>


### [3] [A Unified Approach to Concurrent, Parallel Map-Reduce in R using Futures](https://arxiv.org/abs/2601.17578)
*Henrik Bengtsson*

Main category: cs.DC

TL;DR: futurizeåŒ…æä¾›ä¸€ä¸ªå‡½æ•°ï¼Œå°†é¡ºåºmap-reduceæ“ä½œä¸ºå¹¶è¡Œç­‰æ•ˆè½¬è¯‘ï¼Œé›†æˆå¤šç§æ¡†æ¶ï¼Œç®€åŒ–Rä¸­çš„å¹¶è¡Œè®¡ç®—ã€‚


<details>
  <summary>Details</summary>
Motivation: Rç”Ÿæ€ç³»ç»Ÿå­˜åœ¨å¤šæ ·ä¸”ä¸å…¼å®¹çš„map-reduce APIï¼Œå¹¶è¡ŒåŒ–ä»£ç éœ€å­¦ä¹ å¤šä¸ªä¸ä¸€è‡´æ¥å£ï¼Œå¢åŠ å¼€å‘éš¾åº¦ã€‚

Method: ä½¿ç”¨futurize()å‡½æ•°ï¼Œç»“åˆRç®¡é“æ“ä½œç¬¦ï¼Œå°†é¡ºåºè¡¨è¾¾å¼è½¬è¯‘ä¸ºfutureç”Ÿæ€ç³»ç»Ÿå†…çš„å¹¶è¡Œç­‰æ•ˆï¼Œæ”¯æŒæœ€å°ä»£ç é‡æ„ã€‚å…¼å®¹base Rã€purrrç­‰å¤šä¸ªåŒ…ã€‚

Result: ç”¨æˆ·è¿½åŠ `|> futurize()`å³å¯å¿«é€Ÿå¹¶è¡ŒåŒ–ä»£ç ï¼Œå¼€å‘è€…å£°æ˜å¹¶è¡Œå†…å®¹ï¼Œç”¨æˆ·é€šè¿‡plan()é€‰æ‹©å¹¶è¡Œæ–¹å¼ï¼Œå¤§å¹…å‡å°‘å­¦ä¹ æˆæœ¬ã€‚

Conclusion: é€šè¿‡æŠ½è±¡å¹¶è¡Œæœºåˆ¶å’Œç»Ÿä¸€é€‰é¡¹å¤„ç†ï¼ŒfuturizeåŒ…æ˜¾è‘—ç®€åŒ–Rä¸­çš„å¹¶è¡Œè®¡ç®—ï¼Œæå‡å¼€å‘æ•ˆç‡å’Œç”¨æˆ·ä½“éªŒã€‚

Abstract: The R ecosystem offers a rich variety of map-reduce application programming interfaces (APIs) for iterative computations, yet parallelizing code across these diverse frameworks requires learning multiple, often incompatible, parallel APIs. The futurize package addresses this challenge by providing a single function, futurize(), which transpiles sequential map-reduce expressions into their parallel equivalents in the future ecosystem, which performs all the heavy lifting. By leveraging R's native pipe operator, users can parallelize existing code with minimal refactoring -- often by simply appending `|> futurize()' to an expression. The package supports classical map-reduce functions from base R, purrr, crossmap, foreach, plyr, BiocParallel, e.g., lapply(xs, fcn) |> futurize() and map(xs, fcn) |> futurize(), as well as a growing set of domain-specific packages, e.g., boot, caret, glmnet, lme4, mgcv, and tm. By abstracting away the underlying parallel machinery, and unifying handling of future options, the package enables developers to declare what to parallelize via futurize(), and end-users to choose how via plan(). This article describes the philosophy, design, and implementation of futurize, demonstrates its usage across various map-reduce paradigms, and discusses its role in simplifying parallel computing in R.

</details>


### [4] [Scaling All-to-all Operations Across Emerging Many-Core Supercomputers](https://arxiv.org/abs/2601.17606)
*Shannon Kinkead,Jackson Wesley,Whit Schonbein,David DeBonis,Matthew G. F. Dosanjh,Amanda Bienz*

Main category: cs.DC

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Performant all-to-all collective operations in MPI are critical to fast Fourier transforms, transposition, and machine learning applications. There are many existing implementations for all-to-all exchanges on emerging systems, with the achieved performance dependent on many factors, including message size, process count, architecture, and parallel system partition. This paper presents novel all-to-all algorithms for emerging many-core systems. Further, the paper presents a performance analysis against existing algorithms and system MPI, with novel algorithms achieving up to 3x speedup over system MPI at 32 nodes of state-of-the-art Sapphire Rapids systems.

</details>


### [5] [Multi-core & GPU-based Balanced Butterfly Counting in Signed Bipartite Graphs](https://arxiv.org/abs/2601.17707)
*Mekala Kiran,Apurba Das,Suman Banerjee,Tathagata Ray*

Main category: cs.DC

TL;DR: æœ¬æ–‡å¼€å‘äº†å¹¶è¡Œç®—æ³•M-BBCç”¨äºå¤šæ ¸CPUå’ŒG-BBCç”¨äºGPUï¼Œæ”¹è¿›ç‰ˆG-BBC++åŠ å…¥åŠ¨æ€è°ƒåº¦ï¼Œä»¥åŠ é€Ÿå¹³è¡¡è´è¶è®¡æ•°ï¼Œå¹¶åœ¨å¤§è§„æ¨¡æœ‰ç¬¦å·äºŒåˆ†å›¾ä¸Šå®ç°æ˜¾è‘—æé€Ÿã€‚


<details>
  <summary>Details</summary>
Motivation: å¹³è¡¡è´è¶è®¡æ•°æ˜¯åˆ†ææœ‰ç¬¦å·äºŒåˆ†å›¾çš„åŸºç¡€ä»»åŠ¡ï¼Œä½†ç°æœ‰ä¸²è¡Œæ–¹æ³•è®¡ç®—æˆæœ¬é«˜ï¼Œæˆä¸ºå¤§è§„æ¨¡å›¾åˆ†æçš„ç“¶é¢ˆ Ø­ÙˆØ²Ù‡ã€‚

Method: æå‡ºM-BBCç®—æ³•ï¼ŒåŸºäºç»†ç²’åº¦é¡¶ç‚¹çº§å¹¶è¡Œæ¶ˆé™¤ä¸å¹³è¡¡å­ç»“æ„ï¼›GPUæ–¹æ³•G-BBCé‡‡ç”¨åŸºäºtileçš„å¹¶è¡Œç­–ç•¥ä¼˜åŒ–å…±äº«å†…å­˜ï¼Œå¢å¼ºç‰ˆG-BBC++é›†æˆåŠ¨æ€è°ƒåº¦å‡è¡¡è´Ÿè½½ã€‚

Result: åœ¨15ä¸ªçœŸå®æ•°æ®é›†å®éªŒä¸­ï¼ŒM-BBCæ¯”åºåˆ—åŸºå‡†BB2Kæœ€é«˜åŠ é€Ÿ71.13å€ï¼ˆå¹³å‡38.13å€ï¼‰ï¼›GPUç®—æ³•æ¯”BB2Kæœ€é«˜åŠ é€Ÿ13,320å€ï¼ˆå¹³å‡2,600å€ï¼‰ï¼Œæ¯”M-BBCæœ€é«˜åŠ é€Ÿ186å€ï¼ˆå¹³å‡50å€ï¼‰ã€‚

Conclusion: å¹¶è¡Œç®—æ³•æå¤§æå‡äº†å¯æ‰©å±•æ€§å’Œæ•ˆç‡ï¼Œä¸ºå¤§è§„æ¨¡äºŒåˆ†å›¾çš„é«˜æ€§èƒ½ç­¾å­—æ¨¡å¼åˆ†æå¥ å®šäº†åšå®åŸºç¡€ã€‚

Abstract: Balanced butterfly counting, corresponding to counting balanced (2, 2)-bicliques, is a fundamental primitive in the analysis of signed bipartite graphs and provides a basis for studying higher-order structural properties such as clustering coefficients and community structure. Although prior work has proposed an efficient CPU-based serial method for counting balanced (2, k)-bicliques. The computational cost of balanced butterfly counting remains a major bottleneck on large-scale graphs. In this work, we present the highly parallel implementations for balanced butterfly counting for both multicore CPUs and GPUs. The proposed multi-core algorithm (M-BBC) employs fine-grained vertex-level parallelism to accelerate wedge-based counting while eliminating the generation of unbalanced substructures. To improve scalability, we develop a GPU-based method (G-BBC) that uses a tile-based parallel approach to effectively leverage shared memory while handling large vertex sets. We then present an improved variation, G-BBC++, which integrates dynamic scheduling to mitigate workload imbalance and maximize throughput. We conduct an experimental assessment of the proposed methods across 15 real-world datasets. Experimental results exhibit that M-BBC achieves speedups of up to 71.13x (average 38.13x) over the sequential baseline BB2K. The GPU-based algorithms deliver even greater improvements, achieving up to 13,320x speedup (average 2,600x) over BB2K and outperforming M-BBC by up to 186x (average 50x). These results indicate the substantial scalability and efficiency of our parallel algorithms and establish a robust foundation for high-performance signed motif analysis on massive bipartite graphs.

</details>


### [6] [An MLIR Lowering Pipeline for Stencils at Wafer-Scale](https://arxiv.org/abs/2601.17754)
*Nicolai Stawinoga,David Katz,Anton Lydike,Justs Zarins,Nick Brown,George Bisbas,Tobias Grosser*

Main category: cs.DC

TL;DR: æå‡ºç¼–è¯‘å™¨æµç¨‹å°†æ¨¡æ¿è®¡ç®—è‡ªåŠ¨è½¬åŒ–ä¸ºCSLä»£ç ï¼Œåœ¨Cerebras WSEä¸Šå®ç°é«˜æ€§èƒ½ï¼Œæ— éœ€ä¿®æ”¹åº”ç”¨å±‚ä»£ç ï¼Œæ€§èƒ½è¶…è¶ŠGPUå’ŒCPUé›†ç¾¤ã€‚


<details>
  <summary>Details</summary>
Motivation: WSEå¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ä¸ä¼ ç»ŸHPCç¼–ç¨‹å·®å¼‚å¤§ï¼Œä¸”ç¼–è¯‘å™¨ç¼ºä¹WSEæ”¯æŒï¼Œéœ€æ‰‹åŠ¨ç§»æ¤ä»£ç ã€‚æ¨¡æ¿è®¡ç®—åœ¨HPCä¸­æ™®éå­˜åœ¨ï¼Œå¯åˆ©ç”¨é¢†åŸŸç‰¹å¼‚æ€§å®ç°è‡ªåŠ¨åŒ–ç§»æ¤ã€‚

Method: å¼€å‘ç¼–è¯‘å™¨æµç¨‹ï¼Œå°†æ¨¡æ¿å†…æ ¸è½¬æ¢ä¸ºä¼˜åŒ–CSLä»£ç ï¼Œå¼¥åˆæ•°å­¦é—®é¢˜æè¿°ä¸WSEå¼‚æ­¥æ‰§è¡Œæ¨¡å‹é—´çš„è¯­ä¹‰é¸¿æ²Ÿã€‚ä½¿ç”¨äº”ç»„åŸºå‡†æµ‹è¯•ï¼Œè¦†ç›–ä¸‰ç§HPCæŠ€æœ¯å¹³å°ã€‚

Result: æ€§èƒ½ä¸äººå·¥ä¼˜åŒ–ä»£ç ç›¸å½“ç”šè‡³æ›´ä¼˜ï¼›WSE3ä¸Šé€Ÿåº¦è¾¾128å—Nvidia A100 GPUçš„14å€ï¼Œ128èŠ‚ç‚¹Cray-EXè¶…ç®—çš„20å€ã€‚

Conclusion: é¢†åŸŸç‰¹å®šç¼–è¯‘èƒ½é«˜æ•ˆè‡ªåŠ¨åŒ–ç§»æ¤æ¨¡æ¿è®¡ç®—è‡³WSEï¼Œè¯æ˜å…¶å¯æ›¿ä»£ä¼ ç»ŸHPCç¡¬ä»¶å¹¶æ˜¾è‘—æå‡æ€§èƒ½ï¼Œçªç ´ç¼–è¯‘å™¨ä¸æ”¯æŒçš„é™åˆ¶ã€‚

Abstract: The Cerebras Wafer-Scale Engine (WSE) delivers performance at an unprecedented scale of over 900,000 compute units, all connected via a single-wafer on-chip interconnect. Initially designed for AI, the WSE architecture is also well-suited for High Performance Computing (HPC). However, its distributed asynchronous programming model diverges significantly from the simple sequential or bulk-synchronous programs that one would typically derive for a given mathematical program description. Targeting the WSE requires a bespoke re-implementation when porting existing code. The absence of WSE support in compilers such as MLIR, meant that there was little hope for automating this process.
  Stencils are ubiquitous in HPC, and in this paper we explore the hypothesis that domain specific information about stencils can be leveraged by the compiler to automatically target the WSE without requiring application-level code changes. We present a compiler pipeline that transforms stencil-based kernels into highly optimized CSL code for the WSE, bridging the semantic gap between the mathematical representation of the problem and the WSE's asynchronous execution model. Based upon five benchmarks across three HPC programming technologies, running on both the Cerebras WSE2 and WSE3, our approach delivers comparable, if not slightly better, performance than manually optimized code. Furthermore, without requiring any application level code changes, performance on the WSE3 is around 14 times faster than 128 Nvidia A100 GPUs and 20 times faster than 128 nodes of a CPU-based Cray-EX supercomputer when using our approach.

</details>


### [7] [CondenseGraph: Communication-Efficient Distributed GNN Training via On-the-Fly Graph Condensation](https://arxiv.org/abs/2601.17774)
*Zizhao Zhang,Yihan Xue,Haotian Zhu,Sijia Li,Zhijun Wang,Yujie Xiao*

Main category: cs.DC

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Distributed Graph Neural Network (GNN) training suffers from substantial communication overhead due to the inherent neighborhood dependency in graph-structured data. This neighbor explosion problem requires workers to frequently exchange boundary node features across partitions, creating a communication bottleneck that severely limits training scalability. Existing approaches rely on static graph partitioning strategies that cannot adapt to dynamic network conditions. In this paper, we propose CondenseGraph, a novel communication-efficient framework for distributed GNN training. Our key innovation is an on-the-fly graph condensation mechanism that dynamically compresses boundary node features into compact super nodes before transmission. To compensate for the information loss introduced by compression, we develop a gradient-based error feedback mechanism that maintains convergence guarantees while reducing communication volume by 40-60%. Extensive experiments on four benchmark datasets demonstrate that CondenseGraph achieves comparable accuracy to full-precision baselines while significantly reducing communication costs and training time.

</details>


### [8] [A Universal Load Balancing Principle and Its Application to Large Language Model Serving](https://arxiv.org/abs/2601.17855)
*Zixi Chen,Tianci Bu,Chendong Song,Xin Lu,Yinyu Ye,Zijie Zhou*

Main category: cs.DC

TL;DR: é’ˆå¯¹å¤§è§„æ¨¡è¯­è¨€æ¨¡å‹(LLM)æœåŠ¡ä¸­åŒæ­¥å±éšœå¯¼è‡´çš„èµ„æºé—²ç½®é—®é¢˜ï¼Œæå‡ºäº†ä¸€ç§é€šç”¨è´Ÿè½½å‡è¡¡ä¼˜åŒ–æ¡†æ¶ï¼Œé€šè¿‡åˆ†æ­¥æ•´æ•°ä¼˜åŒ–å‡å°‘å»¶è¿Ÿå·®å¼‚ï¼Œæå‡ç³»ç»Ÿæ•ˆç‡ã€‚


<details>
  <summary>Details</summary>
Motivation: åœ¨æ•°æ®å¹¶è¡Œè§£ç çš„LLMæœåŠ¡ä¸­ï¼Œç³»ç»Ÿå±éšœåŒæ­¥å¯¼è‡´çš„èµ„æºé—²ç½®ç‡å¯è¾¾40%ä»¥ä¸Šï¼Œå¼‚æ„å·¥ä½œè´Ÿè½½å¼•å‘çš„è½åèŠ‚ç‚¹ä¸¥é‡é™åˆ¶äº†æ•´ä½“æ€§èƒ½ã€‚

Method: å»ºç«‹åˆ†æ­¥æœ‰é™èŒƒå›´æ•´æ•°ä¼˜åŒ–æ¨¡å‹ï¼Œæ„å»ºå…·æœ‰æœ€åæƒ…å†µä¿éšœçš„é€šç”¨è´Ÿè½½å‡è¡¡åŸç†ï¼Œé€‚åº”å„ç±»éé€’å‡å‹å·¥ä½œè´Ÿè½½ kiedyã€‚

Result: å®éªŒéªŒè¯ï¼šåœ¨LLMè§£ç åœºæ™¯ä¸‹ï¼Œç³»ç»Ÿè§„æ¨¡æ‰©å¤§æ—¶é•¿æœŸè´Ÿè½½ä¸å‡è¡¡æ˜¾è‘—æ”¹å–„ï¼Œååé‡æå‡12.8%ï¼Œå»¶è¿Ÿé™ä½31%ï¼Œèƒ½è€—å‡å°‘19%ã€‚

Conclusion: ä¸ºåŒæ­¥é—¨æ§ç³»ç»Ÿæä¾›äº†ç†è®ºå®Œå¤‡çš„è´Ÿè½½å‡è¡¡æ¡†æ¶ï¼Œå¯¹å¯æŒç»­LLMæœåŠ¡åŠå…¶ä»–èµ„æºåˆ†é…åœºæ™¯å…·æœ‰æ™®é€‚ä»·å€¼ã€‚

Abstract: Load balancing-the allocation of work across parallel resources to reduce delay, energy and cost-is a pervasive challenge in science and engineering, from large-scale simulation and data processing to cloud and manufacturing operations. Motivated by the emerging bottleneck in large language model (LLM) serving, we study a particularly stringent regime of load balancing that arises in barrier-synchronized, stateful systems: work cannot be freely migrated and progress is gated by the slowest participant at each step, so heterogeneity and temporal drift in workloads create persistent stragglers and substantial idle time. LLM serving under data-parallel decoding provides a prominent modern instance: in production traces, barrier-induced idle can exceed 40% of compute time per decode step. Here we develop a universal load-balancing principle, which admits a step-wise finite-horizon integer-optimization formulation and yields worst-case guarantees: across LLM decode models and a broader class of non-decreasing workload drift processes, it reduces long-run imbalance by a factor that grows with batch size and system scale. Extensive experiments corroborate the theory, showing substantial improvements in throughput and latency together with reductions in energy consumption. These results provide a general, theoretically grounded framework for load balancing, with immediate implications for sustainable LLM serving and broad relevance to other synchronization-gated resource-allocation problems.

</details>


### [9] [An Initial Evaluation of Distributed Graph Algorithms using NWGraph and HPX](https://arxiv.org/abs/2601.18158)
*Karame Mohammadiporshokooh,Panagiotis Syskakis,Hartmut Kaiser*

Main category: cs.DC

TL;DR: æœ¬è®ºæ–‡æå‡ºåˆ†å¸ƒå¼å›¾å¤„ç†æ–¹æ¡ˆï¼Œç»“åˆNWGraphåº“å’ŒHPXè¿è¡Œæ—¶ç³»ç»Ÿï¼Œæ—¨åœ¨å‡å°‘åŒæ­¥å¼€é”€å¹¶æå‡è´Ÿè½½å‡è¡¡ï¼ŒBFSæ€§èƒ½ä¼˜äºBGLä½†PageRankä»æœ‰æŒ‘æˆ˜ã€‚


<details>
  <summary>Details</summary>
Motivation: è§£å†³ç°æœ‰åˆ†å¸ƒå¼å›¾æ¡†æ¶çš„å±€é™æ€§ï¼Œå¦‚é«˜å»¶è¿Ÿã€ä¸è§„åˆ™å†…å­˜è®¿é—®å’ŒåŒæ­¥æˆæœ¬å¯¼è‡´çš„æ•ˆç‡ä½ä¸‹é—®é¢˜ã€‚

Method: é‡‡ç”¨HPXçš„å¼‚æ­¥å¤šä»»åŠ¡æ¨¡å‹é›†æˆNWGraphåº“ï¼Œæ„å»ºåˆ†å¸ƒå¼å›¾åˆ†ææ¡†æ¶ä»¥æé«˜å¯ä¼¸ç¼©æ€§ã€‚

Result: å®éªŒæ˜¾ç¤ºBFSç®—æ³•æ€§èƒ½ä¼˜äºåˆ†å¸ƒå¼Boost Graph Libraryï¼Œè€ŒPageRankç®—æ³•å°šæœªè¶…è¶ŠBGLã€‚

Conclusion: å¼‚æ­¥ä»»åŠ¡è¿è¡Œæ—¶åº”ç”¨äºå›¾å¤„ç†æ½œåŠ›æ˜¾è‘—ä½†æŒ‘æˆ˜ç°å­˜ï¼Œéœ€æœªæ¥ä¼˜åŒ–ç®—æ³•æ€§èƒ½å’Œæ‰©å±•æ€§ã€‚

Abstract: Graphs are central to modeling relationships in scientific computing, data analysis, and AI/ML, but their growing scale can exceed the memory and compute capacity of single nodes, requiring distributed solutions. Existing distributed graph framework, however, face fundamental challenges: graph algorithms are latency-bound, suffer from irregular memory access, and often impose synchronization costs that limit scalability and efficiency. In this work, we present a distributed implementation of the NWGraph library integrated with the HPX runtime system. By leveraging HPX's asynchronous many-task model, our approach aims to reduce synchronization overhead, improve load balance, and provide a foundation for distributed graph analytics. We evaluate this approach using two representative algorithms: Breadth-First-Search (BFS) and (PageRank). Our initial results show that BFS achieves better performance than the distributed Boost Graph Library (BGL), while PageRank remains more challenging, with current implementation not yet outperforming BGL. These findings highlight both the promise and the open challenges of applying asynchronous task-based runtimes to graph processing, and point to opportunities for future optimizations and extensions.

</details>


<div id='cs.NI'></div>

# cs.NI [[Back]](#toc)

### [10] [Efficient Self-Learning and Model Versioning for AI-native O-RAN Edge](https://arxiv.org/abs/2601.17534)
*Mounir Bensalem,Fin Gentzen,Tuck-Wai Choong,Yu-Chiao Jhuang,Admela Jukan,Jenq-Shiou Leu*

Main category: cs.NI

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: The AI-native vision of 6G requires Radio Access Networks to train, deploy, and continuously refine thousands of machine learning (ML) models that drive real-time radio network optimization. Although the Open RAN (O-RAN) architecture provides open interfaces and an intelligent control plane, it leaves the life-cycle management of these models unspecified. Consequently, operators still rely on ad-hoc, manual update practices that can neither scale across the heterogeneous, multi-layer stack of Cell-Site, Edge-, Regional-, and Central-Cloud domains, nor across the three O-RAN control loops (real-, near-real-, and non-real-time). We present a self-learning framework that provides an efficient closed-loop version management for an AI-native O-RAN edge. In this framework, training pipelines in the Central/Regional Cloud continuously generate new models, which are cataloged along with their resource footprints, security scores, and accuracy metrics in a shared version repository. An Update Manager consults this repository and applies a self-learning policy to decide when and where each new model version should be promoted into operation. A container orchestrator then realizes these decisions across heterogeneous worker nodes, enabling multiple services (rApps, xApps, and dApps) to obtain improved inference with minimal disruption. Simulation results show that an efficient RL-driven decision-making can guarantee quality of service, bounded latencies while balancing model accuracy, system stability, and resilience.

</details>


### [11] [Structure-Aware NL-to-SQL for SFC Provisioning via AST-Masking Empowered Language Models](https://arxiv.org/abs/2601.17295)
*Xinyu Zhu,Parisa Fard Moshiri,Poonam Lohan,Burak Kantarci,Emil Janulewicz*

Main category: cs.NI

TL;DR: æå‡ºAST-Maskingæ–¹æ³•ï¼Œé€šè¿‡SQLæŠ½è±¡è¯­æ³•æ ‘è¿›è¡Œç»“æ„æ„ŸçŸ¥å¾®è°ƒï¼Œæ˜¾è‘—æé«˜å¤§å‹è¯­è¨€æ¨¡å‹åœ¨SFCç¼–æ’ä¸­çš„SQLç”Ÿæˆå‡†ç¡®æ€§å’Œæ•ˆç‡ã€‚


<details>
  <summary>Details</summary>
Motivation: å¼ºåŒ–å­¦ä¹ æå‡SFCç¼–æ’é€‚åº”æ€§ä½†å¿½ç•¥ç»“æ„åŒ–çŸ¥è¯†ï¼Œå¯¼è‡´é€šç”¨åŒ–å’Œå¯è§£é‡Šæ€§å—é™ï¼Œä¸”ä¼ ç»Ÿå¾®è°ƒäº§ç”Ÿçš„SQLå­˜åœ¨è¯­æ³•é”™è¯¯å’Œä½æ•ˆé—®é¢˜ã€‚

Method: é‡‡ç”¨AST-MaskingæŠ€æœ¯ï¼Œåˆ©ç”¨SQLæŠ½è±¡è¯­æ³•æ ‘ä¸ºå…³é”®ç»„ä»¶ ............................................................................................................åˆ†é…æƒé‡ï¼Œå®æ–½è½»é‡åŒ–è¯­æ³•æ„ŸçŸ¥å­¦ä¹ ï¼Œé¿å…é¢å¤–æ¨ç†å¼€é”€ã€‚

Result: å®éªŒè¡¨æ˜SQLç”Ÿæˆå‡†ç¡®æ€§å¤§å¹…æå‡ï¼šFLAN-T5æ‰§è¡Œç²¾åº¦è¾¾99.6%ï¼ŒGemmaç»å¯¹å¢ç›Šæœ€å¤§ï¼Œä»7.5%æé«˜åˆ°72.0%ã€‚

Conclusion: ç»“æ„æ„ŸçŸ¥å¾®è°ƒç¡®ä¿è¯­æ³•æ­£ç¡®é«˜æ•ˆSQLç”Ÿæˆï¼Œæœ‰æ•ˆæ”¯æŒå¯è§£é‡Šçš„SFCç¼–æ’ï¼Œè¯å®è¯¥æ–¹æ³•åœ¨å„ç±»è¯­è¨€æ¨¡å‹ä¸­çš„å¯é æ€§ã€‚

Abstract: Effective Service Function Chain (SFC) provisioning requires precise orchestration in dynamic and latency-sensitive networks. Reinforcement Learning (RL) improves adaptability but often ignores structured domain knowledge, which limits generalization and interpretability. Large Language Models (LLMs) address this gap by translating natural language (NL) specifications into executable Structured Query Language (SQL) commands for specification-driven SFC management. Conventional fine-tuning, however, can cause syntactic inconsistencies and produce inefficient queries. To overcome this, we introduce Abstract Syntax Tree (AST)-Masking, a structure-aware fine-tuning method that uses SQL ASTs to assign weights to key components and enforce syntax-aware learning without adding inference overhead. Experiments show that AST-Masking significantly improves SQL generation accuracy across multiple language models. FLAN-T5 reaches an Execution Accuracy (EA) of 99.6%, while Gemma achieves the largest absolute gain from 7.5% to 72.0%. These results confirm the effectiveness of structure-aware fine-tuning in ensuring syntactically correct and efficient SQL generation for interpretable SFC orchestration.

</details>


### [12] [Diffusion Model-based Reinforcement Learning for Version Age of Information Scheduling: Average and Tail-Risk-Sensitive Control](https://arxiv.org/abs/2601.18069)
*Haoyuan Pan,Sizhao Chen,Zhaorui Wang,Tse-Tin Chan*

Main category: cs.NI

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Ensuring timely and semantically accurate information delivery is critical in real-time wireless systems. While Age of Information (AoI) quantifies temporal freshness, Version Age of Information (VAoI) captures semantic staleness by accounting for version evolution between transmitters and receivers. Existing VAoI scheduling approaches primarily focus on minimizing average VAoI, overlooking rare but severe staleness events that can compromise reliability under stochastic packet arrivals and unreliable channels. This paper investigates both average-oriented and tail-risk-sensitive VAoI scheduling in a multi-user status update system with long-term transmission cost constraints. We first formulate the average VAoI minimization problem as a constrained Markov decision process and introduce a deep diffusion-based Soft Actor-Critic (D2SAC) algorithm. By generating actions through a diffusion-based denoising process, D2SAC enhances policy expressiveness and establishes a strong baseline for mean performance. Building on this foundation, we put forth RS-D3SAC, a risk-sensitive deep distributional diffusion-based Soft Actor-Critic algorithm. RS-D3SAC integrates a diffusion-based actor with a quantile-based distributional critic, explicitly modeling the full VAoI return distribution. This enables principled tail-risk optimization via Conditional Value-at-Risk (CVaR) while satisfying long-term transmission cost constraints. Extensive simulations show that, while D2SAC reduces average VAoI, RS-D3SAC consistently achieves substantial reductions in CVaR without sacrificing mean performance. The dominant gain in tail-risk reduction stems from the distributional critic, with the diffusion-based actor providing complementary refinement to stabilize and enrich policy decisions, highlighting their effectiveness for robust and risk-aware VAoI scheduling in multi-user wireless systems.

</details>


### [13] [A Mechanical Wi-Fi Antenna Device for Automatic Orientation Tuning with Bayesian Optimization](https://arxiv.org/abs/2601.18256)
*Akihito Taya,Yuuki Nishiyama,Kaoru Sezaki*

Main category: cs.NI

TL;DR: ç ”ç©¶äººå‘˜å¼€å‘äº†ä¸€ç§æœºæ¢°Wi-Fiå¤©çº¿è®¾å¤‡ï¼Œé€šè¿‡è‡ªåŠ¨è°ƒæ•´å¤©çº¿æ–¹å‘ä¼˜åŒ–é€šä¿¡æ€§èƒ½


<details>
  <summary>Details</summary>
Motivation: éä¸“ä¸šç”¨æˆ·éš¾ä»¥ç¡®å®šæœ€ä½³å¤©çº¿æ–¹å‘ï¼Œå¸¸å¯¼è‡´å¤©çº¿å¤„äºæ— æ•ˆä½ç½®è€Œé™ä½Wi-Fiæ€§èƒ½

Method: ç ”åˆ¶èƒ½è‡ªåŠ¨è°ƒèŠ‚æ–¹å‘çš„æœºæ¢°Wi-Fiå¤©çº¿è®¾å¤‡ï¼Œå¹¶é‡‡ç”¨è´å¶æ–¯ä¼˜åŒ–æŠ€æœ¯è¿›è¡Œæ–¹å‘è°ƒè°

Result: å®éªŒæ˜¾ç¤ºï¼Œğ“”çº¿æ¡ä»¶ä¸‹å¤©çº¿æ–¹å‘å˜åŒ–å¯å¯¼è‡´ååé‡å˜åŠ¨çº¦70 Mbpsï¼Œè´å¶æ–¯ä¼˜åŒ–æ¯”éšæœºæœç´¢æ›´æœ‰æ•ˆ

Conclusion: è‡ªåŠ¨å¤©çº¿æ–¹å‘è°ƒè°å¯è¡Œï¼Œèƒ½æ˜¾è‘—æå‡Wi-Fié€šä¿¡æ•ˆæœ

Abstract: Wi-Fi access points have been widely deployed in homes, offices, and public spaces. Some APs allow users to adjust the antenna orientation to improve communication performance by optimizing antenna polarization. However, it is difficult for non-expert users to determine the optimal orientation, and users often leave the antenna orientation in ineffective positions. To address this issue, we developed a mechanical Wi-Fi antenna device capable of automatically tuning its orientation. Experimental results show that antenna orientation could cause a throughput variation of approximately 70 Mbps under line-of-sight conditions. Furthermore, Bayesian optimization identified better configurations than random search, demonstrating its effectiveness for orientation tuning.

</details>


### [14] [CovertComBench: The First Domain-Specific Testbed for LLMs in Wireless Covert Communication](https://arxiv.org/abs/2601.18315)
*Zhaozhi Liu,Jiaxin Chen,Yuanai Xie,Yuna Jiang,Minrui Xu,Xiao Zhang,Pan Lai,Zan Zhou*

Main category: cs.NI

TL;DR: æœ¬ç ”ç©¶å¼•å…¥CovertComBenchåŸºå‡†æµ‹è¯•ï¼Œè¯„ä¼°å¤§å‹è¯­è¨€æ¨¡å‹åœ¨æ— çº¿éšè”½é€šä¿¡ä¸­çš„èƒ½åŠ›ï¼ŒæŒ‡å‡ºæ¨¡å‹åœ¨æ•°å­¦æ¨å¯¼æ–¹é¢å­˜åœ¨å±€é™ã€‚


<details>
  <summary>Details</summary>
Motivation: ç°æœ‰åŸºå‡†æµ‹è¯•æ— æ³•å……åˆ†è¯„ä¼°LLMåœ¨ä¸¥æ ¼å®‰å…¨çº¦æŸï¼ˆå¦‚Kullback-Leibleræ•£åº¦ï¼‰ä¸‹çš„è¡¨ç°ï¼Œå¯¼è‡´å…¶åœ¨éšè”½é€šä¿¡é¢†åŸŸåº”ç”¨çš„ä¸è¶³æœªè¢«æ­ç¤ºã€‚

Method: å¼€å‘ç»¼åˆæ€§åŸºå‡†CovertComBenchï¼ŒåŒ…æ‹¬æ¦‚å¿µç†è§£é¢˜(MCQs)ã€ä¼˜åŒ–æ¨å¯¼é¢˜(ODQs)å’Œä»£ç ç”Ÿæˆé¢˜(CGQs)ï¼Œå¹¶é‡‡ç”¨æ£€æµ‹ç†è®ºæ¡†æ¶è¿›è¡Œè‡ªåŠ¨åŒ–è¯„åˆ†åˆ†æã€‚

Result: LLMåœ¨æ¦‚å¿µè¯†åˆ«å‡†ç¡®ç‡è¾¾81%ï¼Œä»£ç å®ç°83%ï¼Œä½†æ¶‰åŠå®‰å…¨ä¼˜åŒ–çš„æ•°å­¦æ¨å¯¼è¡¨ç°è¾ƒå·®ï¼Œå‡†ç¡®ç‡ä»…ä¸º18%è‡³55%ã€‚

Conclusion: å½“å‰LLMä»…é€‚åˆä½œå®ç°è¾…åŠ©å·¥å…·ï¼Œæœªæ¥åº”å¼ºåŒ–å¤–éƒ¨å·¥å…·é›†æˆä»¥æé«˜æ— çº¿AIç³»ç»Ÿçš„å¯é æ€§ã€‚

Abstract: The integration of Large Language Models (LLMs) into wireless networks presents significant potential for automating system design. However, unlike conventional throughput maximization, Covert Communication (CC) requires optimizing transmission utility under strict detection-theoretic constraints, such as Kullback-Leibler divergence limits. Existing benchmarks primarily focus on general reasoning or standard communication tasks and do not adequately evaluate the ability of LLMs to satisfy these rigorous security constraints. To address this limitation, we introduce CovertComBench, a unified benchmark designed to assess LLM capabilities across the CC pipeline, encompassing conceptual understanding (MCQs), optimization derivation (ODQs), and code generation (CGQs). Furthermore, we analyze the reliability of automated scoring within a detection-theoretic ``LLM-as-Judge'' framework. Extensive evaluations across state-of-the-art models reveal a significant performance discrepancy. While LLMs achieve high accuracy in conceptual identification (81%) and code implementation (83%), their performance in the higher-order mathematical derivations necessary for security guarantees ranges between 18% and 55%. This limitation indicates that current LLMs serve better as implementation assistants rather than autonomous solvers for security-constrained optimization. These findings suggest that future research should focus on external tool augmentation to build trustworthy wireless AI systems.

</details>


### [15] [An ISAC-ready Full-Duplex Backscatter Architecture for the mmWave IoT](https://arxiv.org/abs/2601.18727)
*Skanda Harisha,Jimmy G. D. Hester,Aline Eid*

Main category: cs.NI

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Achieving long-range, high-rate, concurrent two-way mmWave communication with power-constrained IoT devices is fundamental to scaling future ubiquitous sensing systems, yet the substantial power demands and high cost of mmWave hardware have long stood in the way of practical deployment. This paper presents the first mmWave full-duplex backscatter tag architecture, charting a genuinely low-cost path toward high-performance mmWave connectivity and localization for ISAC systems. The proposed tag operates at ranges beyond 45m on the uplink and beyond 200m on the downlink, delivering 20x the reach of state-of-the-art systems while being over 100x cheaper than existing mmWave backscatter platforms. Enabling this leap is a novel low-power regenerative amplifier that provides 30 dB of gain while consuming only 30 mW, paired with a regenerative rectifier that achieves state-of-the-art sensitivity down to -60 dBm. We integrate our circuits on a compact PCB and evaluate it across diverse uplink and downlink scenarios, where it achieves an downlink BER of $10^{-1}$ at 200 meters and a uplink BER of $10^{-2}$ at 45 meters, demonstrating resilient, high-quality communication even at extended ranges.

</details>


<div id='cs.AR'></div>

# cs.AR [[Back]](#toc)

### [16] [Conduit: Programmer-Transparent Near-Data Processing Using Multiple Compute-Capable Resources in Solid State Drives](https://arxiv.org/abs/2601.17633)
*Rakesh Nadig,Vamanan Arulchelvan,Mayank Kabra,Harshita Gupta,Rahul Bera,Nika Mansouri Ghiasi,Nanditha Rao,Qingcai Jiang,Andreas Kosmas Kakolyris,Yu Liang,Mohammad Sadrosadati,Onur Mutlu*

Main category: cs.AR

TL;DR: Conduitæ˜¯ä¸€ç§é€šç”¨çš„SSDè¿‘æ•°æ®å¤„ç†ï¼ˆNDPï¼‰æ¡†æ¶ï¼Œé€šè¿‡æ•´åˆå¤šä¸ªSSDè®¡ç®—èµ„æºæå‡æ€§èƒ½å’Œèƒ½æ•ˆã€‚


<details>
  <summary>Details</summary>
Motivation: ç°æœ‰NDPæŠ€æœ¯ä»…åˆ©ç”¨SSDéƒ¨åˆ†èŒƒå¼ï¼ˆå¦‚ISPã€PuD-SSDæˆ–IFPï¼‰ï¼Œå­˜åœ¨å±€é™æ€§ï¼›å®ƒä»¬é’ˆå¯¹ç‰¹å®šè´Ÿè½½ã€æ— æ³•å……åˆ†åˆ©ç”¨SSDç®—åŠ›ä¸”ç¼ºä¹ç¨‹åºå‘˜é€æ˜æ€§ï¼Œè€Œä»¥å¾€åˆ†åŒºè®¡ç®—æŠ€æœ¯å¿½ç•¥äº†SSDèµ„æºå¼‚æ„æ€§å’Œå†³ç­–å› ç´ ä¸è¶³ã€‚

Method: åœ¨ç¼–è¯‘æ—¶é€šè¿‡LLVMè‡ªå®šä¹‰è¿›ç¨‹å°†ä»£ç å‘é‡åŒ–ä¸SSDé¡µå¯¹é½ï¼Œå¹¶åµŒå…¥å…ƒæ•°æ®ï¼›è¿è¡Œæ—¶åŸºäºå…­ç§ç‰¹å¾å’Œæˆæœ¬å‡½æ•°è¿›è¡ŒæŒ‡ä»¤çº§å¸è½½ï¼Œè‡ªåŠ¨é€‰æ‹©æœ€ä¼˜SSDèµ„æºæ‰§è¡Œã€‚

Result: åœ¨è‡ªç ”äº‹ä»¶é©±åŠ¨SSDä»¿çœŸå™¨å’Œå…­ä¸ªæ•°æ®å¯†é›†è´Ÿè½½æµ‹è¯•ä¸­ï¼ŒConduitæ¯”æœ€ä¼˜å…ˆå‰æ–¹æ¡ˆæé€Ÿ1.8å€å¹¶é™ä½èƒ½è€—46%ã€‚

Conclusion: Conduitå®ç°äº†SSDå¼‚æ„èµ„æºçš„é«˜æ•ˆç»Ÿä¸€åˆ©ç”¨ï¼Œä¸ºé€šç”¨NDPæä¾›äº†é€æ˜è§£å†³æ–¹æ¡ˆï¼Œæ˜¾è‘—æå‡SSDè®¡ç®—æ½œåŠ›ã€‚

Abstract: Solid-state drives (SSDs) are well suited for near-data processing (NDP) because they: (1) store large application datasets, and (2) support three NDP paradigms: in-storage processing (ISP), processing using DRAM in the SSD (PuD-SSD), and in-flash processing (IFP). A large body of prior SSD-based NDP techniques operate in isolation, mapping computations to only one or two NDP paradigms (i.e., ISP, PuD-SSD, or IFP) within the SSD. These techniques (1) are tailored to specific workloads or kernels, (2) do not exploit the full computational potential of an SSD, and (3) lack programmer-transparency. While several prior works propose techniques to partition computation between the host and near-memory accelerators, adapting these techniques to SSDs has limited benefits because they (1) ignore the heterogeneity of the SSD resources, and (2) make offloading decisions based on limited factors such as bandwidth utilization, or data movement cost. We propose Conduit, a general-purpose, programmer-transparent NDP framework for SSDs that leverages multiple SSD computation resources. At compile time, Conduit executes a custom compiler (e.g., LLVM) pass that (i) vectorizes suitable application code segments into SIMD operations that align with the SSD's page layout, and (ii) embeds metadata (e.g., operation type, operand sizes) into the vectorized instructions to guide runtime offloading decisions. At runtime, within the SSD, Conduit performs instruction-granularity offloading by evaluating six key features, and uses a cost function to select the most suitable SSD resource. We evaluate Conduit and two prior NDP offloading techniques using an in-house event-driven SSD simulator on six data-intensive workloads. Conduit outperforms the best-performing prior offloading policy by 1.8x and reduces energy consumption by 46%.

</details>


### [17] [Late Breaking Results: Boosting Efficient Dual-Issue Execution on Lightweight RISC-V Cores](https://arxiv.org/abs/2601.17940)
*Luca Colagrande,Luca Benini*

Main category: cs.AR

TL;DR: æœ¬æ–‡ä»‹ç»COPIFTv2ç¼–ç¨‹æ¨¡å‹ï¼Œæ”¹è¿›Snitchæ ¸å¿ƒçš„åŒå‘è¡Œæ‰§è¡Œï¼Œé€šè¿‡è½»é‡é˜Ÿåˆ—æå‡æ•´æ•°ä¸æµ®ç‚¹æŒ‡ä»¤çš„é€šä¿¡æ•ˆç‡å’Œå¯ç¼–ç¨‹æ€§ã€‚


<details>
  <summary>Details</summary>
Motivation: å› å…ˆå‰COPIFTæ¨¡å‹å¤æ‚ä¸”æ˜“å‡ºé”™ï¼Œéœ€ä¼˜åŒ–è½»é‡çº§RISC-Væ ¸å¿ƒçš„æ‰§è¡Œæ•ˆç‡ï¼Œå…‹æœç¼–ç¨‹å¤æ‚æ€§å’Œå¼€é”€é—®é¢˜ã€‚

Method: åœ¨Snitchæ ¸å¿ƒä¸­é›†æˆè½»é‡é˜Ÿåˆ—ï¼Œå®ç°æ•´æ•°å’Œæµ®ç‚¹çº¿ç¨‹é—´çš„ç›´æ¥ã€ç²¾ç»†åŒ–é€šä¿¡å’ŒåŒæ­¥ï¼Œæ¶ˆé™¤COPIFTçš„åˆ†å—å’Œè½¯ä»¶æµæ°´çº¿æ­¥éª¤ã€‚

Result: ç›¸è¾ƒCOPIFTï¼Œé€Ÿåº¦æå‡æœ€é«˜è¾¾1.49å€ï¼Œèƒ½æ•ˆæå‡1.47å€ï¼Œå³°å€¼IPCè¾¾1.81ï¼›æ•ˆç‡ä¸ç¼–ç¨‹æ€§æ˜¾è‘—å¢å¼ºã€‚

Conclusion: COPIFTv2å¤§å¹…æ”¹å–„è½»é‡æ ¸å¿ƒåŒå‘è¡Œçš„æ•ˆèƒ½å’Œç”¨æˆ·å‹å¥½æ€§ï¼Œå…¨éƒ¨å¼€æºå¹¶ç¡®ä¿å®éªŒç»“æœå¤ç°ï¼Œæ¨åŠ¨äº†MLåŠ é€Ÿå™¨å‘å±•ã€‚

Abstract: Large-scale ML accelerators rely on large numbers of PEs, imposing strict bounds on the area and energy budget of each PE. Prior work demonstrates that limited dual-issue capabilities can be efficiently integrated into a lightweight in-order open-source RISC-V core (Snitch), with a geomean IPC boost of 1.6x and a geomean energy efficiency gain of 1.3x, obtained by concurrently executing integer and FP instructions. Unfortunately, this required a complex and error-prone low level programming model (COPIFT). We introduce COPIFTv2 which augments Snitch with lightweight queues enabling direct, fine-grained communication and synchronization between integer and FP threads. By eliminating the tiling and software pipelining steps of COPIFT, we can remove much of its complexity and software overheads. As a result, COPIFTv2 achieves up to a 1.49x speedup and a 1.47x energy-efficiency gain over COPIFT, and a peak IPC of 1.81. Overall, COPIFTv2 significantly enhances the efficiency and programmability of dual-issue execution on lightweight cores. Our implementation is fully open source and performance experiments are reproducible using free software.

</details>


### [18] [Memory-Efficient FPGA Implementation of Stochastic Simulated Annealing](https://arxiv.org/abs/2601.18007)
*Duckgyu Shin,Naoya Onizawa,Warren J. Gross,Takahiro Hanyu*

Main category: cs.AR

TL;DR: æœ¬æ–‡æå‡ºäº†ä¸€ç§ç¡¬ä»¶æ„ŸçŸ¥éšæœºæ¨¡æ‹Ÿé€€ç«ç®—æ³•ï¼ˆHA-SSAï¼‰ï¼Œç”¨äºFPGAå®ç°ï¼Œåœ¨å†…å­˜æ•ˆç‡å’Œè®¡ç®—é€Ÿåº¦ä¸Šä¼˜äºä¼ ç»Ÿæ–¹æ³•ã€‚


<details>
  <summary>Details</summary>
Motivation: ä¼ ç»Ÿæ¨¡æ‹Ÿé€€ç«ç®—æ³•ï¼ˆSAï¼‰å¤„ç†å¤§è§„æ¨¡ç»„åˆä¼˜åŒ–é—®é¢˜æ—¶è®¡ç®—æ—¶é—´å‰§å¢ï¼Œè€Œç°æœ‰éšæœºæ¨¡æ‹Ÿé€€ç«ç®—æ³•ï¼ˆSSAï¼‰é€Ÿåº¦è¾ƒå¿«ä½†å†…å­˜å ç”¨é«˜ï¼Œé™åˆ¶äº†FPGAåº”ç”¨ã€‚

Method: å¼€å‘ç¡¬ä»¶æ„ŸçŸ¥SSAç®—æ³•ï¼ˆHA-SSAï¼‰ï¼Œä¼˜åŒ–ä¸­é—´ç»“æœå­˜å‚¨ä»¥å‡å°‘å†…å­˜ç”¨é‡å¹¶ä¿æŒSSAçš„è®¡ç®—é€Ÿåº¦ã€‚

Result: åœ¨æœ€å¤§å‰²é—®é¢˜ï¼ˆG-setæ•°æ®é›†ï¼‰ä¸ŠéªŒè¯ï¼šHA-SSAæ”¶æ•›é€Ÿåº¦æ¯”ä¼ ç»ŸSAå¿«114å€ï¼Œå†…å­˜æ•ˆç‡è¾ƒSSAæé«˜6å€ï¼›FPGAï¼ˆXilinx Kintex-7ï¼‰å®ç°ä¸‹ä¿æŒé«˜è§£å‡é™è´¨é‡ã€‚

Conclusion: HA-SSAæ˜¾è‘—æå‡å†…å­˜æ•ˆç‡å’Œé€Ÿåº¦ï¼Œé€‚ç”¨äºFPGAç»„åˆä¼˜åŒ–å®ç°ï¼Œè§£è´¨é‡ç¨³å®šã€‚

Abstract: Simulated annealing (SA) is a well-known algorithm for solving combinatorial optimization problems. However, the computation time of SA increases rapidly, as the size of the problem grows. Recently, a stochastic simulated annealing (SSA) algorithm that converges faster than conventional SA has been reported. In this paper, we present a hardware-aware SSA (HA- SSA) algorithm for memory-efficient FPGA implementations. HA-SSA can reduce the memory usage of storing intermediate results while maintaining the computing speed of SSA. For evaluation purposes, the proposed algorithm is compared with the conventional SSA and SA approaches on maximum cut combinatorial optimization problems. HA-SSA achieves a convergence speed that is up to 114-times faster than that of the conventional SA algorithm depending on the maximum cut problem selected from the G-set which is a dataset of the maximum cut problems. HA-SSA is implemented on a field-programmable gate array (FPGA) (Xilinx Kintex-7), and it achieves up to 6-times the memory efficiency of conventional SSA while maintaining high solution quality for optimization problems.

</details>


### [19] [CIM-Tuner: Balancing the Compute and Storage Capacity of SRAM-CIM Accelerator via Hardware-mapping Co-exploration](https://arxiv.org/abs/2601.18070)
*Jinwu Chen,Yuhui Shi,He Wang,Zhe Jiang,Jun Yang,Xin Si,Zhenhua Zhu*

Main category: cs.AR

TL;DR: ä¸ºè§£å†³SRAM-CIMåŠ é€Ÿå™¨ä¸­ç¡¬ä»¶å¹³è¡¡å’Œæ˜ å°„ç­–ç•¥ä¸è¶³çš„é—®é¢˜ï¼Œæå‡ºè‡ªåŠ¨åŒ–å·¥å…·CIM-Tunerï¼Œé€šè¿‡ç¡¬ä»¶æ˜ å°„ååŒæ¢ç´¢æå‡æ€§èƒ½ã€‚


<details>
  <summary>Details</summary>
Motivation: å¤šæ ·åŒ–CIMè®¾è®¡å’Œæœªå……åˆ†æ¢ç´¢çš„æ˜ å°„ç­–ç•¥é˜»ç¢äº†è®¡ç®—ä¸å­˜å‚¨å¹³è¡¡çš„ä¼˜åŒ–ï¼Œå¯¼è‡´æ€§èƒ½æ˜¾è‘—ä¸‹é™ã€‚

Method: ä½¿ç”¨CIMå®çš„çŸ©é˜µæŠ½è±¡ä¸é€šç”¨åŠ é€Ÿå™¨æ¨¡æ¿ç¡®ä¿é€šç”¨æ€§ï¼›é‡‡ç”¨ç»†ç²’åº¦ä¸¤çº§ç­–ç•¥ï¼ˆåŠ é€Ÿå™¨çº§è°ƒåº¦å’Œå®çº§åˆ†å—ï¼‰å®ç°é«˜æ•ˆæ˜ å°„ã€‚

Result: ç›¸åŒé¢ç§¯çº¦æŸä¸‹ï¼Œèƒ½æ•ˆæå‡1.58å€ï¼Œååé‡æå‡2.11å€ï¼›åº”ç”¨äºå…ˆè¿›CIMåŠ é€Ÿå™¨æ—¶æ€§èƒ½è¡¨ç°å¯æ¯”ã€‚ä»¿çœŸç²¾åº¦ç»ç¡…éªŒè¯ï¼Œå·¥å…·å·²å¼€æºã€‚

Conclusion: CIM-Tuneræä¾›äº†ä¸€ç§é«˜æ•ˆé€šç”¨çš„ä¼˜åŒ–æ–¹æ¡ˆï¼Œæ˜¾è‘—æå‡CIMåŠ é€Ÿå™¨æ€§èƒ½ï¼Œæ¨åŠ¨ç¡¬ä»¶è®¾è®¡å‘å±•ã€‚

Abstract: As an emerging type of AI computing accelerator, SRAM Computing-In-Memory (CIM) accelerators feature high energy efficiency and throughput. However, various CIM designs and under-explored mapping strategies impede the full exploration of compute and storage balancing in SRAM-CIM accelerator, potentially leading to significant performance degradation. To address this issue, we propose CIM-Tuner, an automatic tool for hardware balancing and optimal mapping strategy under area constraint via hardware-mapping co-exploration. It ensures universality across various CIM designs through a matrix abstraction of CIM macros and a generalized accelerator template. For efficient mapping with different hardware configurations, it employs fine-grained two-level strategies comprising accelerator-level scheduling and macro-level tiling. Compared to prior CIM mapping, CIM-Tuner's extended strategy space achieves 1.58$\times$ higher energy efficiency and 2.11$\times$ higher throughput. Applied to SOTA CIM accelerators with identical area budget, CIM-Tuner also delivers comparable improvements. The simulation accuracy is silicon-verified and CIM-Tuner tool is open-sourced at https://github.com/champloo2878/CIM-Tuner.git.

</details>


### [20] [RTeAAL Sim: Using Tensor Algebra to Represent and Accelerate RTL Simulation (Extended Version)](https://arxiv.org/abs/2601.18140)
*Yan Zhu,Boru Chen,Christopher W. Fletcher,Nandeeka Nayak*

Main category: cs.AR

TL;DR: æœ¬æ–‡æå‡ºRTeAAL Simï¼Œå°†RTLä»¿çœŸé‡æ„ä¸ºç¨€ç–å¼ é‡ä»£æ•°é—®é¢˜ï¼Œè§£å†³ä¼ ç»Ÿä»¿çœŸå™¨ç¼–è¯‘æ…¢å’ŒCPUå‰ç«¯æ€§èƒ½ç“¶é¢ˆé—®é¢˜ã€‚


<details>
  <summary>Details</summary>
Motivation: ä¼ ç»ŸRTLä»¿çœŸå™¨å°†ç”µè·¯åµŒå…¥äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå¯¼è‡´ç¼–è¯‘æ—¶é—´é•¿ä¸”æ‰§è¡Œå—é™äºCPUå‰ç«¯ï¼Œå¼•å‘ä¸¥é‡çš„æŒ‡ä»¤ç¼“å­˜å‹åŠ›ï¼Œæˆä¸ºç¡¬ä»¶è®¾è®¡çš„æ€§èƒ½ç“¶é¢ˆã€‚

Method: é€šè¿‡å°†RTLç”µè·¯è¡¨ç¤ºä¸ºå¼ é‡ã€ä»¿çœŸè¿‡ç¨‹å»ºæ¨¡ä¸ºç¨€ç–å¼ é‡ä»£æ•°å†…æ ¸ï¼Œå®ç°ä»¿çœŸè¡Œä¸ºä¸äºŒè¿›åˆ¶å¤§å°çš„è§£è€¦ï¼Œå¹¶åº”ç”¨å¼ é‡ä»£æ•°ä¼˜åŒ–æŠ€æœ¯ã€‚

Result: åŸå‹ç³»ç»Ÿä»…åº”ç”¨éƒ¨åˆ†ä¼˜åŒ–å³æ˜¾è‘—é™ä½ç¼–è¯‘å¼€é”€å’Œå‰ç«¯å‹åŠ›ï¼Œåœ¨ä¸åŒCPUå’ŒISAä¸Šä¸é«˜åº¦ä¼˜åŒ–çš„Verilatorä»¿çœŸå™¨æ€§èƒ½ç›¸å½“ã€‚

Conclusion: å¼ é‡ä»£æ•°é‡æ„æœ‰æ•ˆå…‹æœä¼ ç»ŸRTLä»¿çœŸç¼ºé™·ï¼Œä¸ºç¡¬ä»¶è®¾è®¡æä¾›é«˜æ•ˆè§£å†³æ–¹æ¡ˆã€‚

Abstract: RTL simulation on CPUs remains a persistent bottleneck in hardware design. State-of-the-art simulators embed the circuit directly into the simulation binary, resulting in long compilation times and execution that is fundamentally CPU frontend-bound, with severe instruction-cache pressure.
  This work proposes RTeAAL Sim, which reformulates RTL simulation as a sparse tensor algebra problem. By representing RTL circuits as tensors and simulation as a sparse tensor algebra kernel, RTeAAL Sim decouples simulation behavior from binary size and makes RTL simulation amenable to well-studied tensor algebra optimizations. We demonstrate that a prototype of our tensor-based simulator, even with a subset of these optimizations, already mitigates the compilation overhead and frontend pressure and achieves performance competitive with the highly optimized Verilator simulator across multiple CPUs and ISAs.

</details>


### [21] [Lifecycle Cost-Effectiveness Modeling for Redundancy-Enhanced Multi-Chiplet Architectures](https://arxiv.org/abs/2601.18159)
*Zizhen Liu,Fangzhiyi Wang,Mengdi Wang,Jing Ye,Hayden Kwok-Hay So,Cheng Liu,Huawei Li*

Main category: cs.AR

TL;DR: æå‡ºå¤šèŠ¯ç‰‡æ¶æ„æˆæœ¬æ•ˆç›Šæ¡†æ¶LCEæŒ‡æ ‡


<details>
  <summary>Details</summary>
Motivation: ç°æœ‰æˆæœ¬æ¨¡å‹å¿½ç•¥è®¡ç®—ä»·å€¼æ‘Šé”€ï¼Œæœªè¯„ä¼°å†—ä½™ç­–ç•¥å¯¹é•¿æœŸæˆæœ¬çš„å½±å“

Method: LCEæŒ‡æ ‡è”åˆä¼˜åŒ–åˆ¶é€ æˆæœ¬ä¸å¯¿å‘½ï¼Œæ•´åˆå†—ä½™æ„ŸçŸ¥å»ºæ¨¡ã€å¯é æ€§å¯¿å‘½ä¼°è®¡å’Œå†—ä½™é…ç½®å®šé‡åˆ†æ

Result: ä¼˜åŒ–ç ”ç©¶è¡¨æ˜æ¨¡å‹æœ‰æ•ˆï¼Œæ­ç¤ºæ¨¡å—çº§ä¸èŠ¯ç‰‡çº§å†—ä½™ååŒä¼˜åŒ–ç­–ç•¥

Conclusion: è¯¥æ–¹æ³•å¯å®ç°æˆæœ¬æ•ˆç›Šä¼˜åŒ–çš„å¤šèŠ¯ç‰‡æ¶æ„è®¾è®¡

Abstract: The growing demand for compute-intensive applications has made multi-chiplet architectures a promising alternative to monolithic designs, offering improved scalability and manufacturing flexibility. However, effectively managing the economic effectiveness remains challenging. Existing cost models either overlook the amortization of compute value over a chip's operational lifetime or fail to evaluate how redundancy strategies, which are widely adopted to enhance yield and fault tolerance, impact long-term cost efficiency. This paper presents a comprehensive cost-effectiveness framework for multi-chiplet architectures, introducing a novel Lifecycle Cost Effectiveness (LCE) metric that evaluates amortized compute costs by jointly optimizing manufacturing expenses and operational lifetime. Our approach uniquely integrates: (1) redundancy-aware cost modeling spanning both intra- and inter-chiplet levels, (2) reliability-driven lifetime estimation, and (3) quantitative analysis of how redundancy configurations on overall economic effectiveness. Extensive trade-off and multi-objective optimization studies demonstrate the effectiveness of the model and reveal essential co-optimization strategies between module and chiplet-level redundancy to achieve cost-efficient multi-chiplet architecture designs.

</details>


<div id='cs.MA'></div>

# cs.MA [[Back]](#toc)

### [22] [Embodiment-Induced Coordination Regimes in Tabular Multi-Agent Q-Learning](https://arxiv.org/abs/2601.17454)
*Muhammad Ahmed Atif,Nehal Naeem Haji,Mohammad Shahid Shaikh,Muhammad Ebad Atif*

Main category: cs.MA

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Centralized value learning is often assumed to improve coordination and stability in multi-agent reinforcement learning, yet this assumption is rarely tested under controlled conditions. We directly evaluate it in a fully tabular predator-prey gridworld by comparing independent and centralized Q-learning under explicit embodiment constraints on agent speed and stamina. Across multiple kinematic regimes and asymmetric agent roles, centralized learning fails to provide a consistent advantage and is frequently outperformed by fully independent learning, even under full observability and exact value estimation. Moreover, asymmetric centralized-independent configurations induce persistent coordination breakdowns rather than transient learning instability. By eliminating confounding effects from function approximation and representation learning, our tabular analysis isolates coordination structure as the primary driver of these effects. The results show that increased coordination can become a liability under embodiment constraints, and that the effectiveness of centralized learning is fundamentally regime and role dependent rather than universal.

</details>


### [23] [VissimRL: A Multi-Agent Reinforcement Learning Framework for Traffic Signal Control Based on Vissim](https://arxiv.org/abs/2601.18284)
*Hsiao-Chuan Chang,Sheng-You Huang,Yen-Chi Chen,I-Chen Wu*

Main category: cs.MA

TL;DR: æå‡ºVissimRLæ¡†æ¶è§£å†³äº¤é€šç¯æ§åˆ¶ç ”ç©¶ä¸­Vissimä»¿çœŸå¹³å°æ¥å£å¤æ‚æ€§é—®é¢˜ï¼Œä¸ºå¼ºåŒ–å­¦ä¹ æä¾›æ ‡å‡†åŒ–ç¯å¢ƒã€‚


<details>
  <summary>Details</summary>
Motivation: Vissimè™½å…·é«˜ç²¾åº¦é©¾é©¶è¡Œä¸ºæ¨¡æ‹Ÿä¸å·¥ä¸šåº”ç”¨ä¼˜åŠ¿ï¼Œä½†å› æ¥å£å¤æ‚å’Œç¼ºä¹æ ‡å‡†æ¡†æ¶ï¼Œåœ¨å¼ºåŒ–å­¦ä¹ ç ”ç©¶ä¸­æœªè¢«å……åˆ†åˆ©ç”¨ã€‚

Method: å¼€å‘æ¨¡å—åŒ–æ¡†æ¶VissimRLï¼Œé€šè¿‡Python APIå°è£…Vissimçš„COMæ¥å£ï¼Œæ”¯æŒå•/å¤šæ™ºèƒ½ä½“å¼ºåŒ–å­¦ä¹ è®­ç»ƒç¯å¢ƒã€‚

Result: æ˜¾è‘—é™ä½å¼€å‘æˆæœ¬å¹¶ä¿æŒè¿è¡Œæ•ˆç‡ï¼Œè®­ç»ƒä¸­æŒç»­æå‡äº¤é€šæ€§èƒ½ï¼Œå¤šæ™ºèƒ½ä½“æ§åˆ¶ä¸­å®ç°ååŒæ•ˆåº”ã€‚

Conclusion: VissimRLè¯å®å¼ºåŒ–å­¦ä¹ åœ¨é«˜ç²¾åº¦ä»¿çœŸä¸­çš„åº”ç”¨å¯è¡Œæ€§ï¼Œä¸ºå­¦æœ¯ç ”ç©¶ä¸æ™ºèƒ½äº¤é€šå®é™…åº”ç”¨æ¶è®¾æ¡¥æ¢ã€‚

Abstract: Traffic congestion remains a major challenge for urban transportation, leading to significant economic and environmental impacts. Traffic Signal Control (TSC) is one of the key measures to mitigate congestion, and recent studies have increasingly applied Reinforcement Learning (RL) for its adaptive capabilities. With respect to SUMO and CityFlow, the simulator Vissim offers high-fidelity driver behavior modeling and wide industrial adoption but remains underutilized in RL research due to its complex interface and lack of standardized frameworks. To address this gap, this paper proposes VissimRL, a modular RL framework for TSC that encapsulates Vissim's COM interface through a high-level Python API, offering standardized environments for both single- and multi-agent training. Experiments show that VissimRL significantly reduces development effort while maintaining runtime efficiency, and supports consistent improvements in traffic performance during training, as well as emergent coordination in multi-agent control. Overall, VissimRL demonstrates the feasibility of applying RL in high-fidelity simulations and serves as a bridge between academic research and practical applications in intelligent traffic signal control.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [24] [Risk-based test framework for LLM features in regulated software](https://arxiv.org/abs/2601.17292)
*Zhiyin Zhou*

Main category: cs.SE

TL;DR: è®ºæ–‡æå‡ºé’ˆå¯¹å—ç›‘ç®¡è½¯ä»¶ä¸­LLMåŠŸèƒ½çš„åŸºäºé£é™©æµ‹è¯•æ¡†æ¶ï¼ŒåŒ…æ‹¬é£é™©åˆ†ç±»ã€åˆ†å±‚æµ‹è¯•ç­–ç•¥å’Œä¸´åºŠæ¡ˆä¾‹éªŒè¯ã€‚


<details>
  <summary>Details</summary>
Motivation: æ³•å¾‹è¯­è¨€æ¨¡å‹åµŒå…¥åŒ»ç–—ç­‰å…³é”®ç³»ç»Ÿæ—¶å­˜åœ¨å¹»è§‰ã€åè§ã€éšç§æ³„éœ²ç­‰é£é™©ï¼Œç°æœ‰AIæµ‹è¯•æ–¹æ³•æ— æ³•è¦†ç›–äº¤äº’å¼äº§å“åœºæ™¯ã€‚

Method: å»ºç«‹å…­ç±»é£é™©åˆ†ç±»æ³•ï¼Œè®¾è®¡åˆ†å±‚æµ‹è¯•ç­–ç•¥ï¼ˆå°†é£é™©æ˜ å°„è‡³æŠ¤å«å±‚Î»Ïåè°ƒå±‚å’Œç³»ç»Ÿå±‚ï¼‰ï¼Œå¹¶é€šè¿‡ä¸´åºŠç ”ç©¶å¹³å°çš„çŸ¥è¯†åº“åŠ©æ‰‹è¿›è¡Œæ¡ˆä¾‹éªŒè¯ã€‚

Result: å¼€å‘äº†å¯è½åœ°çš„æ¡†æ¶ï¼Œå®ç°é£é™©åˆ°å…·ä½“æµ‹è¯•çš„æ˜ å°„ï¼Œä¸´åºŠæ¡ˆä¾‹è¯æ˜äº†æ¡†æ¶åœ¨è¯†åˆ«æ¼æ´æ–¹é¢çš„æœ‰æ•ˆæ€§ã€‚

Conclusion: è¯¥æ¡†æ¶ä¸ºå—ç›‘ç®¡è½¯ä»¶çš„ EgyptLLMåŠŸèƒ½æä¾›äº†é’ˆå¯¹æ€§æµ‹è¯•è·¯å¾„ï¼Œåˆ†å±‚ç­–ç•¥èƒ½ç³»ç»ŸåŒ–ç¼“è§£å®‰å…¨é£é™©ã€‚

Abstract: Large language models are increasingly embedded in regulated and safety-critical software, including clinical research platforms and healthcare information systems. While these features enable natural language search, summarization, and configuration assistance, they introduce risks such as hallucinations, harmful or out-of-scope advice, privacy and security issues, bias, instability under change, and adversarial misuse. Prior work on machine learning testing and AI assurance offers useful concepts but limited guidance for interactive, product-embedded assistants. This paper proposes a risk-based testing framework for LLM features in regulated software: a six-category risk taxonomy, a layered test strategy mapping risks to concrete tests across guardrail, orchestration, and system layers, and a case study applying the approach to a Knowledgebase assistant in a clinical research platform.

</details>


### [25] [YASA: Scalable Multi-Language Taint Analysis on the Unified AST at Ant Group](https://arxiv.org/abs/2601.17390)
*Yayi Wang,Shenao Wang,Jian Zhao,Shaosen Shi,Ting Li,Yan Cheng,Lizhong Bian,Kan Yu,Yanjie Zhao,Haoyu Wang*

Main category: cs.SE

TL;DR: YASA presents a unified multi-language static taint analysis framework for industrial-scale applications.


<details>
  <summary>Details</summary>
Motivation: Current SAST tools struggle with battalion diverse programming languages, causing scalability and precision limitations.

Method: Uses a Unified Abstract Syntax Tree (UAST) for cross-language analysis, with unified semantic models for common features and language-specific models for unique aspects.

Result: Outperformed 8 baselines in benchmarks; in deployment, analyzed 100M+ LoC, finding 314 new taint paths (92 confirmed vulnerabilities), with 76 patched.

Conclusion: YASA demonstrates high effectiveness for securing large-scale industrial systems by overcoming language diversity barriers.

Abstract: Modern enterprises increasingly adopt diverse technology stacks with various programming languages, posing significant challenges for static application security testing (SAST). Existing taint analysis tools are predominantly designed for single languages, requiring substantial engineering effort that scales with language diversity. While multi-language tools like CodeQL, Joern, and WALA attempt to address these challenges, they face limitations in intermediate representation design, analysis precision, and extensibility, which make them difficult to scale effectively for large-scale industrial applications at Ant Group. To bridge this gap, we present YASA (Yet Another Static Analyzer), a unified multi-language static taint analysis framework designed for industrial-scale deployment. Specifically, YASA introduces the Unified Abstract Syntax Tree (UAST) that provides a unified abstraction for compatibility across diverse programming languages. Building on the UAST, YASA performs point-to analysis and taint propagation, leveraging a unified semantic model to manage language-agnostic constructs, while incorporating language-specific semantic models to handle other unique language features. When compared to 6 single- and 2 multi-language static analyzers on an industry-standard benchmark, YASA consistently outperformed all baselines across Java, JavaScript, Python, and Go. In real-world deployment within Ant Group, YASA analyzed over 100 million lines of code across 7.3K internal applications. It identified 314 previously unknown taint paths, with 92 of them confirmed as 0-day vulnerabilities. All vulnerabilities were responsibly reported, with 76 already patched by internal development teams, demonstrating YASA's practical effectiveness for securing large-scale industrial software systems.

</details>


### [26] [Data-driven Test Generation for Fuzzing AI Compiler](https://arxiv.org/abs/2601.17450)
*Qingchao Shen*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: AIç¼–è¯‘å™¨æ¼æ´å¨èƒå¯é æ€§å’Œæ¨¡å‹æ­£ç¡®æ€§ï¼ŒäºŸéœ€ç¡®ä¿è´¨é‡ã€‚

Method: OPERAè¿ç§»åº“æµ‹è¯•éªŒè¯ç®—å­è½¬æ¢ï¼ŒOATestç”Ÿæˆä¼˜åŒ–æ„ŸçŸ¥è®¡ç®—å›¾æµ‹è¯•é«˜çº§ä¼˜åŒ–ï¼ŒHARMONYå˜å¼‚IRç§å­æµ‹è¯•ä½çº§ä¼˜åŒ–ã€‚

Result: åœ¨å››æ¬¾ä¸»æµAIç¼–è¯‘å™¨ä¸­æ£€æµ‹å‡º266ä¸ªæœªçŸ¥é”™è¯¯ã€‚

Conclusion: æ¡†æ¶å®ç°é˜¶æ®µæ€§å…¨é¢è¦†ç›–ï¼Œæ˜¾è‘—æå‡æµ‹è¯•æœ‰æ•ˆæ€§å’Œè¦†ç›–ç‡ã€‚

Abstract: Artificial Intelligence (AI) compilers are critical for efficiently deploying AI models across diverse hardware platforms. However, they remain prone to bugs that can compromise both compiler reliability and model correctness. Thus, ensuring the quality of AI compilers is crucial. In this work, we present a unified data-driven testing framework that systematically addresses stage-specific challenges in AI compilers. Specifically, OPERA migrates tests for AI libraries to test various operator conversion logic in the model loading stage. OATest synthesizes diverse optimization-aware computational graphs for testing high-level optimizations. HARMONY generates and mutates diverse low-level IR seeds to generate hardware-optimization-aware tests for testing low-level optimizations. Together, these techniques provide a comprehensive, stage-aware framework that enhances testing coverage and effectiveness, detecting 266 previously unknown bugs in four widely used AI compilers.

</details>


### [27] [LogPrism: Unifying Structure and Variable Encoding for Effective Log Compression](https://arxiv.org/abs/2601.17482)
*Yang Liu,Kaiming Zhang,Zhuangbin Chen,Jinyang Liu,Zibin Zheng*

Main category: cs.SE

TL;DR: æå‡ºLogPrismæ¡†æ¶ï¼Œé€šè¿‡ç»Ÿä¸€å‹ç¼©æ–¹å¼æ¡¥æ¥è§£æä¸å‹ç¼©éš”é˜‚ï¼Œæ˜¾è‘—æå‡æ—¥å¿—å‹ç¼©æ•ˆç‡å’Œé€Ÿåº¦ã€‚


<details>
  <summary>Details</summary>
Motivation: ç°æœ‰'è§£æåå‹ç¼©'èŒƒå¼åˆ†ç¦»å¤„ç†æ—¥å¿—è§£æå’Œå‹ç¼©ï¼Œè§£æå™¨å¼ºè°ƒè¯­ä¹‰å‡†ç¡®æ€§å´å¿½è§†æ¨¡æ¿ä¸å˜é‡é—´æ·±å±‚å…³è”ï¼Œå¯¼è‡´å­˜å‚¨æ•ˆç‡ä½ä¸‹ã€‚

Method: æ„å»ºç»Ÿä¸€å†—ä½™æ ‘(URT)åŠ¨æ€æ•´åˆç»“æ„æå–ä¸å˜é‡ç¼–ç ï¼ŒæŒ–æ˜'ç»“æ„+å˜é‡'å…±ç°æ¨¡å¼å¹¶é¢„ç¼–ç ï¼Œä»¥æ•è·ä¸Šä¸‹æ–‡å†—ä½™å¹¶åŠ é€Ÿå¤„ç†ã€‚

Result: åœ¨16ä¸ªåŸºå‡†æ•°æ®é›†ä¸Šï¼ŒLogPrismåœ¨13ä¸ªæ•°æ®é›†åˆ›æœ€é«˜å‹ç¼©æ¯”(è¶…è¶ŠåŸºçº¿4.7%~80.9%)ï¼Œååç‡29.87 MB/s(æ¯”å¯¹æ‰‹å¿«1.68Ã—~43.04Ã—)ï¼›å•å½’æ¡£æ¨¡å¼ä¸‹å‹ç¼©æ¯”é¢†å…ˆæœ€å¼ºåŸºçº¿19.39%ï¼Œæé€Ÿ2.62Ã—ã€‚

Conclusion: LogPrismç¡®ç«‹å‹ç¼©é¢†åŸŸæ–°å‰æ²¿ï¼Œåœ¨å‹ç¼©æ¯”ã€é€Ÿåº¦å’Œå…¨å±€æ¨¡å¼æŒ–æ˜æ–¹é¢ä¼˜äºæ‰€æœ‰åŸºçº¿ã€‚

Abstract: The prevailing "parse-then-compress" paradigm in log compression fundamentally limits effectiveness by treating log parsing and compression as isolated objectives. While parsers prioritize semantic accuracy (i.e., event identification), they often obscure deep correlations between static templates and dynamic variables that are critical for storage efficiency. In this paper, we investigate this misalignment through a comprehensive empirical study and propose LogPrism, a framework that bridges the gap via unified redundancy encoding. Rather than relying on a rigid pre-parsing step, LogPrism dynamically integrates structural extraction with variable encoding by constructing a Unified Redundancy Tree (URT). This hierarchical approach effectively mines "structure+variable" co-occurrence patterns, capturing deep contextual redundancies while accelerating processing through pre-emptive pattern encoding. Extensive experiments on 16 benchmark datasets confirm that LogPrism establishes a new state-of-the-art. It achieves the highest compression ratio on 13 datasets, surpassing leading baselines by margins of 4.7% to 80.9%, while delivering superior throughput at 29.87 MB/s (1.68$\times$~43.04$\times$ faster than competitors). Moreover, when configured in single-archive mode to maximize global pattern discovery, LogPrism outperforms the best baseline by 19.39% in compression ratio while maintaining a 2.62$\times$ speed advantage.

</details>


### [28] [Measuring Braking Behavior Using Vehicle Tracking and Camera-to-Satellite Homography Rectification](https://arxiv.org/abs/2601.17558)
*J. P. Fleischer,Tanchanok Sirikanchittavon,Chonlachart Jeenprasom,Nooshin Yousefzadeh,Sanjay Ranka,Mohammed Hadi*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: This paper presents an open-source software application for analyzing traffic camera footage, focusing on vehicle behavior and braking events at signalized urban highways. The core innovation is a robust ground-plane homography estimation that links fixed traffic camera views to satellite orthoimagery. This process rectifies the camera's oblique perspective, ensuring that pixel distances accurately represent real-world distances. This enables the acquisition of features such as vehicle trajectory, speed, deceleration, and braking severity without the need for camera calibration. The pipeline employs the MAGSAC++ estimator to build the homography, converting YOLO11 object detections into a rectified top-down coordinate system. All detection and trajectory data are stored in a ClickHouse database for subsequent analysis. A real-world case study at two signalized intersections in Key West, Florida, showcased the system's capabilities. Across two days of daytime footage, braking activity at the higher-volume intersection peaked around 4 PM at approximately 57.5 events per hour, while the second intersection peaked around 10 AM at roughly 15.5 events per hour. The spatial analysis revealed that most braking events initiated upstream, with mild and moderate braking mostly occurring 30 to 45+ meters away from the stop bar and severe braking distributed throughout, but particularly concentrated in lanes with higher interaction and merging activity. The findings highlight the significant potential of this centralized safety information system to support connected vehicles, facilitating proactive traffic management, crash mitigation, and data-driven roadway design and safety analysis.

</details>


### [29] [Prompt Driven Development with Claude Code: Building a Complete TUI Framework for the Ring Programming Language](https://arxiv.org/abs/2601.17584)
*Mahmoud Samir Fayed,Ahmed Samir Fayed*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Large language models are increasingly used in software development, yet their ability to generate and maintain large, multi module systems through natural language interaction remains insufficiently characterized. This study presents an empirical analysis of developing a 7420 line Terminal User Interface framework for the Ring programming language, completed in roughly ten hours of active work spread across three days using a purely prompt driven workflow with Claude Code, Opus 4.5. The system was produced through 107 prompts: 21 feature requests, 72 bug fix prompts, 9 prompts sharing information from Ring documentation, 4 prompts providing architectural guidance, and 1 prompt dedicated to generating documentation. Development progressed across five phases, with the Window Manager phase requiring the most interaction, followed by complex UI systems and controls expansion. Bug related prompts covered redraw issues, event handling faults, runtime errors, and layout inconsistencies, while feature requests focused primarily on new widgets, window manager capabilities, and advanced UI components. Most prompts were short, reflecting a highly iterative workflow in which the human role was limited to specifying requirements, validating behaviour, and issuing corrective prompts without writing any code manually. The resulting framework includes a complete windowing subsystem, event driven architecture, interactive widgets, hierarchical menus, grid and tree components, tab controls, and a multi window desktop environment. By combining quantitative prompt analysis with qualitative assessment of model behaviour, this study provides empirical evidence that modern LLMs can sustain architectural coherence and support the construction of production grade tooling for emerging programming languages, highlighting prompt driven development as a viable methodology within software engineering practice.

</details>


### [30] [Human-Aligned Enhancement of Programming Answers with LLMs Guided by User Feedback](https://arxiv.org/abs/2601.17604)
*Suborno Deb Bappon,Saikat Mondal,Chanchal K. Roy,Kevin Schneider*

Main category: cs.SE

TL;DR: æœ¬ç ”ç©¶å¼•å…¥AUTOCOMBATå·¥å…·ï¼Œåˆ©ç”¨å¤§å‹è¯­è¨€æ¨¡å‹è‡ªåŠ¨æ•´åˆç”¨æˆ·åé¦ˆæ”¹è¿›ç¼–ç¨‹ç­”æ¡ˆçš„è´¨é‡ã€‚


<details>
  <summary>Details</summary>
Motivation: æŠ€æœ¯é—®ç­”å¹³å°ï¼ˆå¦‚Stack Overflowï¼‰çº¦ä¸‰åˆ†ä¹‹ä¸€çš„ç”¨æˆ·åé¦ˆæœªè¢«å¤„ç†ï¼Œå¯¼è‡´ç­”æ¡ˆè¿‡æ—¶æˆ–ä¸å®Œæ•´ï¼Œæ¢ç´¢å¦‚ä½•åˆ©ç”¨LLMsæ”¹è¿›ç¼–ç¨‹ç­”æ¡ˆã€‚

Method: é¦–å…ˆåˆ›å»ºåŒ…å«790ä¸ªç­”æ¡ˆåŠæ ‡æ³¨è¯„è®ºçš„ReSOlveåŸºå‡†ï¼›è¯„ä¼°å››ç§LLMè¯†åˆ«åé¦ˆçš„èƒ½åŠ›ï¼Œå¼€å‘ç»“åˆè¯„è®ºä¸é—®é¢˜ä¸Šä¸‹æ–‡çš„AUTOCOMBATå·¥å…·ã€‚

Result: AUTOCOMBATæ”¹è¿›è´¨é‡æ¥è¿‘äººå·¥æ°´å¹³ä¸”ä¼˜äºåŸºçº¿ï¼›58ä½ä»ä¸šè€…ç”¨æˆ·ç ”ç©¶ä¸­84.5%æ„¿æ„é‡‡çº³æˆ–æ¨èè¯¥å·¥å…·ã€‚

Conclusion: åé¦ˆé©±åŠ¨çš„ç­”æ¡ˆä¼˜åŒ–å¯æ‰©å±•æå‡æŠ€æœ¯çŸ¥è¯†å¹³å°çš„å¯é æ€§ï¼ŒAUTOCOMBATå±•ç°äº†æ­¤æ½œåŠ›ã€‚

Abstract: Large Language Models (LLMs) are widely used to support software developers in tasks such as code generation, optimization, and documentation. However, their ability to improve existing programming answers in a human-like manner remains underexplored. On technical question-and-answer platforms such as Stack Overflow (SO), contributors often revise answers based on user comments that identify errors, inefficiencies, or missing explanations. Yet roughly one-third of this feedback is never addressed due to limited time, expertise, or visibility, leaving many answers incomplete or outdated. This study investigates whether LLMs can enhance programming answers by interpreting and incorporating comment-based feedback. We make four main contributions. First, we introduce ReSOlve, a benchmark consisting of 790 SO answers with associated comment threads, annotated for improvement-related and general feedback. Second, we evaluate four state-of-the-art LLMs on their ability to identify actionable concerns, finding that DeepSeek achieves the best balance between precision and recall. Third, we present AUTOCOMBAT, an LLM-powered tool that improves programming answers by jointly leveraging user comments and question context. Compared to human revised references, AUTOCOMBAT produces near-human quality improvements while preserving the original intent and significantly outperforming the baseline. Finally, a user study with 58 practitioners shows strong practical value, with 84.5 percent indicating they would adopt or recommend the tool. Overall, AUTOCOMBAT demonstrates the potential of scalable, feedback-driven answer refinement to improve the reliability and trustworthiness of technical knowledge platforms.

</details>


### [31] [Code Change Characteristics and Description Alignment: A Comparative Study of Agentic versus Human Pull Requests](https://arxiv.org/abs/2601.17627)
*Dung Pham,Taher A. Ghaleb*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: AI coding agents can autonomously generate pull requests (PRs), yet little is known about how their contributions compare to those of humans. We analyze 33,596 agent-generated PRs (APRs) and 6,618 human PRs (HPRs) to compare code-change characteristics and message quality. We observe that APR-introduced symbols (functions and classes) are removed much sooner than those in HPRs (median time to removal 3 vs. 34 days) and are also removed more often (symbol churn 7.33% vs. 4.10%), reflecting a focus on other tasks like documentation and test updates. Agents generate stronger commit-level messages (semantic similarity 0.72 vs. 0.68) but lag humans at PR-level summarization (PR-commit similarity 0.86 vs. 0.88). Commit message length is the best predictor of description quality, indicating reliance on individual commits over full-PR reasoning. These findings highlight a gap between agents' micro-level precision and macro-level communication, suggesting opportunities to improve agent-driven development workflows.

</details>


### [32] [Multi-Agent End-to-End Vulnerability Management for Mitigating Recurring Vulnerabilities](https://arxiv.org/abs/2601.17762)
*Zelong Zheng,Jiayuan Zhou,Xing Hu,Yi Gao,Shengyi Pan*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Software vulnerability management has become increasingly critical as modern systems scale in size and complexity. However, existing automated approaches remain insufficient. Traditional static analysis methods struggle to precisely capture contextual dependencies, especially when vulnerabilities span multiple functions or modules. Large language models (LLMs) often lack the ability to retrieve and exploit sufficient contextual information, resulting in incomplete reasoning and unreliable outcomes. Meanwhile, recurring vulnerabilities emerge repeatedly due to code reuse and shared logic, making historical vulnerability knowledge an indispensable foundation for effective vulnerability detection and repair. Nevertheless, prior approaches such as clone-based detection and patch porting, have not fully leveraged this knowledge. To address these challenges, we present MAVM, a multi-agent framework for end-to-end recurring vulnerability management. MAVM integrates five components, including a vulnerability knowledge base, detection, confirmation, repair, and validation, into a unified multi-agent pipeline. We construct a knowledge base from publicly disclosed vulnerabilities, thereby addressing the underuse of historical knowledge in prior work and mitigating the lack of domain-specific expertise in LLMs. Furthermore, we design context-retrieval tools that allow agents to extract and reason over repository-level information, overcoming the contextual limitations of previous methods. Based on agents, MAVM effectively simulates real-world security workflows. To evaluate the performance of MAVM, we construct a dataset containing 78 real-world patch-porting cases (covering 114 function-level migrations). On this dataset, MAVM successfully detects and repairs 51 real vulnerabilities, outperforming baselines by 31.9%-45.2% in repair accuracy, which demonstrates its effectiveness.

</details>


### [33] [iResolveX: Multi-Layered Indirect Call Resolution via Static Reasoning and Learning-Augmented Refinement](https://arxiv.org/abs/2601.17888)
*Monika Santra,Bokai Zhang,Mark Lim,Vishnu Asutosh Dasu,Dongrui Zeng,Gang Tan*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Indirect call resolution remains a key challenge in reverse engineering and control-flow graph recovery, especially for stripped or optimized binaries. Static analysis is sound but often over-approximates, producing many false positives, whereas machine-learning approaches can improve precision but may sacrifice completeness and generalization. We present iResolveX, a hybrid multi-layered framework that combines conservative static analysis with learning-based refinement. The first layer applies a conservative value-set analysis (BPA) to ensure high recall. The second layer adds a learning-based soft-signature scorer (iScoreGen) and selective inter-procedural backward analysis with memory inspection (iScoreRefine) to reduce false positives. The final output, p-IndirectCFG, annotates indirect edges with confidence scores, enabling downstream analyses to choose appropriate precision--recall trade-offs. Across SPEC CPU2006 and real-world binaries, iScoreGen reduces predicted targets by 19.2% on average while maintaining BPA-level recall (98.2%). Combined with iScoreRefine, the total reduction reaches 44.3% over BPA with 97.8% recall (a 0.4% drop). iResolveX supports both conservative, recall-preserving and F1-optimized configurations and outperforms state-of-the-art systems.

</details>


### [34] [Prompt-Based REST API Test Amplification in Industry: An Experience Report](https://arxiv.org/abs/2601.17903)
*Tolgahan Bardakci,Andreas Faes,Mutlu Beyazit,Serge Demeyr*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Large Language Models (LLMs) are increasingly used to support software testing tasks, yet there is little evidence of their effectiveness for REST API testing in industrial settings. To address this gap, we replicate our earlier work on LLM-based REST API test amplification within an industrial context at one of the largest logistics companies in Belgium. We apply LLM-based test amplification to six representative endpoints of a production microservice embedded in a large-scale, security-sensitive system, where there is in-depth complexity in authentication, stateful behavior, and organizational constraints. Our experience shows that LLM-based test amplification remains practically useful in industry by increasing coverage and revealing various observations and anomalies.

</details>


### [35] [RGFL: Reasoning Guided Fault Localization for Automated Program Repair Using Large Language Models](https://arxiv.org/abs/2601.18044)
*Melika Sepidband,Hamed Taherkhani,Hung Viet Pham,Hadi Hemmati*

Main category: cs.SE

TL;DR: æå‡ºäº†ä¸€ç§é¡¹ç›®çº§é”™è¯¯å®šä½æ–°æ–¹æ³•ï¼Œé€šè¿‡åˆ†å±‚æ¨ç†å’Œä¸¤é˜¶æ®µæå‡å‡†ç¡®ç‡ã€‚


<details>
  <summary>Details</summary>
Motivation: è½¯ä»¶ä»“åº“å¸¸è¾¾æ•°ç™¾ä¸‡æ ‡è®°è¶…å‡ºLLMä¸Šä¸‹æ–‡é™åˆ¶ï¼Œé«˜æ•ˆæ–‡ä»¶åŠå…ƒç´ çº§é”™è¯¯å®šä½å¯¹è‡ªåŠ¨ç¨‹åºä¿®å¤è‡³å…³é‡è¦ã€‚

Method: å¼•å…¥åˆ†å±‚æ¨ç†æ¨¡å—ç”Ÿæˆé”™è¯¯ç›¸å…³è§£é‡Šï¼Œç»“åˆLLMä¸åµŒå…¥ä¿¡å·çš„äºŒé˜¶æ®µæ’åºæ–¹æ¡ˆï¼›å¹¶ä½¿ç”¨åäº‹å®ä¸Šç•Œåˆ†æé‡åŒ–å„é˜¶æ®µè´¡çŒ®ã€‚

Result: SWE-benchæ•°æ®é›†ä¸Šæ–‡ä»¶çº§Hit@1ä»71.4%å‡è‡³85%ï¼ŒMRR81.8%è‡³88.8%ï¼›å…ƒç´ çº§top-3æ–‡ä»¶ä¸‹Exact Matchä»36%å¢è‡³69%ï¼›æ•´åˆAgentlessä½¿ç«¯åˆ°ç«¯ä¿®å¤æˆåŠŸç‡æé«˜12.8%ã€‚

Conclusion: æ–¹æ³•æ˜¾è‘—æé«˜é”™è¯¯å®šä½ç²¾åº¦ï¼Œæœ‰æ•ˆæå‡ç«¯åˆ°ç«¯ç¨‹åºä¿®å¤æˆåŠŸç‡ã€‚

Abstract: Fault Localization (FL) is a critical step in Automated Program Repair (APR), and its importance has increased with the rise of Large Language Model (LLM)-based repair agents. In realistic project-level repair scenarios, software repositories often span millions of tokens, far exceeding current LLM context limits. Consequently, models must first identify a small, relevant subset of code, making accurate FL essential for effective repair. We present a novel project-level FL approach that improves both file- and element-level localization. Our method introduces a hierarchical reasoning module that (i) generates structured, bug-specific explanations for candidate files and elements, and (ii) leverages these explanations in a two-stage ranking scheme combining LLM-based and embedding-based signals. We further propose a counterfactual upper-bound analysis to quantify the contribution of each localization stage to repair success. We evaluate our approach on Python and Java projects from SWE-bench Verified, Lite, and Java. Compared to state-of-the-art baselines, including Agentless and OpenHands, our method consistently improves localization accuracy. On SWE-bench Verified, file-level Hit@1 improves from 71.4% to 85%, and MRR from 81.8% to 88.8%. At the element level, Exact Match under top-3 files increases from 36% to 69%. Integrating our localization into Agentless yields a 12.8% end-to-end repair success improvement.

</details>


### [36] [TAM-Eval: Evaluating LLMs for Automated Unit Test Maintenance](https://arxiv.org/abs/2601.18241)
*Elena Bruches,Vadim Alperovich,Dari Baturova,Roman Derunets,Daniil Grebenkin,Georgy Mkrtchyan,Oleg Sedukhin,Mikhail Klementev,Ivan Bondarenko,Nikolay Bushkov,Stanislav Moiseev*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: While Large Language Models (LLMs) have shown promise in software engineering, their application to unit testing remains largely confined to isolated test generation or oracle prediction, neglecting the broader challenge of test suite maintenance. We introduce TAM-Eval (Test Automated Maintenance Evaluation), a framework and benchmark designed to evaluate model performance across three core test maintenance scenarios: creation, repair, and updating of test suites. Unlike prior work limited to function-level tasks, TAM-Eval operates at the test file level, while maintaining access to full repository context during isolated evaluation, better reflecting real-world maintenance workflows. Our benchmark comprises 1,539 automatically extracted and validated scenarios from Python, Java, and Go projects. TAM-Eval supports system-agnostic evaluation of both raw LLMs and agentic workflows, using a reference-free protocol based on test suite pass rate, code coverage, and mutation testing. Empirical results indicate that state-of-the-art LLMs have limited capabilities in realistic test maintenance processes and yield only marginal improvements in test effectiveness. We release TAM-Eval as an open-source framework to support future research in automated software testing. Our data and code are publicly available at https://github.com/trndcenter/TAM-Eval.

</details>


### [37] [Forecasting the Maintained Score from the OpenSSF Scorecard for GitHub Repositories linked to PyPI libraries](https://arxiv.org/abs/2601.18344)
*Alexandros Tsakpinis,Efe Berk ErgÃ¼lec,Emil Schwenger,Alexander Pretschner*

Main category: cs.SE

TL;DR: æœ¬ç ”ç©¶é¢„æµ‹OpenSSF Scorecardç»´æŠ¤æŒ‡æ ‡çš„æœªæ¥å€¼ï¼Œé€šè¿‡æ—¶é—´åºåˆ—åˆ†ææå‡é£é™©è¯„ä¼°èƒ½åŠ›ã€‚


<details>
  <summary>Details</summary>
Motivation: OpenSSF Scorecardçš„MaintainedæŒ‡æ ‡ä»…ä¸ºè¿‡å»90å¤©çš„å›é¡¾æ€§æµ‹åº¦ï¼Œæ— æ³•æ´å¯Ÿæœªæ¥ç»´æŠ¤é£é™©ï¼Œé™åˆ¶äº†ä¸»åŠ¨è¯„ä¼°èƒ½åŠ›ã€‚

Method: åˆ†æ3220ä¸ªPyPIé¡¶çº§åº“GitHubä»“åº“çš„ä¸‰å¹´ sty scoreå†å²æ•°æ®ï¼Œé‡‡ç”¨VARMAã€éšæœºæ£®æ—å’ŒLSTMæ¨¡å‹è¿›è¡Œå¤šå˜é‡æ—¶é—´åºåˆ—é¢„æµ‹ï¼Œæ¶µç›–3-12ä¸ªæœˆè®­ç»ƒçª—å£å’Œ1-6ä¸ªæœˆé¢„æµ‹èŒƒå›´ï¼Œä½¿ç”¨åŸå§‹åˆ†æ•°ã€åˆ†çº§ç»´æŠ¤æ°´å¹³ã€æ•°å€¼è¶‹åŠ¿æ–œç‡å’Œåˆ†ç±»è¶‹åŠ¿ç±»å‹ä½œä¸ºç›®æ ‡è¡¨ç¤ºã€‚

Result: é¢„æµ‹ç²¾åº¦æ˜¾è‘—ï¼Œåˆ†çº§åˆ†æ•°ç²¾åº¦è¶…0.95ï¼Œè¶‹åŠ¿ç±»å‹ç²¾åº¦è¶…0.80ï¼›ç®€å•ç»Ÿè®¡ä¸æœºå™¨å­¦ä¹ æ¨¡å‹ç­‰åŒäºæ·±åº¦å­¦ä¹ æ¨¡å‹ï¼Œè¡¨æ˜æ— éœ€å¤æ‚æ¶æ„ã€‚

Conclusion: é¢„æµ‹å»ºæ¨¡å¯æœ‰æ•ˆè¡¥è¶³ScorecardæŒ‡æ ‡ï¼Œèµ‹èƒ½å¼€æºç»´æŠ¤é£é™©çš„å‰ç»æ€§è¯„ä¼°ã€‚

Abstract: The OpenSSF Scorecard is widely used to assess the security posture of open-source software repositories, with the Maintained metric indicating recent development activity and helping identify potentially abandoned dependencies. However, this metric is inherently retrospective, reflecting only the past 90 days of activity and providing no insight into future maintenance, which limits its usefulness for proactive risk assessment. In this paper, we study to what extent future maintenance activity, as captured by the OpenSSF Maintained score, can be forecasted. We analyze 3,220 GitHub repositories associated with the top 1% most central PyPI libraries by PageRank and reconstruct historical Maintained scores over a three-year period. We formulate the task as multivariate time series forecasting and consider four target representations: raw scores, bucketed maintenance levels, numerical trend slopes, and categorical trend types. We compare a statistical model (VARMA), a machine learning model (Random Forest), and a deep learning model (LSTM) across training windows of 3-12 months and forecasting horizons of 1-6 months. Our results show that future maintenance activity can be predicted with meaningful accuracy, particularly for aggregated representations such as bucketed scores and trend types, achieving accuracies above 0.95 and 0.80, respectively. Simpler statistical and machine learning models perform on par with deep learning approaches, indicating that complex architectures are not required. These findings suggest that predictive modeling can effectively complement existing Scorecard metrics, enabling more proactive assessment of open-source maintenance risks.

</details>


### [38] [Promises, Perils, and (Timely) Heuristics for Mining Coding Agent Activity](https://arxiv.org/abs/2601.18345)
*Romain Robes ThÃ©o Matricon,Thomas Degueule,Andre Hora,Stefano Zacchiroli*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: åŠ¨æœºåœ¨äºä»£ç æ™ºèƒ½ä½“çš„è¿…é€Ÿé‡‡ç”¨åŠå…¶ä¸LLMä»£ç è¡¥å…¨çš„æ˜¾è‘—å·®å¼‚ä½¿å…¶ç ”ç©¶è‡³å…³é‡è¦ï¼Œä¸”å…¶åœ¨ä»“åº“ä¸­çš„å¯è§ç—•è¿¹æ”¯æŒä½¿ç”¨MSRæŠ€æœ¯åˆ†æå…¶å¯¹è½¯ä»¶å·¥ç¨‹çš„å½±å“ã€‚

Method: æ–¹æ³•æ˜¯é€šè¿‡MSRæŠ€æœ¯åˆ†æGitHubä»“åº“ä¸­ä»£ç æ™ºèƒ½æ´»åŠ¨çš„ç—•è¿¹

Result: ç»“æœæ‘˜å½•äº†ä»£ç æ™ºèƒ½ä½“çš„æ‰¿è¯ºï¼ˆå¦‚è‡ªåŠ¨åŒ–æ½œåŠ›ï¼‰ã€é£é™©ï¼ˆå¦‚æ½œåœ¨é—®é¢˜ï¼‰å’Œå¯å‘å¼å®è·µç»éªŒã€‚

Conclusion: ç»“è®ºå¼ºè°ƒäº†ç ”ç©¶ä»£ç æ™ºèƒ½å½±å“çš„å¿…è¦æ€§ï¼Œå¹¶ä¸ºè½¯ä»¶å·¥ç¨‹å®è·µæä¾›äº†åŸºäºå®é™…æ•°æ®çš„æ´å¯Ÿã€‚

Abstract: In 2025, coding agents have seen a very rapid adoption. Coding agents leverage Large Language Models (LLMs) in ways that are markedly different from LLM-based code completion, making their study critical. Moreover, unlike LLM-based completion, coding agents leave visible traces in software repositories, enabling the use of MSR techniques to study their impact on SE practices. This paper documents the promises, perils, and heuristics that we have gathered from studying coding agent activity on GitHub.

</details>


### [39] [An Audit of Machine Learning Experiments on Software Defect Prediction](https://arxiv.org/abs/2601.18477)
*Giuseppe Destefanis,Leila Yousefi,Martin Shepperd,Allan Tucker,Stephen Swift,Steve Counsell,Mahir Arzoky*

Main category: cs.SE

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Background: Machine learning algorithms are widely used to predict defect prone software components. In this literature, computational experiments are the main means of evaluation, and the credibility of results depends on experimental design and reporting. Objective: This paper audits recent software defect prediction (SDP) studies by assessing their experimental design, analysis, and reporting practices against accepted norms from statistics, machine learning, and empirical software engineering. The aim is to characterise current practice and assess the reproducibility of published results. Method: We audited SDP studies indexed in SCOPUS between 2019 and 2023, focusing on design and analysis choices such as outcome measures, out of sample validation strategies, and the use of statistical inference. Nine study issues were evaluated. Reproducibility was assessed using the instrument proposed by GonzÃ¡lez Barahona and Robles. Results: The search identified approximately 1,585 SDP experiments published during the period. From these, we randomly sampled 101 papers, including 61 journal and 40 conference publications, with almost 50 percent behind paywalls. We observed substantial variation in research practice. The number of datasets ranged from 1 to 365, learners or learner variants from 1 to 34, and performance measures from 1 to 9. About 45 percent of studies applied formal statistical inference. Across the sample, we identified 427 issues, with a median of four per paper, and only one paper without issues. Reproducibility ranged from near complete to severely limited. We also identified two cases of tortured phrases and possible paper mill activity. Conclusions: Experimental design and reporting practices vary widely, and almost half of the studies provide insufficient detail to support reproduction. The audit indicates substantial scope for improvement.

</details>


### [40] [On the Abolition of the "ICSE Paper" and the Adoption of the "Registered Proposal" and the "Results Report"](https://arxiv.org/abs/2601.18566)
*Fabio Massacci,Winnie Mbaka*

Main category: cs.SE

TL;DR: è®ºæ–‡æå‡ºåºŸé™¤ä¼ ç»ŸICSEè®ºæ–‡ï¼Œå¼•å…¥åŒå±‚ç³»ç»Ÿï¼šæ³¨å†Œææ¡ˆå®¡æ ¸æ–°æƒ³æ³•ä¸æ–¹æ³•è®ºï¼Œç»“æœæŠ¥å‘Šå‘ˆç°å®è¯å·¥ä½œå¹¶è¿›è¡Œè¯„å®¡ã€‚


<details>
  <summary>Details</summary>
Motivation: ä¸ºè§£å†³è½¯ä»¶å·¥ç¨‹é¢†åŸŸçš„'æ–°é¢–æ€§æ¶æ€§å¾ªç¯'å’Œ'å¯å¤åˆ¶æ€§å±æœº'ï¼ŒåŸºäºç¤¾åŒºé¢„è°ƒæŸ¥çš„æ”¯æŒã€‚

Method: åˆ›å»ºä¸¤é˜¶æ®µæµç¨‹ï¼šç¬¬ä¸€å¹´æäº¤æ³¨å†Œææ¡ˆè¿›è¡ŒåŒè¡Œè¯„å®¡ï¼Œæ¬¡å¹´æäº¤ç»“æœæŠ¥å‘ŠåŸºäºè¯¥ææ¡ˆçš„å®è¯å·¥ä½œã€‚

Result: è®ºè¯è¿™ä¸€é¢ è¦†æ€§æè®®å—ç¤¾åŒºå“åº”æ”¯æŒï¼Œé‡æ„ä¼šè®®å‘è¡¨æœºåˆ¶ã€‚

Conclusion: ç³»ç»Ÿæ—¨åœ¨æå‡ç ”ç©¶å¯å¤åˆ¶æ€§ï¼Œå¹¶ä½¿ä¸¤ç±»å·¥ä½œæˆä¸ºä¼šè®®ä¸»æµç»„æˆéƒ¨åˆ†ã€‚

Abstract: To address the 'novelty-vicious cycle' and the 'replicability crisis' of the field (both discussed in the survey) we propose abolishing the "ICSE paper" as we know it and replacing it with a two-tier system that also evolves the existing notion of 'Registered Report'. Authors proposing a new idea, experiment, or analysis would submit a "Registered Proposal" of their idea and the proposed experimental methodology to undergo peer review. The following year, anyone can submit (shorter) "Results Reports" on the realization of the empirical work based on the registered proposals of the previous ICSE (or FSE or ISSTA or ASE etc.). Both works should be first class citizens of the mainstream events. We argue that such a disruptive (heretical?) idea is supported and based on the responses of the community of the Future of Software Engineering pre-survey

</details>


### [41] [How are MLOps Frameworks Used in Open Source Projects? An Empirical Characterization](https://arxiv.org/abs/2601.18591)
*Fiorella Zampetti,Federico Stocchetti,Federica Razzano,Damian Andrew Tamburri,Massimiliano Di Penta*

Main category: cs.SE

TL;DR: ç ”ç©¶é€šè¿‡GitHubä½¿ç”¨æ•°æ®å’Œå¼€æºé—®é¢˜è·Ÿè¸ªå™¨ï¼Œåˆ†æäº†å…«ç§æµè¡Œå¼€æºMLOpsæ¡†æ¶çš„å®é™…ä½¿ç”¨åœºæ™¯ä¸åŠŸèƒ½æ”¹è¿›éœ€æ±‚ã€‚


<details>
  <summary>Details</summary>
Motivation: è¯†åˆ«æ¡†æ¶æä¾›çš„åŠŸèƒ½ä¸å®é™…ä½¿ç”¨éœ€æ±‚çš„å·®å¼‚

Method: 1) åˆ†æGitHubä¾èµ–é¡¹ç›®çš„APIè°ƒç”¨è¡Œä¸º 2) å®šæ€§ç ”ç©¶æ¡†æ¶é—®é¢˜è·Ÿè¸ªå™¨çš„åŠŸèƒ½è¯·æ±‚

Result: å¼€å‘è€…ä¸»è¦è°ƒç”¨APIå®ç°å®šåˆ¶åŠŸèƒ½ï¼Œè¾ƒå°‘ç›´æ¥ä½¿ç”¨æ¡†æ¶ï¼›éœ€æ±‚é›†ä¸­äºæ ¸å¿ƒåŠŸèƒ½å¢å¼ºã€APIä¼˜åŒ–åŠCI/CDé›†æˆ

Conclusion: MLOpsæ¡†æ¶éœ€åŠ å¼ºæ ¸å¿ƒåŠŸèƒ½çµæ´»æ€§å¹¶æ”¹è¿›CI/CDé›†æˆä»¥æ»¡è¶³å®šåˆ¶åŒ–å¼€å‘éœ€æ±‚

Abstract: Machine Learning (ML) Operations (MLOps) frameworks have been conceived to support developers and AI engineers in managing the lifecycle of their ML models. While such frameworks provide a wide range of features, developers may leverage only a subset of them, while missing some highly desired features. This paper investigates the practical use and desired feature enhancements of eight popular open-source MLOps frameworks. Specifically, we analyze their usage by dependent projects on GitHub, examining how they invoke the frameworks' APIs and commands. Then, we qualitatively analyze feature requests and enhancements mined from the frameworks' issue trackers, relating these desired improvements to the previously identified usage features. Results indicate that MLOps frameworks are rarely used out-of-the-box and are infrequently integrated into GitHub Workflows, but rather, developers use their APIs to implement custom functionality in their projects. Used features concern core ML phases and whole infrastructure governance, sometimes leveraging multiple frameworks with complementary features. The mapping with feature requests highlights that users mainly ask for enhancements to core features of the frameworks, but also better API exposure and CI/CD integration.

</details>


<div id='cs.PF'></div>

# cs.PF [[Back]](#toc)

### [42] [GreenServ: Energy-Efficient Context-Aware Dynamic Routing for Multi-Model LLM Inference](https://arxiv.org/abs/2601.17551)
*Thomas Ziller,Shashikant Ilager,Alessandro Tundo,Ezio Bartocci,Leonardo Mariani,Ivona Brandic*

Main category: cs.PF

TL;DR: Summary generation failed


<details>
  <summary>Details</summary>
Motivation: Motivation analysis unavailable

Method: Method extraction failed

Result: Result analysis unavailable

Conclusion: Conclusion extraction failed

Abstract: Large language models (LLMs) demonstrate remarkable capabilities, but their broad deployment is limited by significant computational resource demands, particularly energy consumption during inference. Static, one-model-fits-all inference strategies are often inefficient, as they do not exploit the diverse range of available models or adapt to varying query requirements.
  This paper presents GreenServ, a dynamic, context-aware routing framework that optimizes the trade-off between inference accuracy and energy efficiency. GreenServ extracts lightweight contextual features from each query, including task type, semantic cluster, and text complexity, and routes queries to the most suitable model from a heterogeneous pool, based on observed accuracy and energy usage. We employ a multi-armed bandit approach to learn adaptive routing policies online. This approach operates under partial feedback, eliminates the need for extensive offline calibration, and streamlines the integration of new models into the inference pipeline.
  We evaluated GreenServ across five benchmark tasks and a pool of 16 contemporary open-access LLMs. Experimental results show that GreenServ consistently outperforms static (single-model) and random baselines. In particular, compared to random routing, GreenServ achieved a 22% increase in accuracy while reducing cumulative energy consumption by 31%. Finally, we evaluated GreenServ with RouterBench, achieving an average accuracy of 71.7% with a peak accuracy of 75.7%. All artifacts are open-source and available as an anonymous repository for review purposes here: https://anonymous.4open.science/r/llm-inference-router-EBEA/README.md

</details>
